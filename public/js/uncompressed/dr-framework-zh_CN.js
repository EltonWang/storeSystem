/*!
 * jQuery JavaScript Library v1.10.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03T13:48Z
 */
(function( window, undefined ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//"use strict";
var
	// The deferred used on DOM ready
	readyList,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// Support: IE<10
	// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`
	core_strundefined = typeof undefined,

	// Use the correct document accordingly with window argument (sandbox)
	location = window.location,
	document = window.document,
	docElem = document.documentElement,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// [[Class]] -> type pairs
	class2type = {},

	// List of deleted data cache ids, so we can reuse them
	core_deletedIds = [],

	core_version = "1.10.2",

	// Save a reference to some core methods
	core_concat = core_deletedIds.concat,
	core_push = core_deletedIds.push,
	core_slice = core_deletedIds.slice,
	core_indexOf = core_deletedIds.indexOf,
	core_toString = class2type.toString,
	core_hasOwn = class2type.hasOwnProperty,
	core_trim = core_version.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,

	// Used for splitting on whitespace
	core_rnotwhite = /\S+/g,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	},

	// The ready event handler
	completed = function( event ) {

		// readyState === "complete" is good enough for us to call the dom ready in oldIE
		if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
			detach();
			jQuery.ready();
		}
	},
	// Clean-up method for dom ready events
	detach = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", completed, false );
			window.removeEventListener( "load", completed, false );

		} else {
			document.detachEvent( "onreadystatechange", completed );
			window.detachEvent( "onload", completed );
		}
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: core_version,

	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),

	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return String( obj );
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ core_toString.call(obj) ] || "object" :
			typeof obj;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( jQuery.support.ownLast ) {
			for ( key in obj ) {
				return core_hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );
		if ( scripts ) {
			jQuery( scripts ).remove();
		}
		return jQuery.merge( [], parsed.childNodes );
	},

	parseJSON: function( data ) {
		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		if ( data === null ) {
			return data;
		}

		if ( typeof data === "string" ) {

			// Make sure leading/trailing whitespace is removed (IE can't handle it)
			data = jQuery.trim( data );

			if ( data ) {
				// Make sure the incoming data is actual JSON
				// Logic borrowed from http://json.org/json2.js
				if ( rvalidchars.test( data.replace( rvalidescape, "@" )
					.replace( rvalidtokens, "]" )
					.replace( rvalidbraces, "")) ) {

					return ( new Function( "return " + data ) )();
				}
			}
		}

		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				core_push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return core_concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			length = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < length; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations.
	// Note: this method belongs to the css module but it's needed here for the support module.
	// If support gets modularized, this method should be moved back to the css module.
	swap: function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || type !== "function" &&
		( length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj );
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
/*!
 * Sizzle CSS Selector Engine v1.10.2
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03
 */
(function( window, undefined ) {

var i,
	support,
	cachedruns,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	hasDuplicate = false,
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rsibling = new RegExp( whitespace + "*[+~]" ),
	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			// BMP codepoint
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && context.parentNode || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key += " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Detect xml
 * @param {Element|Object} elem An element or a document
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent.attachEvent && parent !== parent.top ) {
		parent.attachEvent( "onbeforeunload", function() {
			setDocument();
		});
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Support: Opera 10-12/IE8
			// ^= $= *= and empty values
			// Should not select anything
			// Support: Windows 8 Native Apps
			// The type attribute is restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "t", "" );

			if ( div.querySelectorAll("[t^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );

		if ( compare ) {
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === doc || contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		}

		// Not directly comparable, sort on existence of method
		return a.compareDocumentPosition ? -1 : 1;
	} :
	function( a, b ) {
		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Parentless nodes are either documents or disconnected
		} else if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val === undefined ?
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null :
		val;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (see #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] && match[4] !== undefined ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var data, cache, outerCache,
				dirkey = dirruns + " " + doneName;

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
							if ( (data = cache[1]) === true || data === cachedruns ) {
								return data === true;
							}
						} else {
							cache = outerCache[ dir ] = [ dirkey ];
							cache[1] = matcher( elem, context, xml ) || cachedruns;
							if ( cache[1] === true ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	// A counter to specify which element is currently being matched
	var matcherCachedRuns = 0,
		bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = matcherCachedRuns;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++matcherCachedRuns;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
				}
				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && context.parentNode || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector )
	);
	return results;
}

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return (val = elem.getAttributeNode( name )) && val.specified ?
				val.value :
				elem[ name ] === true ? name.toLowerCase() : null;
		}
	});
}

jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function( support ) {

	var all, a, input, select, fragment, opt, eventName, isSupported, i,
		div = document.createElement("div");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// Finish early in limited (non-browser) environments
	all = div.getElementsByTagName("*") || [];
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !a || !a.style || !all.length ) {
		return support;
	}

	// First batch of tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName("tbody").length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName("link").length;

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute("style") );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Make sure that element opacity exists
	// (IE uses filter instead)
	// Use a regex to work around a WebKit issue. See #5145
	support.opacity = /^0.5/.test( a.style.opacity );

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!a.style.cssFloat;

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement("form").enctype;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone = document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Will be defined later
	support.inlineBlockNeedsLayout = false;
	support.shrinkWrapBlocks = false;
	support.pixelPosition = false;
	support.deleteExpando = true;
	support.noCloneEvent = true;
	support.reliableMarginRight = true;
	support.boxSizingReliable = true;

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<9
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	// Check if we can trust getAttribute("value")
	input = document.createElement("input");
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "checked", "t" );
	input.setAttribute( "name", "t" );

	fragment = document.createDocumentFragment();
	fragment.appendChild( input );

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
	// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
	for ( i in { submit: true, change: true, focusin: true }) {
		div.setAttribute( eventName = "on" + i, "t" );

		support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Support: IE<9
	// Iteration over object's inherited properties before its own.
	for ( i in jQuery( support ) ) {
		break;
	}
	support.ownLast = i !== "0";

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, marginDiv, tds,
			divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

		body.appendChild( container ).appendChild( div );

		// Support: IE8
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Support: IE8
		// Check if empty table cells still have offsetWidth/Height
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior.
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";

		// Workaround failing boxSizing test due to offsetWidth returning wrong value
		// with some non-1 values of body zoom, ticket #13543
		jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
			support.boxSizing = div.offsetWidth === 4;
		});

		// Use window.getComputedStyle because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = div.appendChild( document.createElement("div") );
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";

			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== core_strundefined ) {
			// Support: IE<8
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Support: IE6
			// Check if elements with layout shrink-wrap their children
			div.style.display = "block";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			if ( support.inlineBlockNeedsLayout ) {
				// Prevent IE 6 from affecting layout for positioned elements #11048
				// Prevent IE from shrinking the body in IE 7 mode #12869
				// Support: IE<8
				body.style.zoom = 1;
			}
		}

		body.removeChild( container );

		// Null elements to avoid leaks in IE
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	all = select = fragment = opt = a = input = null;

	return support;
})({});

var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

function internalData( elem, name, data, pvt /* Internal Use Only */ ){
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = core_deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"applet": true,
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		// Do not set data on non-element because it will not be cleared (#8335).
		if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {
			return false;
		}

		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var attrs, name,
			data = null,
			i = 0,
			elem = this[0];

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attrs = elem.attributes;
					for ( ; i < attrs.length; i++ ) {
						name = attrs[i].name;

						if ( name.indexOf("data-") === 0 ) {
							name = jQuery.camelCase( name.slice(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook,
	rclass = /[\t\r\n\f]/g,
	rreturn = /\r/g,
	rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	getSetInput = jQuery.support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}
					elem.className = jQuery.trim( cur );

				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}
					elem.className = value ? jQuery.trim( cur ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( core_rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === core_strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var ret, hooks, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// Use proper attribute retrieval(#6932, #12072)
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === core_strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( core_rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;

	jQuery.expr.attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var fn = jQuery.expr.attrHandle[ name ],
				ret = isXML ?
					undefined :
					/* jshint eqeqeq: false */
					(jQuery.expr.attrHandle[ name ] = undefined) !=
						getter( elem, name, isXML ) ?

						name.toLowerCase() :
						null;
			jQuery.expr.attrHandle[ name ] = fn;
			return ret;
		} :
		function( elem, name, isXML ) {
			return isXML ?
				undefined :
				elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
		};
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			return name === "value" || value === elem.getAttribute( name ) ?
				value :
				undefined;
		}
	};
	jQuery.expr.attrHandle.id = jQuery.expr.attrHandle.name = jQuery.expr.attrHandle.coords =
		// Some attributes are constructed with empty-string values when not defined
		function( elem, name, isXML ) {
			var ret;
			return isXML ?
				undefined :
				(ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
		};
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			return ret && ret.specified ?
				ret.value :
				undefined;
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}


// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !jQuery.support.hrefNormalized ) {
	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !jQuery.support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});
var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = core_hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = core_slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Even when returnValue equals to undefined Firefox will still show alert
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === core_strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});
var isSimple = /^.[^:#\[\.,]*$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},

	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					cur = ret.push( cur );
					break;
				}
			}
		}

		return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( jQuery.unique(all) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var
			// Snapshot the DOM in case .domManip sweeps something relevant into its fragment
			args = jQuery.map( this, function( elem ) {
				return [ elem.nextSibling, elem.parentNode ];
			}),
			i = 0;

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			var next = args[ i++ ],
				parent = args[ i++ ];

			if ( parent ) {
				// Don't use the snapshot next if it has moved (#13810)
				if ( next && next.parentNode !== parent ) {
					next = this.nextSibling;
				}
				jQuery( this ).remove();
				parent.insertBefore( elem, next );
			}
		// Allow new content to include elements from the context set
		}, true );

		// Force removal if there was no new content (e.g., from empty arguments)
		return i ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback, allowIntersection ) {

		// Flatten any nested arrays
		args = core_concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback, allowIntersection );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Hope ajax is available...
								jQuery._evalUrl( node.src );
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			core_push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( manipulation_rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== core_strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						core_deletedIds.push( id );
					}
				}
			}
		}
	},

	_evalUrl: function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	}
});
jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});
var iframe, getStyles, curCSS,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	// isHidden might be called from jQuery#filter function;
	// in that case, element will be second argument
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			var len, styles,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

// NOTE: we've included the "window" in window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, _computed ) {
		var width, minWidth, maxWidth,
			computed = _computed || getStyles( elem ),

			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
			style = elem.style;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, _computed ) {
		var left, rs, rsLeft,
			computed = _computed || getStyles( elem ),
			ret = computed ? computed[ name ] : undefined,
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {
			// Use the already-created iframe if possible
			iframe = ( iframe ||
				jQuery("<iframe frameborder='0' width='0' height='0'/>")
				.css( "cssText", "display:block !important" )
			).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
			doc.write("<!doctype html><html><body>");
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}

// Called ONLY from within css_defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
		display = jQuery.css( elem[0], "display" );
	elem.remove();
	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				if ( computed ) {
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// Work around by temporarily setting element display to inline-block
					return jQuery.swap( elem, { "display": "inline-block" },
						curCSS, [ elem, "marginRight" ] );
				}
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						computed = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( computed ) ?
							jQuery( elem ).position()[ prop ] + "px" :
							computed;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
			(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function(){
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !manipulation_rcheckableType.test( type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});
var
	// Document location
	ajaxLocParts,
	ajaxLocation,
	ajax_nonce = jQuery.now(),

	ajax_rquery = /\?/,
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
	jQuery.fn[ type ] = function( fn ){
		return this.on( type, fn );
	};
});

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});
var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
var xhrCallbacks, xhrSupported,
	xhrId = 0,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject && function() {
		// Abort all pending requests
		var key;
		for ( key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	};

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject("Microsoft.XMLHTTP");
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
xhrSupported = jQuery.ajaxSettings.xhr();
jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = jQuery.support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( err ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, responseHeaders, statusText, responses;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									responses = {};
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									if ( typeof xhr.responseText === "string" ) {
										responses.text = xhr.responseText;
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) ) {
		jQuery.fx.start();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, win,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	return {
		top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
		left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
	};
};

jQuery.offset = {

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;
			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Limit scope pollution from any deprecated API
// (function() {

// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;

// })();
if ( typeof module === "object" && module && typeof module.exports === "object" ) {
	// Expose jQuery as module.exports in loaders that implement the Node
	// module pattern (including browserify). Do not create the global, since
	// the user will be storing it themselves locally, and globals are frowned
	// upon in the Node module world.
	module.exports = jQuery;
} else {
	// Otherwise expose jQuery to the global object as usual
	window.jQuery = window.$ = jQuery;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	if ( typeof define === "function" && define.amd ) {
		define( "jquery", [], function () { return jQuery; } );
	}
}

})( window );

/*!
 * jQuery Migrate - v1.2.1 - 2013-05-08
 * https://github.com/jquery/jquery-migrate
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors; Licensed MIT
 */
(function( jQuery, window, undefined ) {
// See http://bugs.jquery.com/ticket/13335
// "use strict";


var warnedAbout = {};

// List of warnings already given; public read only
jQuery.migrateWarnings = [];

// Set to true to prevent console output; migrateWarnings still maintained
// jQuery.migrateMute = false;

// Show a message on the console so devs know we're active
if ( !jQuery.migrateMute && window.console && window.console.log ) {
	window.console.log("JQMIGRATE: Logging is active");
}

// Set to false to disable traces that appear with warnings
if ( jQuery.migrateTrace === undefined ) {
	jQuery.migrateTrace = true;
}

// Forget any warnings we've already given; public
jQuery.migrateReset = function() {
	warnedAbout = {};
	jQuery.migrateWarnings.length = 0;
};

function migrateWarn( msg) {
	var console = window.console;
	if ( !warnedAbout[ msg ] ) {
		warnedAbout[ msg ] = true;
		jQuery.migrateWarnings.push( msg );
		if ( console && console.warn && !jQuery.migrateMute ) {
			console.warn( "JQMIGRATE: " + msg );
			if ( jQuery.migrateTrace && console.trace ) {
				console.trace();
			}
		}
	}
}

function migrateWarnProp( obj, prop, value, msg ) {
	if ( Object.defineProperty ) {
		// On ES5 browsers (non-oldIE), warn if the code tries to get prop;
		// allow property to be overwritten in case some other plugin wants it
		try {
			Object.defineProperty( obj, prop, {
				configurable: true,
				enumerable: true,
				get: function() {
					migrateWarn( msg );
					return value;
				},
				set: function( newValue ) {
					migrateWarn( msg );
					value = newValue;
				}
			});
			return;
		} catch( err ) {
			// IE8 is a dope about Object.defineProperty, can't warn there
		}
	}

	// Non-ES5 (or broken) browser; just set the property
	jQuery._definePropertyBroken = true;
	obj[ prop ] = value;
}

if ( document.compatMode === "BackCompat" ) {
	// jQuery has never supported or tested Quirks Mode
	migrateWarn( "jQuery is not compatible with Quirks Mode" );
}


var attrFn = jQuery( "<input/>", { size: 1 } ).attr("size") && jQuery.attrFn,
	oldAttr = jQuery.attr,
	valueAttrGet = jQuery.attrHooks.value && jQuery.attrHooks.value.get ||
		function() { return null; },
	valueAttrSet = jQuery.attrHooks.value && jQuery.attrHooks.value.set ||
		function() { return undefined; },
	rnoType = /^(?:input|button)$/i,
	rnoAttrNodeType = /^[238]$/,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	ruseDefault = /^(?:checked|selected)$/i;

// jQuery.attrFn
migrateWarnProp( jQuery, "attrFn", attrFn || {}, "jQuery.attrFn is deprecated" );

jQuery.attr = function( elem, name, value, pass ) {
	var lowerName = name.toLowerCase(),
		nType = elem && elem.nodeType;

	if ( pass ) {
		// Since pass is used internally, we only warn for new jQuery
		// versions where there isn't a pass arg in the formal params
		if ( oldAttr.length < 4 ) {
			migrateWarn("jQuery.fn.attr( props, pass ) is deprecated");
		}
		if ( elem && !rnoAttrNodeType.test( nType ) &&
			(attrFn ? name in attrFn : jQuery.isFunction(jQuery.fn[name])) ) {
			return jQuery( elem )[ name ]( value );
		}
	}

	// Warn if user tries to set `type`, since it breaks on IE 6/7/8; by checking
	// for disconnected elements we don't warn on $( "<button>", { type: "button" } ).
	if ( name === "type" && value !== undefined && rnoType.test( elem.nodeName ) && elem.parentNode ) {
		migrateWarn("Can't change the 'type' of an input or button in IE 6/7/8");
	}

	// Restore boolHook for boolean property/attribute synchronization
	if ( !jQuery.attrHooks[ lowerName ] && rboolean.test( lowerName ) ) {
		jQuery.attrHooks[ lowerName ] = {
			get: function( elem, name ) {
				// Align boolean attributes with corresponding properties
				// Fall back to attribute presence where some booleans are not supported
				var attrNode,
					property = jQuery.prop( elem, name );
				return property === true || typeof property !== "boolean" &&
					( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?

					name.toLowerCase() :
					undefined;
			},
			set: function( elem, value, name ) {
				var propName;
				if ( value === false ) {
					// Remove boolean attributes when set to false
					jQuery.removeAttr( elem, name );
				} else {
					// value is true since we know at this point it's type boolean and not false
					// Set boolean attributes to the same name and set the DOM property
					propName = jQuery.propFix[ name ] || name;
					if ( propName in elem ) {
						// Only set the IDL specifically if it already exists on the element
						elem[ propName ] = true;
					}

					elem.setAttribute( name, name.toLowerCase() );
				}
				return name;
			}
		};

		// Warn only for attributes that can remain distinct from their properties post-1.9
		if ( ruseDefault.test( lowerName ) ) {
			migrateWarn( "jQuery.fn.attr('" + lowerName + "') may use property instead of attribute" );
		}
	}

	return oldAttr.call( jQuery, elem, name, value );
};

// attrHooks: value
jQuery.attrHooks.value = {
	get: function( elem, name ) {
		var nodeName = ( elem.nodeName || "" ).toLowerCase();
		if ( nodeName === "button" ) {
			return valueAttrGet.apply( this, arguments );
		}
		if ( nodeName !== "input" && nodeName !== "option" ) {
			migrateWarn("jQuery.fn.attr('value') no longer gets properties");
		}
		return name in elem ?
			elem.value :
			null;
	},
	set: function( elem, value ) {
		var nodeName = ( elem.nodeName || "" ).toLowerCase();
		if ( nodeName === "button" ) {
			return valueAttrSet.apply( this, arguments );
		}
		if ( nodeName !== "input" && nodeName !== "option" ) {
			migrateWarn("jQuery.fn.attr('value', val) no longer sets properties");
		}
		// Does not return so that setAttribute is also used
		elem.value = value;
	}
};


var matched, browser,
	oldInit = jQuery.fn.init,
	oldParseJSON = jQuery.parseJSON,
	// Note: XSS check is done below after string is trimmed
	rquickExpr = /^([^<]*)(<[\w\W]+>)([^>]*)$/;

// $(html) "looks like html" rule change
jQuery.fn.init = function( selector, context, rootjQuery ) {
	var match;

	if ( selector && typeof selector === "string" && !jQuery.isPlainObject( context ) &&
			(match = rquickExpr.exec( jQuery.trim( selector ) )) && match[ 0 ] ) {
		// This is an HTML string according to the "old" rules; is it still?
		if ( selector.charAt( 0 ) !== "<" ) {
			migrateWarn("$(html) HTML strings must start with '<' character");
		}
		if ( match[ 3 ] ) {
			migrateWarn("$(html) HTML text after last tag is ignored");
		}
		// Consistently reject any HTML-like string starting with a hash (#9521)
		// Note that this may break jQuery 1.6.x code that otherwise would work.
		if ( match[ 0 ].charAt( 0 ) === "#" ) {
			migrateWarn("HTML string cannot start with a '#' character");
			jQuery.error("JQMIGRATE: Invalid selector string (XSS)");
		}
		// Now process using loose rules; let pre-1.8 play too
		if ( context && context.context ) {
			// jQuery object as context; parseHTML expects a DOM object
			context = context.context;
		}
		if ( jQuery.parseHTML ) {
			return oldInit.call( this, jQuery.parseHTML( match[ 2 ], context, true ),
					context, rootjQuery );
		}
	}
	return oldInit.apply( this, arguments );
};
jQuery.fn.init.prototype = jQuery.fn;

// Let $.parseJSON(falsy_value) return null
jQuery.parseJSON = function( json ) {
	if ( !json && json !== null ) {
		migrateWarn("jQuery.parseJSON requires a valid JSON string");
		return null;
	}
	return oldParseJSON.apply( this, arguments );
};

jQuery.uaMatch = function( ua ) {
	ua = ua.toLowerCase();

	var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		/(msie) ([\w.]+)/.exec( ua ) ||
		ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		[];

	return {
		browser: match[ 1 ] || "",
		version: match[ 2 ] || "0"
	};
};

// Don't clobber any existing jQuery.browser in case it's different
if ( !jQuery.browser ) {
	matched = jQuery.uaMatch( navigator.userAgent );
	browser = {};

	if ( matched.browser ) {
		browser[ matched.browser ] = true;
		browser.version = matched.version;
	}

	// Chrome is Webkit, but Webkit is also Safari.
	if ( browser.chrome ) {
		browser.webkit = true;
	} else if ( browser.webkit ) {
		browser.safari = true;
	}

	jQuery.browser = browser;
}

// Warn if the code tries to get jQuery.browser
migrateWarnProp( jQuery, "browser", jQuery.browser, "jQuery.browser is deprecated" );

jQuery.sub = function() {
	function jQuerySub( selector, context ) {
		return new jQuerySub.fn.init( selector, context );
	}
	jQuery.extend( true, jQuerySub, this );
	jQuerySub.superclass = this;
	jQuerySub.fn = jQuerySub.prototype = this();
	jQuerySub.fn.constructor = jQuerySub;
	jQuerySub.sub = this.sub;
	jQuerySub.fn.init = function init( selector, context ) {
		if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
			context = jQuerySub( context );
		}

		return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
	};
	jQuerySub.fn.init.prototype = jQuerySub.fn;
	var rootjQuerySub = jQuerySub(document);
	migrateWarn( "jQuery.sub() is deprecated" );
	return jQuerySub;
};


// Ensure that $.ajax gets the new parseJSON defined in core.js
jQuery.ajaxSetup({
	converters: {
		"text json": jQuery.parseJSON
	}
});


var oldFnData = jQuery.fn.data;

jQuery.fn.data = function( name ) {
	var ret, evt,
		elem = this[0];

	// Handles 1.7 which has this behavior and 1.8 which doesn't
	if ( elem && name === "events" && arguments.length === 1 ) {
		ret = jQuery.data( elem, name );
		evt = jQuery._data( elem, name );
		if ( ( ret === undefined || ret === evt ) && evt !== undefined ) {
			migrateWarn("Use of jQuery.fn.data('events') is deprecated");
			return evt;
		}
	}
	return oldFnData.apply( this, arguments );
};


var rscriptType = /\/(java|ecma)script/i,
	oldSelf = jQuery.fn.andSelf || jQuery.fn.addBack;

jQuery.fn.andSelf = function() {
	migrateWarn("jQuery.fn.andSelf() replaced by jQuery.fn.addBack()");
	return oldSelf.apply( this, arguments );
};

// Since jQuery.clean is used internally on older versions, we only shim if it's missing
if ( !jQuery.clean ) {
	jQuery.clean = function( elems, context, fragment, scripts ) {
		// Set context per 1.8 logic
		context = context || document;
		context = !context.nodeType && context[0] || context;
		context = context.ownerDocument || context;

		migrateWarn("jQuery.clean() is deprecated");

		var i, elem, handleScript, jsTags,
			ret = [];

		jQuery.merge( ret, jQuery.buildFragment( elems, context ).childNodes );

		// Complex logic lifted directly from jQuery 1.8
		if ( fragment ) {
			// Special handling of each script element
			handleScript = function( elem ) {
				// Check if we consider it executable
				if ( !elem.type || rscriptType.test( elem.type ) ) {
					// Detach the script and store it in the scripts array (if provided) or the fragment
					// Return truthy to indicate that it has been handled
					return scripts ?
						scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
						fragment.appendChild( elem );
				}
			};

			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				// Check if we're done after handling an executable script
				if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
					// Append to fragment and handle embedded scripts
					fragment.appendChild( elem );
					if ( typeof elem.getElementsByTagName !== "undefined" ) {
						// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
						jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );

						// Splice the scripts into ret after their former ancestor and advance our index beyond them
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
						i += jsTags.length;
					}
				}
			}
		}

		return ret;
	};
}

var eventAdd = jQuery.event.add,
	eventRemove = jQuery.event.remove,
	eventTrigger = jQuery.event.trigger,
	oldToggle = jQuery.fn.toggle,
	oldLive = jQuery.fn.live,
	oldDie = jQuery.fn.die,
	ajaxEvents = "ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess",
	rajaxEvent = new RegExp( "\\b(?:" + ajaxEvents + ")\\b" ),
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	hoverHack = function( events ) {
		if ( typeof( events ) !== "string" || jQuery.event.special.hover ) {
			return events;
		}
		if ( rhoverHack.test( events ) ) {
			migrateWarn("'hover' pseudo-event is deprecated, use 'mouseenter mouseleave'");
		}
		return events && events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

// Event props removed in 1.9, put them back if needed; no practical way to warn them
if ( jQuery.event.props && jQuery.event.props[ 0 ] !== "attrChange" ) {
	jQuery.event.props.unshift( "attrChange", "attrName", "relatedNode", "srcElement" );
}

// Undocumented jQuery.event.handle was "deprecated" in jQuery 1.7
if ( jQuery.event.dispatch ) {
	migrateWarnProp( jQuery.event, "handle", jQuery.event.dispatch, "jQuery.event.handle is undocumented and deprecated" );
}

// Support for 'hover' pseudo-event and ajax event warnings
jQuery.event.add = function( elem, types, handler, data, selector ){
	if ( elem !== document && rajaxEvent.test( types ) ) {
		migrateWarn( "AJAX events should be attached to document: " + types );
	}
	eventAdd.call( this, elem, hoverHack( types || "" ), handler, data, selector );
};
jQuery.event.remove = function( elem, types, handler, selector, mappedTypes ){
	eventRemove.call( this, elem, hoverHack( types ) || "", handler, selector, mappedTypes );
};

jQuery.fn.error = function() {
	var args = Array.prototype.slice.call( arguments, 0);
	migrateWarn("jQuery.fn.error() is deprecated");
	args.splice( 0, 0, "error" );
	if ( arguments.length ) {
		return this.bind.apply( this, args );
	}
	// error event should not bubble to window, although it does pre-1.7
	this.triggerHandler.apply( this, args );
	return this;
};

jQuery.fn.toggle = function( fn, fn2 ) {

	// Don't mess with animation or css toggles
	if ( !jQuery.isFunction( fn ) || !jQuery.isFunction( fn2 ) ) {
		return oldToggle.apply( this, arguments );
	}
	migrateWarn("jQuery.fn.toggle(handler, handler...) is deprecated");

	// Save reference to arguments for access in closure
	var args = arguments,
		guid = fn.guid || jQuery.guid++,
		i = 0,
		toggler = function( event ) {
			// Figure out which function to execute
			var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
			jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

			// Make sure that clicks stop
			event.preventDefault();

			// and execute the function
			return args[ lastToggle ].apply( this, arguments ) || false;
		};

	// link all the functions, so any of them can unbind this click handler
	toggler.guid = guid;
	while ( i < args.length ) {
		args[ i++ ].guid = guid;
	}

	return this.click( toggler );
};

jQuery.fn.live = function( types, data, fn ) {
	migrateWarn("jQuery.fn.live() is deprecated");
	if ( oldLive ) {
		return oldLive.apply( this, arguments );
	}
	jQuery( this.context ).on( types, this.selector, data, fn );
	return this;
};

jQuery.fn.die = function( types, fn ) {
	migrateWarn("jQuery.fn.die() is deprecated");
	if ( oldDie ) {
		return oldDie.apply( this, arguments );
	}
	jQuery( this.context ).off( types, this.selector || "**", fn );
	return this;
};

// Turn global events into document-triggered events
jQuery.event.trigger = function( event, data, elem, onlyHandlers  ){
	if ( !elem && !rajaxEvent.test( event ) ) {
		migrateWarn( "Global events are undocumented and deprecated" );
	}
	return eventTrigger.call( this,  event, data, elem || document, onlyHandlers  );
};
jQuery.each( ajaxEvents.split("|"),
	function( _, name ) {
		jQuery.event.special[ name ] = {
			setup: function() {
				var elem = this;

				// The document needs no shimming; must be !== for oldIE
				if ( elem !== document ) {
					jQuery.event.add( document, name + "." + jQuery.guid, function() {
						jQuery.event.trigger( name, null, elem, true );
					});
					jQuery._data( this, name, jQuery.guid++ );
				}
				return false;
			},
			teardown: function() {
				if ( this !== document ) {
					jQuery.event.remove( document, name + "." + jQuery._data( this, name ) );
				}
				return false;
			}
		};
	}
);


})( jQuery, window );;
(function($){
	var uaMatch = function(ua) {
		ua = ua.toLowerCase();
		var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
			/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
			/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
			/(msie) ([\w.]+)/.exec( ua ) ||
			ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
			[];
		return {
			browser: match[ 1 ] || "",
			version: match[ 2 ] || "0"
		};
	};
	matched = uaMatch( navigator.userAgent );
	browser = {};
	if ( matched.browser ) {
		browser[ matched.browser ] = true;
		browser.version = matched.version;
	}
	// Chrome is Webkit, but Webkit is also Safari.
	if ( browser.chrome || browser.webkit) {
		browser.webkit = true;
		browser.safari = true;
	}
	$.browser = browser;

	/*
	 *
	 * Overrides the jQuery attr function to allow for setting attributes and their related properties pre-1.6 style.
	 * e.g. .attr("checked", "checked") ;  .attr("checked", "") ; .attr("disabled", "disabled") ; .attr("disabled", "")
	 * 
	 */
	// Store a reference to the original attr method.
	var originalAttr = jQuery.fn.attr;
	var attrs = ["disabled", "checked", "selected", "readonly", "multiple"];
	//Overriding jQuery's attr method.
	jQuery.fn.attr = function(){
		if (arguments.length > 1 && $.inArray(arguments[0], attrs) > -1 && ($.inArray(arguments[1], attrs) > -1 || arguments[1] === "")) {
			var arguments1 = arguments[1];
			//grab the matched attr
			arguments[1] = (_.find(attrs, function(attr){ return attr == arguments1}) === arguments[1])
		} else if (arguments.length === 1 && $.inArray(arguments[0], attrs) > -1) {
			return jQuery.fn.prop.apply(this, arguments);
		}
		// Execute the original method.
		return originalAttr.apply( this, arguments );
	}
})(jQuery);;
/*
 * jQuery Address Plugin v1.5
 * deeplink.js
 * http://www.asual.com/jquery/address/
 *
 * Copyright (c) 2009-2010 Rostislav Hristov
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Date: 2012-11-18 23:51:44 +0200 (Sun, 18 Nov 2012)
 */
(function ($) {

    $.address = (function () {

        var _trigger = function(name) {
               var ev = $.extend($.Event(name), 
                 (function() {
                            var parameters = {},
                                parameterNames = $.address.parameterNames();
                            for (var i = 0, l = parameterNames.length; i < l; i++) {
                                parameters[parameterNames[i]] = $.address.parameter(parameterNames[i]);
                            }
                            return {
                                value: $.address.value(),
                                path: $.address.path(),
                                pathNames: $.address.pathNames(),
                                parameterNames: parameterNames,
                                parameters: parameters,
                                queryString: $.address.queryString()
                            };
                        }).call($.address)
                    );

               $($.address).trigger(ev);
               return ev;
            },
            _array = function(obj) {
                return Array.prototype.slice.call(obj);
            },
            _bind = function(value, data, fn) {
                $().bind.apply($($.address), Array.prototype.slice.call(arguments));
                return $.address;
            },
            _unbind = function(value,  fn) {
                $().unbind.apply($($.address), Array.prototype.slice.call(arguments));
                return $.address;
            },
            _supportsState = function() {
                return (_h.pushState && _opts.state !== UNDEFINED);
            },
            _hrefState = function() {
                return ('/' + _l.pathname.replace(new RegExp(_opts.state), '') + 
                    _l.search + (_hrefHash() ? '#' + _hrefHash() : '')).replace(_re, '/');
            },
            _hrefHash = function() {
                var index = _l.href.indexOf('#');
                return index != -1 ? _crawl(_l.href.substr(index + 1), FALSE) : '';
            },
            _href = function() {
                return _supportsState() ? _hrefState() : _hrefHash();
            },
            _window = function() {
                try {
                    return top.document !== UNDEFINED && top.document.title !== UNDEFINED ? top : window;
                } catch (e) { 
                    return window;
                }
            },
            _js = function() {
                return 'javascript';
            },
            _strict = function(value) {
                value = value.toString();
                return (_opts.strict && value.substr(0, 1) != '/' ? '/' : '') + value;
            },
            _crawl = function(value, direction) {
                if (_opts.crawlable && direction) {
                    return (value !== '' ? '!' : '') + value;
                }
                return value.replace(/^\!/, '');
            },
            _cssint = function(el, value) {
                return parseInt(el.css(value), 10);
            },
            
            // Hash Change Callback
            _listen = function() {
                if (!_silent) {
                    var hash = _href(),
                        diff = decodeURI(_value) != decodeURI(hash);
                    if (diff) {
                        if (_msie && _version < 7) {
                            _l.reload();
                        } else {
                            if (_msie && !_hashchange && _opts.history) {
                                _st(_html, 50);
                            }
                            _old = _value;
                            _value = hash;
                            _update(FALSE);
                        }
                    }
                }
            },

            _update = function(internal) {
                var changeEv = _trigger(CHANGE),
                    xChangeEv = _trigger(internal ? INTERNAL_CHANGE : EXTERNAL_CHANGE);
                
                _st(_track, 10);

                if (changeEv.isDefaultPrevented() || xChangeEv.isDefaultPrevented()){
                  _preventDefault();
                }
            },

            _preventDefault = function(){
              _value = _old;
              
              if (_supportsState()) {
                  _h.popState({}, '', _opts.state.replace(/\/$/, '') + (_value === '' ? '/' : _value));
              } else {
                  _silent = TRUE;
                  if (_webkit) {
                      if (_opts.history) {
                          _l.hash = '#' + _crawl(_value, TRUE);
                      } else {
                          _l.replace('#' + _crawl(_value, TRUE));
                      }
                  } else if (_value != _href()) {
                      if (_opts.history) {
                          _l.hash = '#' + _crawl(_value, TRUE);
                      } else {
                          _l.replace('#' + _crawl(_value, TRUE));
                      }
                  }
                  if ((_msie && !_hashchange) && _opts.history) {
                      _st(_html, 50);
                  }
                  if (_webkit) {
                      _st(function(){ _silent = FALSE; }, 1);
                  } else {
                      _silent = FALSE;
                  }
              }
              
            },

            _track = function() {
                if (_opts.tracker !== 'null' && _opts.tracker !== NULL) {
                    var fn = $.isFunction(_opts.tracker) ? _opts.tracker : _t[_opts.tracker],
                        value = (_l.pathname + _l.search + 
                                ($.address && !_supportsState() ? $.address.value() : ''))
                                .replace(/\/\//, '/').replace(/^\/$/, '');
                    if ($.isFunction(fn)) {
                        fn(value);
                    } else if ($.isFunction(_t.urchinTracker)) {
                        _t.urchinTracker(value);
                    } else if (_t.pageTracker !== UNDEFINED && $.isFunction(_t.pageTracker._trackPageview)) {
                        _t.pageTracker._trackPageview(value);
                    } else if (_t._gaq !== UNDEFINED && $.isFunction(_t._gaq.push)) {
                        _t._gaq.push(['_trackPageview', decodeURI(value)]);
                    }
                }
            },
            _html = function() {
                var src = _js() + ':' + FALSE + ';document.open();document.writeln(\'<html><head><title>' + 
                    _d.title.replace(/\'/g, '\\\'') + '</title><script>var ' + ID + ' = "' + encodeURIComponent(_href()).replace(/\'/g, '\\\'') + 
                    (_d.domain != _l.hostname ? '";document.domain="' + _d.domain : '') + 
                    '";</' + 'script></head></html>\');document.close();';
                if (_version < 7) {
                    _frame.src = src;
                } else {
                    _frame.contentWindow.location.replace(src);
                }
            },
            _options = function() {
                if (_url && _qi != -1) {
                    var i, param, params = _url.substr(_qi + 1).split('&');
                    for (i = 0; i < params.length; i++) {
                        param = params[i].split('=');
                        if (/^(autoUpdate|crawlable|history|strict|wrap)$/.test(param[0])) {
                            _opts[param[0]] = (isNaN(param[1]) ? /^(true|yes)$/i.test(param[1]) : (parseInt(param[1], 10) !== 0));
                        }
                        if (/^(state|tracker)$/.test(param[0])) {
                            _opts[param[0]] = param[1];
                        }
                    }
                    _url = NULL;
                }
                _old = _value;
                _value = _href();
            },
            _load = function() {
                if (!_loaded) {
                    _options();
                    var complete = function() {
                            _enable.call(this);
                            _unescape.call(this);
                        },
                        body = $(document).ajaxComplete(complete).find("body");
                    complete();
                    if (_opts.wrap) {
                        var wrap = $('body > *')
                            .wrapAll('<div style="padding:' + 
                                (_cssint(body, 'marginTop') + _cssint(body, 'paddingTop')) + 'px ' + 
                                (_cssint(body, 'marginRight') + _cssint(body, 'paddingRight')) + 'px ' + 
                                (_cssint(body, 'marginBottom') + _cssint(body, 'paddingBottom')) + 'px ' + 
                                (_cssint(body, 'marginLeft') + _cssint(body, 'paddingLeft')) + 'px;" />')
                            .parent()
                            .wrap('<div id="' + ID + '" style="height:100%;overflow:auto;position:relative;' + 
                                (_webkit && !window.statusbar.visible ? 'resize:both;' : '') + '" />');
                        $('html, body')
                            .css({
                                height: '100%',
                                margin: 0,
                                padding: 0,
                                overflow: 'hidden'
                            });
                        if (_webkit) {
                            $('<style type="text/css" />')
                                .appendTo('head')
                                .text('#' + ID + '::-webkit-resizer { background-color: #fff; }');
                        }
                    }
                    if (_msie && !_hashchange) {
                        var frameset = _d.getElementsByTagName('frameset')[0];
                        _frame = _d.createElement((frameset ? '' : 'i') + 'frame');
                        _frame.src = _js() + ':' + FALSE;
                        if (frameset) {
                            frameset.insertAdjacentElement('beforeEnd', _frame);
                            frameset[frameset.cols ? 'cols' : 'rows'] += ',0';
                            _frame.noResize = TRUE;
                            _frame.frameBorder = _frame.frameSpacing = 0;
                        } else {
                            _frame.style.display = 'none';
                            _frame.style.width = _frame.style.height = 0;
                            _frame.tabIndex = -1;
                            _d.body.insertAdjacentElement('afterBegin', _frame);
                        }
                        _st(function() {
                            $(_frame).bind('load', function() {
                                var win = _frame.contentWindow;
                                _old = _value;
                                _value = win[ID] !== UNDEFINED ? win[ID] : '';
                                if (_value != _href()) {
                                    _update(FALSE);
                                    _l.hash = _crawl(_value, TRUE);
                                }
                            });
                            if (_frame.contentWindow[ID] === UNDEFINED) {
                                _html();
                            }
                        }, 50);
                    }
                    _st(function() {
                        _trigger('init');
                        _update(FALSE);
                    }, 1);
                    if (!_supportsState()) {
                        if ((_msie && _version > 7) || (!_msie && _hashchange)) {
                            if (_t.addEventListener) {
                                _t.addEventListener(HASH_CHANGE, _listen, FALSE);
                            } else if (_t.attachEvent) {
                                _t.attachEvent('on' + HASH_CHANGE, _listen);
                            }
                        } else {
                            _si(_listen, 50);
                        }
                    }
                    if ('state' in window.history) {
                        $(window).trigger('popstate');
                    }
                    $(document).trigger("onAddressActivated");
                    $(document).unbind("onAddressActivated");
                    _loaded = TRUE;
                }
            },
            _enable = function() {
                var el, 
                    elements = $('a'), 
                    length = elements.size(),
                    delay = 1,
                    index = -1,
                    sel = '[rel*="address:"]',
                    fn = function() {
                        if (++index != length) {
                            el = $(elements.get(index));
                            if (el.is(sel)) {
                                el.address(sel);
                            }
                            _st(fn, delay);
                        }
                    };
                _st(fn, delay);
            },
            _popstate = function() {
                if (decodeURI(_value) != decodeURI(_href())) {
                    _old = _value;
                    _value = _href();
                    _update(FALSE);
                }
            },
            _unload = function() {
                if (_t.removeEventListener) {
                    _t.removeEventListener(HASH_CHANGE, _listen, FALSE);
                } else if (_t.detachEvent) {
                    _t.detachEvent('on' + HASH_CHANGE, _listen);
                }
            },
            _unescape = function() {
                if (_opts.crawlable) {
                    var base = _l.pathname.replace(/\/$/, ''),
                        fragment = '_escaped_fragment_';
                    if ($('body').html().indexOf(fragment) != -1) {
                        $('a[href]:not([href^=http]), a[href*="' + document.domain + '"]').each(function() {
                            var href = $(this).attr('href').replace(/^http:/, '').replace(new RegExp(base + '/?$'), '');
                            if (href === '' || href.indexOf(fragment) != -1) {
                                $(this).attr('href', '#' + encodeURI(decodeURIComponent(href.replace(new RegExp('/(.*)\\?' + 
                                    fragment + '=(.*)$'), '!$2'))));
                            }
                        });
                    }
                }
            },
            UNDEFINED,
            NULL = null,
            ID = 'jQueryAddress',
            STRING = 'string',
            HASH_CHANGE = 'hashchange',
            INIT = 'init',
            CHANGE = 'change',
            INTERNAL_CHANGE = 'internalChange',
            EXTERNAL_CHANGE = 'externalChange',
            TRUE = true,
            FALSE = false,
            _opts = {
                autoUpdate: TRUE, 
                crawlable: FALSE,
                history: TRUE, 
                strict: TRUE,
                wrap: FALSE
            },
            _browser = $.browser, 
            _version = parseFloat(_browser.version),
            _msie = !$.support.opacity,
            _webkit = _browser.webkit || _browser.safari,
            _t = _window(),
            _d = _t.document,
            _h = _t.history, 
            _l = _t.location,
            _si = setInterval,
            _st = setTimeout,
            _re = /\/{2,9}/g,
            _agent = navigator.userAgent,
            _hashchange = 'on' + HASH_CHANGE in _t,
            _frame,
            _form,
            _url = $('script:last').attr('src'),
            _qi = _url ? _url.indexOf('?') : -1,
            _title = _d.title, 
            _silent = FALSE,
            _loaded = FALSE,
            _juststart = TRUE,
            _updating = FALSE,
            _listeners = {}, 
            _value = _href();
            _old = _value;
            
        if (_msie) {
            _version = parseFloat(_agent.substr(_agent.indexOf('MSIE') + 4));
            if (_d.documentMode && _d.documentMode != _version) {
                _version = _d.documentMode != 8 ? 7 : 8;
            }
            var logAnError = function(e) {
                if (typeof window.console != "undefined" && typeof window.console.log === "function") {
                    window.console.log("Error in Address plugin: " + e.message);
                }
            }
            try {
                var pc = _d.onpropertychange;
                _d.onpropertychange = function() {
                    try {
                        if (pc) {
                            pc.call(_d);
                        }
                        if (_d.title != _title && _d.title.indexOf('#' + _href()) != -1) {
                            _d.title = _title;
                        }
                    } catch(e) {
                        logAnError(e);
                    }
                };
            } catch(e) {
                logAnError(e);
            }
        }
        
        if (_h.navigationMode) {
            _h.navigationMode = 'compatible';
        }
        $(window).bind('popstate', _popstate).bind('unload', _unload);

        return {
            activate:function() {
                if (document.readyState == 'complete') {
                    var interval = setInterval(function() {
                        if ($.address) {
                            _load();
                            clearInterval(interval);
                        }
                    }, 50);
                } else {
                    _options();
                    $(_load);
                }
            },
            bind: function(type, data, fn) {
                return _bind.apply(this, _array(arguments));
            },
            unbind: function(type, fn) {
                return _unbind.apply(this, _array(arguments));
            },
            init: function(data, fn) {
                return _bind.apply(this, [INIT].concat(_array(arguments)));
            },
            change: function(data, fn) {
                return _bind.apply(this, [CHANGE].concat(_array(arguments)));
            },
            internalChange: function(data, fn) {
                return _bind.apply(this, [INTERNAL_CHANGE].concat(_array(arguments)));
            },
            externalChange: function(data, fn) {
                return _bind.apply(this, [EXTERNAL_CHANGE].concat(_array(arguments)));
            },
            baseURL: function() {
                var url = _l.href;
                if (url.indexOf('#') != -1) {
                    url = url.substr(0, url.indexOf('#'));
                }
                if (/\/$/.test(url)) {
                    url = url.substr(0, url.length - 1);
                }
                return url;
            },
            autoUpdate: function(value) {
                if (value !== UNDEFINED) {
                    _opts.autoUpdate = value;
                    return this;
                }
                return _opts.autoUpdate;
            },
            crawlable: function(value) {
                if (value !== UNDEFINED) {
                    _opts.crawlable = value;
                    return this;
                }
                return _opts.crawlable;
            },
            history: function(value) {
                if (value !== UNDEFINED) {
                    _opts.history = value;
                    return this;
                }
                return _opts.history;
            },
            state: function(value) {
                if (value !== UNDEFINED) {
                    _opts.state = value;
                    var hrefState = _hrefState();
                    if (_opts.state !== UNDEFINED) {
                        if (_h.pushState) {
                            if (hrefState.substr(0, 3) == '/#/') {
                                _l.replace(_opts.state.replace(/^\/$/, '') + hrefState.substr(2));
                            }
                        } else if (hrefState != '/' && hrefState.replace(/^\/#/, '') != _hrefHash()) {
                            _st(function() {
                                _l.replace(_opts.state.replace(/^\/$/, '') + '/#' + hrefState);
                            }, 1);
                        }
                    }
                    return this;
                }
                return _opts.state;
            },
            strict: function(value) {
                if (value !== UNDEFINED) {
                    _opts.strict = value;
                    return this;
                }
                return _opts.strict;
            },
            tracker: function(value) {
                if (value !== UNDEFINED) {
                    _opts.tracker = value;
                    return this;
                }
                return _opts.tracker;
            },
            wrap: function(value) {
                if (value !== UNDEFINED) {
                    _opts.wrap = value;
                    return this;
                }
                return _opts.wrap;
            },
            update: function() {
                _updating = TRUE;
                this.value(_value);
                _updating = FALSE;
                return this;
            },
            title: function(value) {
                if (value !== UNDEFINED) {
                    _st(function() {
                        _title = _d.title = value;
                        if (_juststart && _frame && _frame.contentWindow && _frame.contentWindow.document) {
                            _frame.contentWindow.document.title = value;
                            _juststart = FALSE;
                        }
                    }, 50);
                    return this;
                }
                return _d.title;
            },
            value: function(value) {
                if (value !== UNDEFINED) {
                    value = _strict(value);
                    if (value == '/') {
                        value = '';
                    }
                    if (_value == value && !_updating) {
                        return;
                    }
                    _old = _value;
                    _value = value;
                    if (_opts.autoUpdate || _updating) {
                        _update(TRUE);
                        if (_supportsState()) {
                            _h[_opts.history ? 'pushState' : 'replaceState']({}, '', 
                                    _opts.state.replace(/\/$/, '') + (_value === '' ? '/' : _value));
                        } else {
                            _silent = TRUE;
                            if (_webkit) {
                                if (_opts.history) {
                                    _l.hash = '#' + _crawl(_value, TRUE);
                                } else {
                                    _l.replace('#' + _crawl(_value, TRUE));
                                }
                            } else if (_value != _href()) {
                                if (_opts.history) {
                                    _l.hash = '#' + _crawl(_value, TRUE);
                                } else {
                                    _l.replace('#' + _crawl(_value, TRUE));
                                }
                            }
                            if ((_msie && !_hashchange) && _opts.history) {
                                _st(_html, 50);
                            }
                            if (_webkit) {
                                _st(function(){ _silent = FALSE; }, 1);
                            } else {
                                _silent = FALSE;
                            }
                        }
                    }
                    return this;
                }
                return _strict(_value);
            },
            path: function(value) {
                if (value !== UNDEFINED) {
                    var qs = this.queryString(),
                        hash = this.hash();
                    this.value(value + (qs ? '?' + qs : '') + (hash ? '#' + hash : ''));
                    return this;
                }
                return _strict(_value).split('#')[0].split('?')[0];
            },
            pathNames: function() {
                var path = this.path(),
                    names = path.replace(_re, '/').split('/');
                if (path.substr(0, 1) == '/' || path.length === 0) {
                    names.splice(0, 1);
                }
                if (path.substr(path.length - 1, 1) == '/') {
                    names.splice(names.length - 1, 1);
                }
                return names;
            },
            queryString: function(value) {
                if (value !== UNDEFINED) {
                    var hash = this.hash();
                    this.value(this.path() + (value ? '?' + value : '') + (hash ? '#' + hash : ''));
                    return this;
                }
                var arr = _value.split('?');
                return arr.slice(1, arr.length).join('?').split('#')[0];
            },
            parameter: function(name, value, append) {
                var i, params;
                if (value !== UNDEFINED) {
                    var names = this.parameterNames();
                    params = [];
                    value = value === UNDEFINED || value === NULL ? '' : value.toString();
                    for (i = 0; i < names.length; i++) {
                        var n = names[i],
                            v = this.parameter(n);
                        if (typeof v == STRING) {
                            v = [v];
                        }
                        if (n == name) {
                            v = (value === NULL || value === '') ? [] : 
                                (append ? v.concat([value]) : [value]);
                        }
                        for (var j = 0; j < v.length; j++) {
                            params.push(n + '=' + v[j]);
                        }
                    }
                    if ($.inArray(name, names) == -1 && value !== NULL && value !== '') {
                        params.push(name + '=' + value);
                    }
                    this.queryString(params.join('&'));
                    return this;
                }
                value = this.queryString();
                if (value) {
                    var r = [];
                    params = value.split('&');
                    for (i = 0; i < params.length; i++) {
                        var p = params[i].split('=');
                        if (p[0] == name) {
                            r.push(p.slice(1).join('='));
                        }
                    }
                    if (r.length !== 0) {
                        return r.length != 1 ? r : r[0];
                    }
                }
            },
            parameterNames: function() {
                var qs = this.queryString(),
                    names = [];
                if (qs && qs.indexOf('=') != -1) {
                    var params = qs.split('&');
                    for (var i = 0; i < params.length; i++) {
                        var name = params[i].split('=')[0];
                        if ($.inArray(name, names) == -1) {
                            names.push(name);
                        }
                    }
                }
                return names;
            },
            hash: function(value) {
                if (value !== UNDEFINED) {
                    this.value(_value.split('#')[0] + (value ? '#' + value : ''));
                    return this;
                }
                var arr = _value.split('#');
                return arr.slice(1, arr.length).join('#');                
            },
            ready: function() {
                return _loaded;
            }
        };
    })();
    
    $.fn.address = function(fn) {
        var sel;
        if (typeof fn == 'string') {
            sel = fn;
            fn = undefined;
        }
        if (!$(this).attr('address')) {
            var f = function(e) {
                if (e.shiftKey || e.ctrlKey || e.metaKey || e.which == 2) {
                    return true;
                }
                if ($(this).is('a')) {
                    e.preventDefault();
                    var value = fn ? fn.call(this) : 
                        /address:/.test($(this).attr('rel')) ? $(this).attr('rel').split('address:')[1].split(' ')[0] : 
                        $.address.state() !== undefined && !/^\/?$/.test($.address.state()) ? 
                                $(this).attr('href').replace(new RegExp('^(.*' + $.address.state() + '|\\.)'), '') : 
                                $(this).attr('href').replace(/^(#\!?|\.)/, '');
                    $.address.value(value);
                }
            };
            $(sel ? sel : this).live('click', f).live('submit', function(e) {
                if ($(this).is('form')) {
                    e.preventDefault();
                    var action = $(this).attr('action'),
                        value = fn ? fn.call(this) : (action.indexOf('?') != -1 ? action.replace(/&$/, '') : action + '?') + 
                            $(this).serialize();
                    $.address.value(value);
                }
            }).attr('address', true);
        }
        return this;
    };
})(jQuery);;
/**
 * jQuery backgroundPosition
 * @author Alexander Farkas
 * v. 1.1
 */

(function($){
	if(!document.defaultView || !document.defaultView.getComputedStyle){
		var oldCurCSS = jQuery.curCSS;
		jQuery.curCSS = function(elem, name, force){
			if(name !== 'backgroundPosition' || !elem.currentStyle || elem.currentStyle[ name ]){
				return oldCurCSS.apply(this, arguments);
			}
			var style = elem.style;
			if ( !force && style && style[ name ] ){
				return style[ name ];
			}
			return oldCurCSS(elem, 'backgroundPositionX', force) +' '+ oldCurCSS(elem, 'backgroundPositionY', force);
		};
	}
})(jQuery);

(function($) {
	
	function toArray(strg){
		strg = strg.replace(/left|top/g,'0px');
		strg = strg.replace(/right|bottom/g,'100%');
		strg = strg.replace(/([0-9\.]+)(\s|\)|$)/g,"$1px$2");
		var res = strg.match(/(-?[0-9\.]+)(px|\%|em|pt)\s(-?[0-9\.]+)(px|\%|em|pt)/);
		return [parseFloat(res[1],10),res[2],parseFloat(res[3],10),res[4]];
	}
	
	$.fx.step. backgroundPosition = function(fx) {
		if (!fx.bgPosReady) {
			
			var start = $.curCSS(fx.elem,'backgroundPosition');
			if(!start){//FF2 no inline-style fallback
				start = '0px 0px';
			}
			
			start = toArray(start);
			fx.start = [start[0],start[2]];
			
			var end = toArray(fx.options.curAnim.backgroundPosition);
			fx.end = [end[0],end[2]];
			
			fx.unit = [end[1],end[3]];
			fx.bgPosReady = true;
		}
		
		var nowPosX = [];
		nowPosX[0] = ((fx.end[0] - fx.start[0]) * fx.pos) + fx.start[0] + fx.unit[0];
		nowPosX[1] = ((fx.end[1] - fx.start[1]) * fx.pos) + fx.start[1] + fx.unit[1];           
		fx.elem.style.backgroundPosition = nowPosX[0]+' '+nowPosX[1];

	};
})(jQuery);;
/*
 * 
 * TableSorter 2.0 - Client-side table sorting with ease!
 * Version 2.0.5b
 * @requires jQuery v1.2.3
 * 
 * Copyright (c) 2007 Christian Bach
 * Examples and docs at: http://tablesorter.com
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 * 
 */
/**
 * 
 * @description Create a sortable table with multi-column sorting capabilitys
 * 
 * @example $('table').tablesorter();
 * @desc Create a simple tablesorter interface.
 * 
 * @example $('table').tablesorter({ sortList:[[0,0],[1,0]] });
 * @desc Create a tablesorter interface and sort on the first and secound column column headers.
 * 
 * @example $('table').tablesorter({ headers: { 0: { sorter: false}, 1: {sorter: false} } });
 *          
 * @desc Create a tablesorter interface and disableing the first and second  column headers.
 *      
 * 
 * @example $('table').tablesorter({ headers: { 0: {sorter:"integer"}, 1: {sorter:"currency"} } });
 * 
 * @desc Create a tablesorter interface and set a column parser for the first
 *       and second column.
 * 
 * 
 * @param Object
 *            settings An object literal containing key/value pairs to provide
 *            optional settings.
 * 
 * 
 * @option String cssHeader (optional) A string of the class name to be appended
 *         to sortable tr elements in the thead of the table. Default value:
 *         "th_header"
 * 
 * @option String cssAsc (optional) A string of the class name to be appended to
 *         sortable tr elements in the thead on a ascending sort. Default value:
 *         "headerSortUp"
 * 
 * @option String cssDesc (optional) A string of the class name to be appended
 *         to sortable tr elements in the thead on a descending sort. Default
 *         value: "headerSortDown"
 * 
 * @option String sortInitialOrder (optional) A string of the inital sorting
 *         order can be asc or desc. Default value: "asc"
 * 
 * @option String sortMultisortKey (optional) A string of the multi-column sort
 *         key. Default value: "shiftKey"
 * 
 * @option String textExtraction (optional) A string of the text-extraction
 *         method to use. For complex html structures inside td cell set this
 *         option to "complex", on large tables the complex option can be slow.
 *         Default value: "simple"
 * 
 * @option Object headers (optional) An array containing the forces sorting
 *         rules. This option let's you specify a default sorting rule. Default
 *         value: null
 * 
 * @option Array sortList (optional) An array containing the forces sorting
 *         rules. This option let's you specify a default sorting rule. Default
 *         value: null
 * 
 * @option Array sortForce (optional) An array containing forced sorting rules.
 *         This option let's you specify a default sorting rule, which is
 *         prepended to user-selected rules. Default value: null
 * 
 * @option Boolean sortLocaleCompare (optional) Boolean flag indicating whatever
 *         to use String.localeCampare method or not. Default set to true.
 * 
 * 
 * @option Array sortAppend (optional) An array containing forced sorting rules.
 *         This option let's you specify a default sorting rule, which is
 *         appended to user-selected rules. Default value: null
 * 
 * @option Boolean widthFixed (optional) Boolean flag indicating if tablesorter
 *         should apply fixed widths to the table columns. This is usefull when
 *         using the pager companion plugin. This options requires the dimension
 *         jquery plugin. Default value: false
 * 
 * @option Boolean cancelSelection (optional) Boolean flag indicating if
 *         tablesorter should cancel selection of the table headers text.
 *         Default value: true
 * 
 * @option Boolean debug (optional) Boolean flag indicating if tablesorter
 *         should display debuging information usefull for development.
 * 
 * @type jQuery
 * 
 * @name tablesorter
 * 
 * @cat Plugins/Tablesorter
 * 
 * @author Christian Bach/christian.bach@polyester.se
 */

(function ($) {
    $.extend({
        tablesorter: new
        function () {

            var parsers = [],
                widgets = [];

            this.defaults = {
                cssHeader: "th_header",
                cssAsc: "headerSortUp",
                cssDesc: "headerSortDown",
                cssChildRow: "expand-child",
                sortInitialOrder: "asc",
                sortMultiSortKey: "shiftKey",
                sortForce: null,
                sortAppend: null,
                sortLocaleCompare: true,
                textExtraction: "simple",
                parsers: {}, widgets: [],
                widgetZebra: {
                    css: ["even", "odd"]
                }, headers: {}, widthFixed: false,
                cancelSelection: true,
                sortList: [],
                headerList: [],
                dateFormat: "us",
                decimal: '/\.|\,/g',
                onRenderHeader: null,
                selectorHeaders: 'thead th',
                debug: false
            };

            /* debuging utils */

            function benchmark(s, d) {
                log(s + "," + (new Date().getTime() - d.getTime()) + "ms");
            }

            this.benchmark = benchmark;

            function log(s) {
                if (typeof console != "undefined" && typeof console.debug != "undefined") {
                    console.log(s);
                } else {
                    alert(s);
                }
            }

            /* parsers utils */

            function buildParserCache(table, $headers) {

                if (table.config.debug) {
                    var parsersDebug = "";
                }

                if (table.tBodies.length == 0) return; // In the case of empty tables
                var rows = table.tBodies[0].rows;

                if (rows[0]) {

                    var list = [],
                        cells = rows[0].cells,
                        l = cells.length;

                    for (var i = 0; i < l; i++) {

                        var p = false;

                        if ($.metadata && ($($headers[i]).metadata() && $($headers[i]).metadata().sorter)) {

                            p = getParserById($($headers[i]).metadata().sorter);

                        } else if ((table.config.headers[i] && table.config.headers[i].sorter)) {

                            p = getParserById(table.config.headers[i].sorter);
                        }
                        if (!p) {

                            p = detectParserForColumn(table, rows, -1, i);
                        }

                        if (table.config.debug) {
                            parsersDebug += "column:" + i + " parser:" + p.id + "\n";
                        }

                        list.push(p);
                    }
                }

                if (table.config.debug) {
                    log(parsersDebug);
                }

                return list;
            };

            function detectParserForColumn(table, rows, rowIndex, cellIndex) {
                var l = parsers.length,
                    node = false,
                    nodeValue = false,
                    keepLooking = true;
                while (nodeValue == '' && keepLooking) {
                    rowIndex++;
                    if (rows[rowIndex]) {
                        node = getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex);
                        nodeValue = trimAndGetNodeText(table.config, node);
                        if (table.config.debug) {
                            log('Checking if value was empty on row:' + rowIndex);
                        }
                    } else {
                        keepLooking = false;
                    }
                }
                for (var i = 1; i < l; i++) {
                    if (parsers[i].is(nodeValue, table, node)) {
                        return parsers[i];
                    }
                }
                // 0 is always the generic parser (text)
                return parsers[0];
            }

            function getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex) {
                return rows[rowIndex].cells[cellIndex];
            }

            function trimAndGetNodeText(config, node) {
                return $.trim(getElementText(config, node));
            }

            function getParserById(name) {
                var l = parsers.length;
                for (var i = 0; i < l; i++) {
                    if (parsers[i].id.toLowerCase() == name.toLowerCase()) {
                        return parsers[i];
                    }
                }
                return false;
            }

            /* utils */

            function buildCache(table) {

                if (table.config.debug) {
                    var cacheTime = new Date();
                }

                var totalRows = (table.tBodies[0] && table.tBodies[0].rows.length) || 0,
                    totalCells = (table.tBodies[0].rows[0] && table.tBodies[0].rows[0].cells.length) || 0,
                    parsers = table.config.parsers,
                    cache = {
                        row: [],
                        normalized: []
                    };

                for (var i = 0; i < totalRows; ++i) {

                    /** Add the table data to main data array */
                    var c = $(table.tBodies[0].rows[i]),
                        cols = [];

                    // if this is a child row, add it to the last row's children and
                    // continue to the next row
                    if (c.hasClass(table.config.cssChildRow)) {
                        cache.row[cache.row.length - 1] = cache.row[cache.row.length - 1].add(c);
                        // go to the next for loop
                        continue;
                    }

                    cache.row.push(c);

                    for (var j = 0; j < totalCells; ++j) {
                        cols.push(parsers[j].format(getElementText(table.config, c[0].cells[j]), table, c[0].cells[j]));
                    }

                    cols.push(cache.normalized.length); // add position for rowCache
                    cache.normalized.push(cols);
                    cols = null;
                };

                if (table.config.debug) {
                    benchmark("Building cache for " + totalRows + " rows:", cacheTime);
                }

                return cache;
            };

            function getElementText(config, node) {

                var text = "";

                if (!node) return "";

                if (!config.supportsTextContent) config.supportsTextContent = node.textContent || false;

                if (config.textExtraction == "simple") {
                    if (config.supportsTextContent) {
                        text = node.textContent;
                    } else {
                        if (node.childNodes[0] && node.childNodes[0].hasChildNodes()) {
                            text = node.childNodes[0].innerHTML;
                        } else {
                            text = node.innerHTML;
                        }
                    }
                } else {
                    if (typeof(config.textExtraction) == "function") {
                        text = config.textExtraction(node);
                    } else {
                        text = $(node).text();
                    }
                }
                return text;
            }

            function appendToTable(table, cache) {

                if (table.config.debug) {
                    var appendTime = new Date()
                }

                var c = cache,
                    r = c.row,
                    n = c.normalized,
                    totalRows = n.length,
                    checkCell = (n[0].length - 1),
                    tableBody = $(table.tBodies[0]),
                    rows = [];


                for (var i = 0; i < totalRows; i++) {
                    var pos = n[i][checkCell];

                    rows.push(r[pos]);

                    if (!table.config.appender) {

                        //var o = ;
                        var l = r[pos].length;
                        for (var j = 0; j < l; j++) {
                            tableBody[0].appendChild(r[pos][j]);
                        }

                        // 
                    }
                }



                if (table.config.appender) {

                    table.config.appender(table, rows);
                }

                rows = null;

                if (table.config.debug) {
                    benchmark("Rebuilt table:", appendTime);
                }

                // apply table widgets
                applyWidget(table);

                // trigger sortend
                setTimeout(function () {
                    $(table).trigger("sortEnd");
                }, 0);

            };

            function buildHeaders(table) {

                if (table.config.debug) {
                    var time = new Date();
                }

                var meta = ($.metadata) ? true : false;
                
                var header_index = computeTableHeaderCellIndexes(table);

                $tableHeaders = $(table.config.selectorHeaders, table).each(function (index) {

                    this.column = header_index[this.parentNode.rowIndex + "-" + this.cellIndex];
                    // this.column = index;
                    this.order = formatSortingOrder(table.config.sortInitialOrder);
                    
					
					this.count = this.order;

                    if (checkHeaderMetadata(this) || checkHeaderOptions(table, index)) this.sortDisabled = true;
					if (checkHeaderOptionsSortingLocked(table, index)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(table, index);

                    if (!this.sortDisabled) {
                        var $th = $(this).addClass(table.config.cssHeader);
                        if (table.config.onRenderHeader) table.config.onRenderHeader.apply($th);
                    }

                    // add cell to headerList
                    table.config.headerList[index] = this;
                });

                if (table.config.debug) {
                    benchmark("Built headers:", time);
                    log($tableHeaders);
                }

                return $tableHeaders;

            };

            // from:
            // http://www.javascripttoolbox.com/lib/table/examples.php
            // http://www.javascripttoolbox.com/temp/table_cellindex.html


            function computeTableHeaderCellIndexes(t) {
                var matrix = [];
                var lookup = {};
                var thead = t.getElementsByTagName('THEAD')[0];
                var trs = thead.getElementsByTagName('TR');

                for (var i = 0; i < trs.length; i++) {
                    var cells = trs[i].cells;
                    for (var j = 0; j < cells.length; j++) {
                        var c = cells[j];

                        var rowIndex = c.parentNode.rowIndex;
                        var cellId = rowIndex + "-" + c.cellIndex;
                        var rowSpan = c.rowSpan || 1;
                        var colSpan = c.colSpan || 1
                        var firstAvailCol;
                        if (typeof(matrix[rowIndex]) == "undefined") {
                            matrix[rowIndex] = [];
                        }
                        // Find first available column in the first row
                        for (var k = 0; k < matrix[rowIndex].length + 1; k++) {
                            if (typeof(matrix[rowIndex][k]) == "undefined") {
                                firstAvailCol = k;
                                break;
                            }
                        }
                        lookup[cellId] = firstAvailCol;
                        for (var k = rowIndex; k < rowIndex + rowSpan; k++) {
                            if (typeof(matrix[k]) == "undefined") {
                                matrix[k] = [];
                            }
                            var matrixrow = matrix[k];
                            for (var l = firstAvailCol; l < firstAvailCol + colSpan; l++) {
                                matrixrow[l] = "x";
                            }
                        }
                    }
                }
                return lookup;
            }

            function checkCellColSpan(table, rows, row) {
                var arr = [],
                    r = table.tHead.rows,
                    c = r[row].cells;

                for (var i = 0; i < c.length; i++) {
                    var cell = c[i];

                    if (cell.colSpan > 1) {
                        arr = arr.concat(checkCellColSpan(table, headerArr, row++));
                    } else {
                        if (table.tHead.length == 1 || (cell.rowSpan > 1 || !r[row + 1])) {
                            arr.push(cell);
                        }
                        // headerArr[row] = (i+row);
                    }
                }
                return arr;
            };

            function checkHeaderMetadata(cell) {
                if (($.metadata) && ($(cell).metadata().sorter === false)) {
                    return true;
                };
                return false;
            }

            function checkHeaderOptions(table, i) {
                if ((table.config.headers[i]) && (table.config.headers[i].sorter === false)) {
                    return true;
                };
                return false;
            }
			
			 function checkHeaderOptionsSortingLocked(table, i) {
                if ((table.config.headers[i]) && (table.config.headers[i].lockedOrder)) return table.config.headers[i].lockedOrder;
                return false;
            }
			
            function applyWidget(table) {
                var c = table.config.widgets;
                var l = c.length;
                for (var i = 0; i < l; i++) {

                    getWidgetById(c[i]).format(table);
                }

            }

            function getWidgetById(name) {
                var l = widgets.length;
                for (var i = 0; i < l; i++) {
                    if (widgets[i].id.toLowerCase() == name.toLowerCase()) {
                        return widgets[i];
                    }
                }
            };

            function formatSortingOrder(v) {
                if (typeof(v) != "Number") {
                    return (v.toLowerCase() == "desc") ? 1 : 0;
                } else {
                    return (v == 1) ? 1 : 0;
                }
            }

            function isValueInArray(v, a) {
                var l = a.length;
                for (var i = 0; i < l; i++) {
                    if (a[i][0] == v) {
                        return true;
                    }
                }
                return false;
            }

            function setHeadersCss(table, $headers, list, css) {
                // remove all header information
                $headers.removeClass(css[0]).removeClass(css[1]);

                var h = [];
                $headers.each(function (offset) {
                    if (!this.sortDisabled) {
                        h[this.column] = $(this);
                    }
                });

                var l = list.length;
                for (var i = 0; i < l; i++) {
                    h[list[i][0]].addClass(css[list[i][1]]);
                }
            }

            function fixColumnWidth(table, $headers) {
                var c = table.config;
                if (c.widthFixed) {
                    var colgroup = $('<colgroup>');
                    $("tr:first td", table.tBodies[0]).each(function () {
                        colgroup.append($('<col>').css('width', $(this).width()));
                    });
                    $(table).prepend(colgroup);
                };
            }

            function updateHeaderSortCount(table, sortList) {
                var c = table.config,
                    l = sortList.length;
                for (var i = 0; i < l; i++) {
                    var s = sortList[i],
                        o = c.headerList[s[0]];
                    o.count = s[1];
                    o.count++;
                }
            }

            /* sorting methods */

            function multisort(table, sortList, cache) {

                if (table.config.debug) {
                    var sortTime = new Date();
                }

                var dynamicExp = "var sortWrapper = function(a,b) {",
                    l = sortList.length;

                // TODO: inline functions.
                for (var i = 0; i < l; i++) {

                    var c = sortList[i][0];
                    var order = sortList[i][1];
                    // var s = (getCachedSortType(table.config.parsers,c) == "text") ?
                    // ((order == 0) ? "sortText" : "sortTextDesc") : ((order == 0) ?
                    // "sortNumeric" : "sortNumericDesc");
                    // var s = (table.config.parsers[c].type == "text") ? ((order == 0)
                    // ? makeSortText(c) : makeSortTextDesc(c)) : ((order == 0) ?
                    // makeSortNumeric(c) : makeSortNumericDesc(c));
                    var s = (table.config.parsers[c].type == "text") ? ((order == 0) ? makeSortFunction("text", "asc", c) : makeSortFunction("text", "desc", c)) : ((order == 0) ? makeSortFunction("numeric", "asc", c) : makeSortFunction("numeric", "desc", c));
                    var e = "e" + i;

                    dynamicExp += "var " + e + " = " + s; // + "(a[" + c + "],b[" + c
                    // + "]); ";
                    dynamicExp += "if(" + e + ") { return " + e + "; } ";
                    dynamicExp += "else { ";

                }

                // if value is the same keep orignal order
                var orgOrderCol = cache.normalized[0].length - 1;
                dynamicExp += "return a[" + orgOrderCol + "]-b[" + orgOrderCol + "];";

                for (var i = 0; i < l; i++) {
                    dynamicExp += "}; ";
                }

                dynamicExp += "return 0; ";
                dynamicExp += "}; ";

                if (table.config.debug) {
                    benchmark("Evaling expression:" + dynamicExp, new Date());
                }

                eval(dynamicExp);

                cache.normalized.sort(sortWrapper);

                if (table.config.debug) {
                    benchmark("Sorting on " + sortList.toString() + " and dir " + order + " time:", sortTime);
                }

                return cache;
            };

            function makeSortFunction(type, direction, index) {
                var a = "a[" + index + "]",
                    b = "b[" + index + "]";
                if (type == 'text' && direction == 'asc') {
                    return "(" + a + " == " + b + " ? 0 : (" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : (" + a + " < " + b + ") ? -1 : 1 )));";
                } else if (type == 'text' && direction == 'desc') {
                    return "(" + a + " == " + b + " ? 0 : (" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : (" + b + " < " + a + ") ? -1 : 1 )));";
                } else if (type == 'numeric' && direction == 'asc') {
                    return "(" + a + " === null && " + b + " === null) ? 0 :(" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : " + a + " - " + b + "));";
                } else if (type == 'numeric' && direction == 'desc') {
                    return "(" + a + " === null && " + b + " === null) ? 0 :(" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : " + b + " - " + a + "));";
                }
            };

            function makeSortText(i) {
                return "((a[" + i + "] < b[" + i + "]) ? -1 : ((a[" + i + "] > b[" + i + "]) ? 1 : 0));";
            };

            function makeSortTextDesc(i) {
                return "((b[" + i + "] < a[" + i + "]) ? -1 : ((b[" + i + "] > a[" + i + "]) ? 1 : 0));";
            };

            function makeSortNumeric(i) {
                return "a[" + i + "]-b[" + i + "];";
            };

            function makeSortNumericDesc(i) {
                return "b[" + i + "]-a[" + i + "];";
            };

            function sortText(a, b) {
                if (table.config.sortLocaleCompare) return a.localeCompare(b);
                return ((a < b) ? -1 : ((a > b) ? 1 : 0));
            };

            function sortTextDesc(a, b) {
                if (table.config.sortLocaleCompare) return b.localeCompare(a);
                return ((b < a) ? -1 : ((b > a) ? 1 : 0));
            };

            function sortNumeric(a, b) {
                return a - b;
            };

            function sortNumericDesc(a, b) {
                return b - a;
            };

            function getCachedSortType(parsers, i) {
                return parsers[i].type;
            }; /* public methods */
            this.construct = function (settings) {
                return this.each(function () {
                    // if no thead or tbody quit.
                    if (!this.tHead || !this.tBodies) return;
                    // declare
                    var $this, $document, $headers, cache, config, shiftDown = 0,
                        sortOrder;
                    // new blank config object
                    this.config = {};
                    // merge and extend.
                    config = $.extend(this.config, $.tablesorter.defaults, settings);
                    // store common expression for speed
                    $this = $(this);
                    // save the settings where they read
                    $.data(this, "tablesorter", config);
                    // build headers
                    $headers = buildHeaders(this);
                    // try to auto detect column type, and store in tables config
                    this.config.parsers = buildParserCache(this, $headers);
                    // build the cache for the tbody cells
                    cache = buildCache(this);
                    // get the css class names, could be done else where.
                    var sortCSS = [config.cssDesc, config.cssAsc];
                    // fixate columns if the users supplies the fixedWidth option
                    fixColumnWidth(this);
                    // apply event handling to headers
                    // this is to big, perhaps break it out?
                    $headers.click(

                    function (e) {
                        var totalRows = ($this[0].tBodies[0] && $this[0].tBodies[0].rows.length) || 0;
                        if (!this.sortDisabled && totalRows > 0) {
                            // Only call sortStart if sorting is
                            // enabled.
                            $this.trigger("sortStart");
                            // store exp, for speed
                            var $cell = $(this);
                            // get current column index
                            var i = this.column;
                            // get current column sort order
                            this.order = this.count++ % 2;
							// always sort on the locked order.
							if(this.lockedOrder) this.order = this.lockedOrder;
							
							// user only whants to sort on one
                            // column
                            if (!e[config.sortMultiSortKey]) {
                                // flush the sort list
                                config.sortList = [];
                                if (config.sortForce != null) {
                                    var a = config.sortForce;
                                    for (var j = 0; j < a.length; j++) {
                                        if (a[j][0] != i) {
                                            config.sortList.push(a[j]);
                                        }
                                    }
                                }
                                // add column to sort list
                                config.sortList.push([i, this.order]);
                                // multi column sorting
                            } else {
                                // the user has clicked on an all
                                // ready sortet column.
                                if (isValueInArray(i, config.sortList)) {
                                    // revers the sorting direction
                                    // for all tables.
                                    for (var j = 0; j < config.sortList.length; j++) {
                                        var s = config.sortList[j],
                                            o = config.headerList[s[0]];
                                        if (s[0] == i) {
                                            o.count = s[1];
                                            o.count++;
                                            s[1] = o.count % 2;
                                        }
                                    }
                                } else {
                                    // add column to sort list array
                                    config.sortList.push([i, this.order]);
                                }
                            };
                            setTimeout(function () {
                                // set css for headers
                                setHeadersCss($this[0], $headers, config.sortList, sortCSS);
                                appendToTable(
	                                $this[0], multisort(
	                                $this[0], config.sortList, cache)
								);
                            }, 1);
                            // stop normal event by returning false
                            return false;
                        }
                        // cancel selection
                    }).mousedown(function () {
                        if (config.cancelSelection) {
                            this.onselectstart = function () {
                                return false
                            };
                            return false;
                        }
                    });
                    // apply easy methods that trigger binded events
                    $this.bind("update", function () {
                        var me = this;
                        setTimeout(function () {
                            // rebuild parsers.
                            me.config.parsers = buildParserCache(
                            me, $headers);
                            // rebuild the cache map
                            cache = buildCache(me);
                        }, 1);
                    }).bind("updateCell", function (e, cell) {
                        var config = this.config;
                        // get position from the dom.
                        var pos = [(cell.parentNode.rowIndex - 1), cell.cellIndex];
                        // update cache
                        cache.normalized[pos[0]][pos[1]] = config.parsers[pos[1]].format(
                        getElementText(config, cell), cell);
                    }).bind("sorton", function (e, list) {
                        $(this).trigger("sortStart");
                        config.sortList = list;
                        // update and store the sortlist
                        var sortList = config.sortList;
                        // update header count index
                        updateHeaderSortCount(this, sortList);
                        // set css for headers
                        setHeadersCss(this, $headers, sortList, sortCSS);
                        // sort the table and append it to the dom
                        appendToTable(this, multisort(this, sortList, cache));
                    }).bind("appendCache", function () {
                        appendToTable(this, cache);
                    }).bind("applyWidgetId", function (e, id) {
                        getWidgetById(id).format(this);
                    }).bind("applyWidgets", function () {
                        // apply widgets
                        applyWidget(this);
                    });
                    if ($.metadata && ($(this).metadata() && $(this).metadata().sortlist)) {
                        config.sortList = $(this).metadata().sortlist;
                    }
                    // if user has supplied a sort list to constructor.
                    if (config.sortList.length > 0) {
                        $this.trigger("sorton", [config.sortList]);
                    }
                    // apply widgets
                    applyWidget(this);
                });
            };
            this.addParser = function (parser) {
                var l = parsers.length,
                    a = true;
                for (var i = 0; i < l; i++) {
                    if (parsers[i].id.toLowerCase() == parser.id.toLowerCase()) {
                        a = false;
                    }
                }
                if (a) {
                    parsers.push(parser);
                };
            };
            this.addWidget = function (widget) {
                widgets.push(widget);
            };
            this.formatFloat = function (s) {
                var i = parseFloat(s);
                return (isNaN(i)) ? 0 : i;
            };
            this.formatInt = function (s) {
                var i = parseInt(s);
                return (isNaN(i)) ? 0 : i;
            };
            this.isDigit = function (s, config) {
                // replace all an wanted chars and match.
                return /^[-+]?\d*$/.test($.trim(s.replace(/[,.']/g, '')));
            };
            this.clearTableBody = function (table) {
                if ($.browser.msie) {
                    function empty() {
                        while (this.firstChild)
                        this.removeChild(this.firstChild);
                    }
                    empty.apply(table.tBodies[0]);
                } else {
                    table.tBodies[0].innerHTML = "";
                }
            };
        }
    });

    // extend plugin scope
    $.fn.extend({
        tablesorter: $.tablesorter.construct
    });

    // make shortcut
    var ts = $.tablesorter;

    // add default parsers
    ts.addParser({
        id: "text",
        is: function (s) {
            return true;
        }, format: function (s) {
            return $.trim(s.toLocaleLowerCase());
        }, type: "text"
    });

    ts.addParser({
        id: "digit",
        is: function (s, table) {
            var c = table.config;
            return $.tablesorter.isDigit(s, c);
        }, format: function (s) {
            return $.tablesorter.formatFloat(s);
        }, type: "numeric"
    });

    ts.addParser({
        id: "currency",
        is: function (s) {
            return /^[£$€?.]/.test(s);
        }, format: function (s) {
            return $.tablesorter.formatFloat(s.replace(new RegExp(/[£$€]/g), ""));
        }, type: "numeric"
    });

    ts.addParser({
        id: "ipAddress",
        is: function (s) {
            return /^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(s);
        }, format: function (s) {
            var a = s.split("."),
                r = "",
                l = a.length;
            for (var i = 0; i < l; i++) {
                var item = a[i];
                if (item.length == 2) {
                    r += "0" + item;
                } else {
                    r += item;
                }
            }
            return $.tablesorter.formatFloat(r);
        }, type: "numeric"
    });

    ts.addParser({
        id: "url",
        is: function (s) {
            return /^(https?|ftp|file):\/\/$/.test(s);
        }, format: function (s) {
            return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\/\//), ''));
        }, type: "text"
    });

    ts.addParser({
        id: "isoDate",
        is: function (s) {
            return /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s);
        }, format: function (s) {
            return $.tablesorter.formatFloat((s != "") ? new Date(s.replace(
            new RegExp(/-/g), "/")).getTime() : "0");
        }, type: "numeric"
    });

    ts.addParser({
        id: "percent",
        is: function (s) {
            return /\%$/.test($.trim(s));
        }, format: function (s) {
            return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g), ""));
        }, type: "numeric"
    });

    ts.addParser({
        id: "usLongDate",
        is: function (s) {
            return s.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/));
        }, format: function (s) {
            return $.tablesorter.formatFloat(new Date(s).getTime());
        }, type: "numeric"
    });

    ts.addParser({
        id: "shortDate",
        is: function (s) {
            return /\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(s);
        }, format: function (s, table) {
            var c = table.config;
            s = s.replace(/\-/g, "/");
            if (c.dateFormat == "us") {
                // reformat the string in ISO format
                s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, "$3/$1/$2");
            } else if (c.dateFormat == "uk") {
                // reformat the string in ISO format
                s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, "$3/$2/$1");
            } else if (c.dateFormat == "dd/mm/yy" || c.dateFormat == "dd-mm-yy") {
                s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/, "$1/$2/$3");
            }
            return $.tablesorter.formatFloat(new Date(s).getTime());
        }, type: "numeric"
    });
    ts.addParser({
        id: "time",
        is: function (s) {
            return /^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(s);
        }, format: function (s) {
            return $.tablesorter.formatFloat(new Date("2000/01/01 " + s).getTime());
        }, type: "numeric"
    });
    ts.addParser({
        id: "metadata",
        is: function (s) {
            return false;
        }, format: function (s, table, cell) {
            var c = table.config,
                p = (!c.parserMetadataName) ? 'sortValue' : c.parserMetadataName;
            return $(cell).metadata()[p];
        }, type: "numeric"
    });
    // add default widgets
    ts.addWidget({
        id: "zebra",
        format: function (table) {
            if (table.config.debug) {
                var time = new Date();
            }
            var $tr, row = -1,
                odd;
            // loop through the visible rows
            $("tr:visible", table.tBodies[0]).each(function (i) {
                $tr = $(this);
                // style children rows the same way the parent
                // row was styled
                if (!$tr.hasClass(table.config.cssChildRow)) row++;
                odd = (row % 2 == 0);
                $tr.removeClass(
                table.config.widgetZebra.css[odd ? 0 : 1]).addClass(
                table.config.widgetZebra.css[odd ? 1 : 0])
            });
            if (table.config.debug) {
                $.tablesorter.benchmark("Applying Zebra widget", time);
            }
        }
    });
})(jQuery);;
/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */
(function(a){function d(b){var c=b||window.event,d=[].slice.call(arguments,1),e=0,f=!0,g=0,h=0;return b=a.event.fix(c),b.type="mousewheel",c.wheelDelta&&(e=c.wheelDelta/120),c.detail&&(e=-c.detail/3),h=e,c.axis!==undefined&&c.axis===c.HORIZONTAL_AXIS&&(h=0,g=-1*e),c.wheelDeltaY!==undefined&&(h=c.wheelDeltaY/120),c.wheelDeltaX!==undefined&&(g=-1*c.wheelDeltaX/120),d.unshift(b,e,g,h),(a.event.dispatch||a.event.handle).apply(this,d)}var b=["DOMMouseScroll","mousewheel"];if(a.event.fixHooks)for(var c=b.length;c;)a.event.fixHooks[b[--c]]=a.event.mouseHooks;a.event.special.mousewheel={setup:function(){if(this.addEventListener)for(var a=b.length;a;)this.addEventListener(b[--a],d,!1);else this.onmousewheel=d},teardown:function(){if(this.removeEventListener)for(var a=b.length;a;)this.removeEventListener(b[--a],d,!1);else this.onmousewheel=null}},a.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})})(jQuery)
;
/* Copyright (c) 2010 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version 2.1.2
 */
(function(a){a.fn.bgiframe=(a.browser.msie&&/msie 6\.0/i.test(navigator.userAgent)?function(d){d=a.extend({top:"auto",left:"auto",width:"auto",height:"auto",opacity:true,src:"javascript:false;"},d);var c='<iframe class="bgiframe"frameborder="0"tabindex="-1"src="'+d.src+'"style="display:block;position:absolute;z-index:-1;'+(d.opacity!==false?"filter:Alpha(Opacity='0');":"")+"top:"+(d.top=="auto"?"expression(((parseInt(this.parentNode.currentStyle.borderTopWidth)||0)*-1)+'px')":b(d.top))+";left:"+(d.left=="auto"?"expression(((parseInt(this.parentNode.currentStyle.borderLeftWidth)||0)*-1)+'px')":b(d.left))+";width:"+(d.width=="auto"?"expression(this.parentNode.offsetWidth+'px')":b(d.width))+";height:"+(d.height=="auto"?"expression(this.parentNode.offsetHeight+'px')":b(d.height))+';"/>';return this.each(function(){if(a(this).children("iframe.bgiframe").length===0){this.insertBefore(document.createElement(c),this.firstChild)}})}:function(){return this});a.fn.bgIframe=a.fn.bgiframe;function b(c){return c&&c.constructor===Number?c+"px":c}})(jQuery);
// Underscore.js 1.4.4
// ===================

// > http://underscorejs.org
// > (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
// > Underscore may be freely distributed under the MIT license.

// Baseline setup
// --------------
(function() {

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);;
/*
Copyright (c) 2005 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/*
    The global object JSON contains two methods.

    JSON.stringify(value) takes a JavaScript value and produces a JSON text.
    The value must not be cyclical.

    JSON.parse(text) takes a JSON text and produces a JavaScript value. It will
    throw a 'JSONError' exception if there is an error.
*/
var JSON = {
    copyright: '(c)2005 JSON.org',
    license: 'http://www.crockford.com/JSON/license.html',
/*
    Stringify a JavaScript value, producing a JSON text.
*/
    stringify: function (v) {
        var a = [];

/*
    Emit a string.
*/
        function e(s) {
            a[a.length] = s;
        }

/*
    Convert a value.
*/
        function g(x) {
            var c, i, l, v;

            switch (typeof x) {
            case 'object':
                if (x) {
                    if (x instanceof Array) {
                        e('[');
                        l = a.length;
                        for (i = 0; i < x.length; i += 1) {
                            v = x[i];
                            if (typeof v != 'undefined' &&
                                    typeof v != 'function') {
                                if (l < a.length) {
                                    e(',');
                                }
                                g(v);
                            }
                        }
                        e(']');
                        return;
                    } else if (typeof x.valueOf == 'function') {
                        e('{');
                        l = a.length;
                        for (i in x) {
                            v = x[i];
                            if (typeof v != 'undefined' &&
                                    typeof v != 'function' &&
                                    (!v || typeof v != 'object' ||
                                        typeof v.valueOf == 'function')) {
                                if (l < a.length) {
                                    e(',');
                                }
                                g(i);
                                e(':');
                                g(v);
                            }
                        }
                        return e('}');
                    }
                }
                e('null');
                return;
            case 'number':
                e(isFinite(x) ? +x : 'null');
                return;
            case 'string':
                l = x.length;
                e('"');
                for (i = 0; i < l; i += 1) {
                    c = x.charAt(i);
                    if (c >= ' ') {
                        if (c == '\\' || c == '"') {
                            e('\\');
                        }
                        e(c);
                    } else {
                        switch (c) {
                        case '\b':
                            e('\\b');
                            break;
                        case '\f':
                            e('\\f');
                            break;
                        case '\n':
                            e('\\n');
                            break;
                        case '\r':
                            e('\\r');
                            break;
                        case '\t':
                            e('\\t');
                            break;
                        default:
                            c = c.charCodeAt();
                            e('\\u00' + Math.floor(c / 16).toString(16) +
                                (c % 16).toString(16));
                        }
                    }
                }
                e('"');
                return;
            case 'boolean':
                e(String(x));
                return;
            default:
                e('null');
                return;
            }
        }
        g(v);
        return a.join('');
    },
/*
    Parse a JSON text, producing a JavaScript value.
*/
    parse: function (text) {
        return (/^(\s+|[,:{}\[\]]|"(\\["\\\/bfnrtu]|[^\x00-\x1f"\\]+)*"|-?\d+(\.\d*)?([eE][+-]?\d+)?|true|false|null)+$/.test(text)) &&
            eval('(' + text + ')');
    }
};
;

/*! Beacon Code Copyright 2014 Digital River Inc. */
;(function($) {

	if (!window.console) {
	    window.console = {
	        log : function() {},
	        error : function() {},
	        warn : function() {},
	        profile : function() {}
	    };
	}

	// array of unobtrusive field events
	var PLUGINS = [];
	
	/**
	 * Create a "dr" namespace inside jQuery to put custom functionality
	 * @constructor
	 */
	$.dr = window.jQuery.dr || {
		
		/******************************************************************************
		* VERSION is the version number of the framework when it was created
		*****************************************************************************/	
		VERSION: "1.9.29",
		
		/******************************************************************************
		* VERSION is the timestamp when the compressed file was created
		*****************************************************************************/	
		VERSION_CREATION_DATE: "1413426357593",
	
		/******************************************************************************
		* BUILD_ID is used to prevent the browser from caching the javascript
		* css, and images, when deploying a new version of the framework
		* 
		* This value is populated from the ant build script.
		* 
		* The default is /drui/
		*****************************************************************************/	
		BUILD_ID: "1.9.29",
		
		/******************************************************************************
		* FRAMEWORK_PATH is the path to where the DR framework is located 
		* on the server. The framework should be root relative, example:
		* /yourappname/dr_framework/build/
		*****************************************************************************/
		FRAMEWORK_PATH: window.basePath || "//ui1.img.digitalrivercontent.net/drui/1.9.29/",
	
		/******************************************************************************
		* IMAGE_PATH is the location of the DR Framework images
		* Usually they are found here: /dr_framework/build/images/
		*****************************************************************************/
		IMAGE_PATH: '//ui1.img.digitalrivercontent.net/drui/1.9.29/images/',

		/******************************************************************************
		* BLANK_PAGE_URL is used in the modal overlay code.
		* 
		* It's also used when using transparent iframes
		*****************************************************************************/
		BLANK_PAGE_URL: '//ui1.img.digitalrivercontent.net/drui/1.9.29/html/Blank.html',
		
		/******************************************************************************
		* LOGIN_URL is used when the session times out to redirect to the login page
		* 
		* DO NOT CHANGE THE VALUE IN THIS FILE! Recast in the overrides.js file
		* 
		*****************************************************************************/	
		LOGIN_URL: "",
		
		/******************************************************************************
		* userdata is used for saving and retrieving user settings via AJAX
		*****************************************************************************/	
		userdata: null,
	
		/******************************************************************************
		* USER_LOCALE is used in the Date Picker to know how to format the date
		* The default is set to english US
		*****************************************************************************/		
		USER_LOCALE: "zh_CN",
	
		/******************************************************************************
		* IS_INTERNAL_USER is used to optionally enable special features/logging
		* for admin users
		*****************************************************************************/		
		IS_INTERNAL_USER: false,
	
		/******************************************************************************
		* IS_MODAL tracks if the current window is modal
		*****************************************************************************/			
		IS_MODAL:false,

		/*
		 * Overridable  - global localizeable strings
		 */	
		strings: {
			LOADING: "\u6B63\u5728\u52A0\u8F7D...",
			PROCESSING: "\u6B63\u5728\u5904\u7406...",
			AUTHORIZING: "\u6B63\u5728\u6388\u6743...",
			SEARCHING: "\u6B63\u5728\u67E5\u627E...",
			SEARCH: "\u641C\u7D22",
			APPLY: "\u5E94\u7528",
			RENAME: "\u91CD\u547D\u540D",
			PROPERTIES: "\u5C5E\u6027",
			MOVE_UP: "\u5411\u4E0A\u79FB\u52A8",
			MOVE_DOWN: "\u5411\u4E0B\u79FB\u52A8",
			DELETE: "\u5220\u9664",
			CLOSE: "\u5173\u95ED",
			CLOSE_WINDOW: "\u5173\u95ED\u7A97\u53E3",
			COLLAPSE: "\u5D29\u6E83",
			DONE: "\u5B8C\u6210",
			EXPAND: "\u6269\u5C55",
			SAVE: "\u4FDD\u5B58",
			NEXT: "\u4E0B\u4E00\u6B65",
			YES: "\u662F",
			NO: "\u5426",
			FINISH: "\u5B8C\u6210",
			CANCEL: "\u53D6\u6D88",
			OK: "\u786E\u5B9A"
		},
// The following countries are known to use a period as the decimal separator
		periodCountries : [    // Middle East
			'IL', //Isreal 
			// Asia
			'CN', // China
			'JP', // Japan
			'MY', // Malasia
			'KR', // South Korea
			'KP', // North Korea
			'TH', // Thailand
			'TW', // Taiwan
			'PH', // Philippines
			'IN', // India
			'PK', // Pakistan 
			'SG', // Singapore
			'HK', // Hong Kong
			// Latin America
			'MX', // Mexico
			'PR', // Puerto Rico
			//Africa
			'NG', // Nigeria
			'BW', // Botswana
			'ZW' // Zimbabwe
		],
		CURRENCY: "$",
	
		/*****************************************************************************
		*
		* $.dr.init runs after html is complete to the browser, but before window.onload()
		*
		*****************************************************************************/
		init: function(){
			
			// Do this check right away to set the IS_MODAL global 
			var isModal = $('body.modalPage').length;
			if (isModal) {
				$.dr.IS_MODAL = true;
			}

			// Legacy Support
			if ($.isFunction(window.customOnload)) {
				customOnload();
			}

			// Make sure domReadyEarly and unobtrusiveEventEarly events get executed as early as possible (BEFORE DOM-ready)
			$(document).trigger('domReadyEarly').trigger('unobtrusiveEventEarly',[document]);

			// Run the rest when jQuery says the document is ready
			$(function(){

				// This needs to run FIRST in this DOM-ready function
				if (isModal) {
					setTimeout(function(){
						(new DR.Utils.PageSizer()).initModalScroller();
					}, 100);
					// if there is no parent, catch the error
					try {
						parent.overlayStack.getCurrent().center(true);
					} 
					// parent does not exist
					catch (e) {
					}
				}

				// Trigger the remaining 4 normal/late events
				$(document).trigger('domReadyNormal');
				$.dr.triggerUnobtrusiveEvents(document);
				$(document).trigger('domReadyLate');

			});

		},
		
		/*
		 * Utility to add dom ready events
		 */
		
		addDomReadyEvent: function(func,_type){
			$(document).bind(_type||'domReadyLate',func);
		},
		
		/*
		 * Utility to add unobtrusive event
		 */
		addUnobtrusiveEvent: function(func,eventName){
			$(document).bind(eventName||'unobtrusiveEventNormal',func);
		},
		
		/*
		 * Fires all unobtrusive events, early, normal, and then late
		 */
		triggerUnobtrusiveEvents: function(context){
			// When the context is the document, the unobtrusiveEventEarly event already ran
			if (context !== document) {
				$(document).trigger('unobtrusiveEventEarly',[context]);
			}
			$(document).trigger('unobtrusiveEventNormal',[context]).trigger('unobtrusiveEventLate',[context]);
		},

		/*
		 * Add an event that will be bound to each field as it is indexed.
		 */
		addPlugin: function(type, callback){
			if(type && typeof callback == 'function' ){
				if(typeof PLUGINS[type] === 'undefined'){
					 PLUGINS[type] = [];
				}
				
				PLUGINS[type].push(callback);
			}
		},
		
		/*
		 * Returns list of plugins
		 */
		getPlugins: function(type){
			return PLUGINS[type];
		},

		/*
		* Empty object where utils will be added.
		*/
		utils:{}
	};

})(jQuery);
	/**
	 * The legacy DR global namespace
	 * @constructor
	 */
 	var DR = window.DR || function(){};
		
	/**
	 * Utility to set up the prototype, constructor and superclass properties to
	 * support an inheritance strategy that can chain constructors and methods.
	 *
	 * @param {Function} subclass the object to modify
	 * @param {Function} superclass the object to inherit
	 */

	DR.Global = function(){};
	DR.Utils = function(){};
	DR.Widgets = function(){};
	$.dr.utils = window.jQuery.dr.utils || {};
	DR.Utils.FormUtils = DR.Utils.FormUtils || {};
	
	/*
	 * Global Variables used in the framework
	 * 
	 * @TODO - Convert these to UPPER CASE and move inside $.dr framework  - need to search codebase
	 */
	var overlayStack,  pageInfo = {};



/* namespace.js
 * jQuery namespace plugin (without eval)
 * Author: Jason Moon
 */
(function($){

// Keep track of each jQuery call, to be used later when a namespaced function is used
var $current = null;
var jQueryInit = $.fn.init;

// Recurse down through the dot-delimited string, returning the object at the end
var getObjectFromSpace = function(names){
	var name = names.shift();
	if (!this[name]) {
		this[name] = {};
	}
	return (names.length) ? getObjectFromSpace.call(this[name], names) : this[name];
};

// Create the namespaced function, which will return the jQuery object from the last jQuery selection that was made
var assignPlugin = function(fn){
	return function(){
		return fn.apply($current, arguments);
	};
};

// Override the jQuery init function to serve as a hook into every jQuery selection that is made
$.fn.extend({
	init: function(selector, context, rootjQuery) {
		$current = new jQueryInit(selector, context, rootjQuery);
		return $current;
	}
});

$.namespace = function(fullname, extension){
	// Handle a single function that is passed as 'extension'; its name will be the last level of the 'fullname' string
	if ($.isFunction(extension)) {
		var nameList = fullname.split('.');
		var finalName = nameList.pop();
		var endSpace = (nameList.length) ? getObjectFromSpace.call($.fn, nameList) : $.fn;
		endSpace[finalName] = assignPlugin(extension);
	} else {
		var finalSpace = $.fn;
		if (typeof fullname === 'string') {
			finalSpace = getObjectFromSpace.call(finalSpace, fullname.split('.'));
			fullname += '.';
		} else {
			// Only a single parameter could be passed in, an object literal
			extension = fullname;
			fullname = '';
		}
		// Handle an object literal, with its properties becoming the plugin functions
		if (extension) {
			$.each(extension, function(key, fn){
				if ($.isFunction(fn)) {
					finalSpace[key] = assignPlugin(fn);
				} else if (typeof fn === 'object') {
					$.namespace(fullname+key, fn);
				}
			});
		}
	}
};

})(jQuery);
;(function(){
		$.dr.utils.appendParam = function(url){
			for (var i=1;i<arguments.length;i++) {
				(function(param){
					if (param) {
						var delim = (/\?/.test(url)) ? '&' : '?';
						url += param.replace(/^\?|&?/, delim);
					}
				})(arguments[i]);
			}
			return url;
		};
})(jQuery);
;(function(){
	/*
	 * Bind a callback function to a custom event to a jquery collection.
	 * 
	 * Example: return this.dr.bindPluginEvent('beforechange', function(){}).each(function(){ });
	 * 
	 * Returns: jQuery collection
	 * 
	 */
	$.namespace('dr.bindPluginEvent', function(eventName, callback){
		if ($.isFunction(callback)) {
			return this.bind(eventName, function(customEvent){
				var callbackResult = callback.apply(this, arguments);
				if (callbackResult === false) {
					customEvent.stopImmediatePropagation();
				}
				return callbackResult;
			});
		} else {
			return this;
		}
	});
	/*
	 * Bind multiple events to a jquery collection. 
	 * 
	 * Example: return this.dr.bindPluginEvents({
	 *					'beforechange':  beforechangeFunction,
	 *					'beforeanimate': beforeanimateFunction,
	 *					'afteranimate':  afteranimateFunction
	 *				}).each(function(){});
	 * 
	 * Returns: jQuery collection
	 */
	$.namespace('dr.bindPluginEvents', function(){
		var events = arguments;
		return this.each(function(){
			for(var i=0;i<events.length;i++){
				for(var e in events[i]){
                    if (events[i].hasOwnProperty(e)) {
                       $(this).dr.bindPluginEvent(e, events[i][e]);
                    }
				}
			}
		});
	});
    /*
     * Private helper function for event binding
     */
    var createPluginEvent = function(namespace){
        // Creates a plugin that binds a callback function to a custom event
        var eventName = namespace.split('.').pop();
        $.namespace(namespace, function(callback){
            return this.dr.bindPluginEvent(eventName, callback);
        });
    };

    /*
     * Bind a single custom event to a namspaced plugin
     * 
     * Example:     $.dr.utils.createPluginEvents('dr.widgetname', ['beforechange', 'beforeanimate', 'afteranimate']);
     * 
     * Returns: void
     */
    // Utility that dynamically creates a plugin that binds its callback function to a custom event with the same name as the new plugin
    $.dr.utils.createPluginEvent = function(namespace){
        createPluginEvent(namespace);
    };
    /*
     * Bind multiple custom events to a namspaced plugin
     * 
     * Example:     $.dr.utils.createPluginEvents('dr.widgetname', ['beforechange', 'beforeanimate', 'afteranimate']);
     * 
     * Returns: void
     */
    $.dr.utils.createPluginEvents = function(namespace,events){
        for(var i=0;i<events.length;i++){
            createPluginEvent(namespace+"."+events[i]);
        }
    };
	// Plugin that fires all custom events on its collection of matched elements
	$.fn.drTriggerEach = function(eventName, params){
		var result = undefined;
		// Trigger the custom event for each matched element
		this.each(function(){
			var tempResult = $(this).triggerHandler(eventName, params);
			if (tempResult !== undefined) {
				result = tempResult;
				// Stop triggering this event for more elements when any one of its handlers returns false
				if (tempResult === false) {
					return false;
				}
			}
		});
		return result;
	};
    /*
    Add a callback function to a timers assoc array, which runs after a set amount of time. Subsequent calls with the same params will reset the timeout.
    This is useful for throttling browser events like 'resize' and 'scroll'
    */
    $.dr.utils.waitForFinalEvent = (function() {
        var timers = {};
        return function(callback, ms, uniqueId) {
            //DO NOT CALL THIS TWICE WITHOUT A UNIQUE ID
            if (!uniqueId) {
                uniqueId = "_"+new Date().getTime() * Math.floor(Math.random()*100000);
            }
            if (timers[uniqueId]) {
                clearTimeout(timers[uniqueId]);
            }
            timers[uniqueId] = setTimeout(callback, ms);
        };
    })();
})(jQuery);
;
(function() {
    var initializing = false, 
        fnTest = /xyz/.test(function() {xyz;}) ? /\b_super\b/ : /.*/;
    
    // The base Class implementation (does nothing)
    this.Class = function() {};
    
    // Create a new Class that inherits from this class
    Class.create = function(prop) {
        var _super = this.prototype;
        
        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;
        
        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
            typeof _super[name] == "function" &&
            fnTest.test(prop[name]) ? (function(name, fn) {
                return function() {
                    var tmp = this._super;
                    
                    // Add a new ._super() method that is the same method but on the super-class
                    this._super = _super[name];
                    
                    // The method only need to be bound temporarily, so we remove it when we're done executing
                    var ret = fn.apply(this, arguments);
                    this._super = tmp;
                    return ret;
                };
            })(name, prop[name]) : prop[name];
        }
        
        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init) {
                this.init.apply(this, arguments);
            }
        }
        
        // Populate our constructed prototype object
        Class.prototype = prototype;
        
        // Enforce the constructor to be what we expect
        Class.constructor = Class;
        
        // And make this class extendable
        Class.create = arguments.callee;
        return Class;
    };
})();

;(function($){
	/*
	 * Normalize Width and Height - useful to get the width of hidden objects on page. normally
	 * in these cases offsetWidth and offsetHeight return zero as the value.
	 */
	var getComputedStyleEnabled = document.defaultView && document.defaultView.getComputedStyle;
    $.dr.utils.getComputedValue = function(obj,propertyName){
        if (getComputedStyleEnabled) {
            return document.defaultView.getComputedStyle(obj,'').getPropertyValue(propertyName);
        }
        else{
            return obj.currentStyle[propertyName];
        }
    };
	$.namespace('dr',{
		computedWidth: function (){
			if(this.length>0){
				var num = parseInt($.dr.utils.getComputedValue(this[0], 'width'),10);
				return (isNaN(num)) ? 0 : num;
			}
		},
		computedHeight: function (){
			if(this.length>0){
				var num = parseInt($.dr.utils.getComputedValue(this[0], 'height'),10);
				return (isNaN(num)) ? 0 : num;
			}
		}
	});
})(jQuery);
;(function($){
    $.dr.utils.normalizeNumber = function(num, locale){
        if (num === null || num === undefined) {
            return null;
        }
        locale = $.dr.utils.getNumberLocale(locale);
        var isDecimalCountry = $.dr.utils.isPeriodCountry(locale);
        var commaPos = num.indexOf(',');
        var decimalPos = num.indexOf('.');
        if (isDecimalCountry) {
            // This includes USA, UK, NZ, en_CA, AU, en_HK, IE and other countries listed in decimalCountries 
            if (decimalPos >= commaPos || decimalPos == -1 || commaPos == -1) {
                num = num.replace(/,/g, "");
            }
        }
        else {
            // For non English speaking countries normalize the decimal point
            if (commaPos >= decimalPos || decimalPos == -1 || commaPos == -1) {
                num = num.replace(/\./g, "").replace(/,/g, ".");
                var numberParts = locale.split(".");
                if (numberParts.length == 2) {
                    num = numberParts[0].replace(/ /g, "");
                }
                else {
                    // some locales like france use space for the thousand separator
                    num = num.replace(/ /g, "");
                }
            }
        }
        return num;
    };
    $.dr.utils.convertCurrencyToNumber = function(obj, val, format, locale){
        if (val === null || val === undefined) {
            return false;
        }
        if (!format) {
            format = $.dr.CURRENCY;
        }
        var num = val.replace(format, "");
        if (format == ' CAD') {
            num = num.replace("C$", "");
            num = num.replace("$", "");
        }
        num = Number($.dr.utils.normalizeNumber(num, locale));
        return num;
    };
    $.dr.utils.getNumberLocale = function(locale) {
        return (typeof locale == "string" && locale.substr(2, 1) == "_") ? locale : $.dr.USER_LOCALE;
    };
})(jQuery);
	/******************************************************************************
	 * DR.Utils.Cookie Class
	 *
	 * This class constructs a cookie object. The cookie is loaded and saved with
	 * an uppercase name.
	 *
	 * This class supports stuffing multiple values into one cookie.
	 *****************************************************************************/
	
	/******************************************************************************
	 * @constructor
	 * This constructs a new cookie object. Always create a cookie object before using.<br />
	 * Read/Write Properties:<br />
	 * path<br />
	 * domain<br />
	 * secure<br />
	 * All others are exposed but should not be set without using supplied interface<br />
	 * Example: <code>var myCookie = new Cookie('myCookieName');</code>
	 * @param {String} name String of cookie name.
	 *****************************************************************************/
	DR.Utils.Cookie = function(name) {
		this.name = name;
		this.expires = null;
		this.path = null;
		this.domain = null;
		this.defaultExpireDays = 365;
		this.secure = null;
		this.type = "Single";
		this.value = null;
		this.valueLoaded = false;
		this.arrayValues = [];
		this.arrayValuesLoaded = false;
		this.arraySeperator = "^";
		this.nameArrayValues = [];
		this.nameArrayValuesLoaded = false;
		this.nameArraySeperator = "&";
		this.nameArrayInnerSeperator = ":";
	};
	
	/*
	DR.Utils.Cookie.ERROR_VALID_DATE = "You must enter a valid date";
	*/
	DR.Utils.Cookie.ERROR_VALID_DATE = "\u8F93\u5165\u6709\u6548\u65E5\u671F\u3002";
	
		/******************************************************************************
		 * Inherited Class Methods
		 *****************************************************************************/
	DR.Utils.Cookie.prototype ={

		/******************************************************************************
		 * Checks to see if date passed in is valid.<br />
		 * Example: <code>cookieObj.setExpires(expires)</code>
		 * @param {String/Date} expires Date string or Date Object. String should be formatted as mm/dd/yyyy.
		 *****************************************************************************/
		setExpires: function(expires) {
			if (!this.nameArrayValuesLoaded){
				this.load();
			}
		
			if (expires !== null) {
				expires = new Date(expires);
		
				if (expires.constructor == Date) {
					this.expires = expires.toGMTString();
				} else {
					alert(DR.Utils.Cookie.ERROR_VALID_DATE);
				}
			}
		},
		
		setExpireDays: function(days) {
			this.defaultExpireDays = days;
		},
		
		/******************************************************************************
		 * Loads Cookie by name passed into the cookieObj.<br />
		 * Example: <code>cookieObj.load()</code>
		 * @return {Boolean} Boolean if load succeeded
		 *****************************************************************************/
		load: function() {
			var cookies = document.cookie;
		
			if (cookies === '') {return false;}
		
			var cookieStart = cookies.indexOf(this.name + '=');
		
			if (cookieStart != -1) {
				cookieStart += this.name.length + 1; //include "="
				var cookieEnd = cookies.indexOf(';', cookieStart);
		
				if (cookieEnd == -1) {cookieEnd = cookies.length;}
				
				var stringValue = unescape(cookies.substring(cookieStart, cookieEnd));
		
				if (this.type=="Single")
				{
					this.value = stringValue;
					this.nameArrayValuesLoaded = true;
				}
				else if (this.type=="NameValuePair")
				{
					this.splitCookiePairs(stringValue);
				}
				else if (this.type=="Array")
				{
					this.splitCookieArray(stringValue);
				}
						
				return true;
			}
		
			return false;
		},
		
		/******************************************************************************
		 * Creates/overwrites cookie based on the supplied name. The values Array is 
		 * joined together to form one string for the cookie.<br />
		 * Example: <code>cookieObj.save()</code>
		 *****************************************************************************/
		save: function() {
			
			var v = "";
			if (this.type=="Single")
			{
				v = this.value;
			}
			else if (this.type=="NameValuePair")
			{
				v = this.joinNameValuePairs();
			}
			else if (this.type=="Array")
			{
				v = this.joinArrayValues();
			}
			if (this.expires===null)
			{
				this.expires = this.getDateOffset(this.defaultExpireDays);
			}
		
			document.cookie = this.name + "=" + escape(v) +
		    ((this.expires) ? "; expires=" + this.expires : "") +
		    ((this.path) ? "; path=" + this.path : "") +
		    ((this.domain) ? "; domain=" + this.domain : "") +
		    ((this.secure) ? "; secure" : "");
		
		},
		
		/******************************************************************************
		 * Creates/Sets a value for the cookie.<br />
		 * This method automatically calls save(), after the value has been added.<br />
		 * Example: <code>cookieObj.setValue(value)</code><br />
		 * @param {String} value String for the value
		 *****************************************************************************/
		setValue: function(value) {
			if (!this.nameArrayValuesLoaded) { this.load(); }
			this.value=value;
			this.type = "Single";
			this.save();
		},
		
		/******************************************************************************
		 * Deletes the cookie and clears the memory<br />
		 * Example: <code>cookieObj.delete(value)</code>
		 * @param {String} value String for the value
		 *****************************************************************************/
		clear: function() {
		
			// Set the expires date to right now
			var c = new Date();
			document.cookie = this.name + "="  +
		    ((this.expires) ? "; expires=" + c.toGMTString() : "") +
		    ((this.path) ? "; path=" + this.path : "") +
		    ((this.domain) ? "; domain=" + this.domain : "") +
		    ((this.secure) ? "; secure" : "");
			
			// Free up the memory
			this.name = null;
			this.expires = null;
			this.path = null;
			this.domain = null;
			this.defaultExpireDays = null;
			this.secure = null;
			this.type = null;
			this.value = null;
			this.valueLoaded = null;
			this.arrayValues = null;
			this.arrayValuesLoaded = null;
			this.arraySeperator = null;
			this.nameArrayValues = null;
			this.nameArrayValuesLoaded = null;
			this.nameArraySeperator = null;
			this.nameArrayInnerSeperator = null;
		},
		
		/******************************************************************************
		 * This function adds an item to an array cookie, if it already exists,
		 * it moves to the end. Then it saves the new array into the cookie.<br />
		 * Example: <code>cookieObj.addArrayValue(itemValue)</code>
		 * @param {String} itemValue String for the value. It can not contain "^" 
		 *****************************************************************************/
		addArrayValue: function(itemValue) {
			
			this.type = "Array";
			if (!this.arrayValuesLoaded) { this.load(); }
			
			var value = '';
			var ary = this.arrayValues;
			var temp = [];
			var k=0;
			if (ary.length>0){
				for (var i=0;i < ary.length;i++) 
				{
					if (ary[i]!=itemValue)
					{
						value += ary[i] + this.arraySeperator;
						temp[k] = ary[i];
						k++;
					}
				}
			}
			temp[k] = itemValue;
			value += itemValue + this.arraySeperator;
			this.arrayValues = temp;
			this.value = value;
			this.save();
		
		},
		
		/******************************************************************************
		 * Removes an item from the array if found. Saves the changed array back to the cookie<br />
		 * Example: <code>cookieObj.removeArrayValue(itemValue)</code>
		 * @param {String} itemValue String for the value. It can not contain "^" 
		 *****************************************************************************/
		removeArrayValue: function(itemValue) {
			this.type = "Array";
			var value = '';
			var ary = this.arrayValues;
			var temp = [];
			var k=0;
			for (var i=0;i < ary.length;i++) 
			{
				if (ary[i]!=itemValue)
				{
					value += ary[i] + this.arraySeperator;
					temp[k] = ary[i];
					k++;
				}
			}
			this.arrayValues = temp;
			this.value = value;
			this.save();
		},
		
		/******************************************************************************
		 * Creates/Sets a name value pair for the cookie.
		 * If the cookie has not been loaded it calls load(). This method automatically
		 * calls save(), after the value has been added.<br />
		 * Example: <code>cookieObj.setValue(name, value)</code>
		 * @param {String} name String for the name. It can not contain "&" or ":"
		 * @param {String} value String for the value. It can not contain "&" or ":"
		 *****************************************************************************/
		setNameValuePair: function(name, value) {
			var v = value+'';
			if (name.indexOf('&') == -1 && name.indexOf(':') == -1 && v.indexOf('&') == -1 && v.indexOf(':') == -1)
			{
				if (!this.nameArrayValuesLoaded) { this.load(); }
				this.type = "NameValuePair";
				this.nameArrayValues[name] = value;
				this.save();
			}
		},
		
		/******************************************************************************
		 * Gets a value based on the name from the cookie.
		 * If the cookie has not been loaded it calls load().<br />
		 * Example: <code>cookieObj.getValue(name)</code>
		 * @param {String} name String for the name. It can not contain "&" or ":"
		 * @return {String} String for the value of name.
		 *****************************************************************************/
		getValue: function(name) {
			if (!this.nameArrayValuesLoaded){this.load();}
			if (name)
			{
				return this.nameArrayValues[name];
			}else{
				return this.value;
			}
		},
		
		/******************************************************************************
		 * Removes the name value pair from the cookie. Loads cookie if not already
		 * loaded. Remaining name value pairs are saved.<br />
		 * Example: <code>cookieObj.removeValue(name)</code>
		 * @param {String} name String for the name. It can not contain "&" or ":"
		 *****************************************************************************/
		removeValue: function(name) {
			if (!this.nameArrayValuesLoaded){this.load();}
			delete this.nameArrayValues.name;
			this.save();
		},
		
		/******************************************************************************
		 * Removes all values from the cookie. Loads cookie if not already
		 * loaded. Empty cookie is saved.<br />
		 * Example: <code>cookieObj.removeAllValues(expires)</code>
		 * @param {String/Date} expires Date string or Date Object. String should be formatted as mm/dd/yyyy.
		 *****************************************************************************/
		removeAllValues: function() {
			if (!this.nameArrayValuesLoaded){this.load();}
			this.nameArrayValues = [];
		},
		
		/******************************************************************************
		 * This is a private function it should not be called from outside the object.
		 * Creates an array of name value pairs. Pairs are separted by "&". Name
		 * values are separated by ":"<br />
		 * Example: <code>cookieObj.splitCookiePairs(valuesStr)</code>
		 * @param {String} valueStr
		 *****************************************************************************/
		splitCookiePairs: function(valueStr) {
			var vals = valueStr.split(this.nameArraySeperator);
		
			for (var i = 0; i < vals.length; i++) {
				vals[i] = vals[i].split(this.nameArrayInnerSeperator);
			}
		
			//Empty Values first
			this.nameArrayValues = [];
		
			for (var j = 0; j < vals.length; j++) {
				this.nameArrayValues[vals[j][0]] = vals[j][1];
			}
			
			this.joinNameValuePairs();
		},
		
		/******************************************************************************
		 * This is a private function it should not be called from outside the object.
		 * Creates an array of name value pairs. Pairs are separted by "^".<br /> 
		 * Example: <code>cookieObj.splitCookieArray(valueStr)</code>
		 * @param {String} valueStr
		 *****************************************************************************/
		splitCookieArray: function(valueStr) {
			var ary = [];
			if (valueStr!==null) 
			{
				var i=0;
				while (valueStr.indexOf(this.arraySeperator) != '-1') 
				{
					ary[i] = valueStr.substring(0,valueStr.indexOf(this.arraySeperator));
					i++;
					valueStr = valueStr.substring(valueStr.indexOf(this.arraySeperator)+1, valueStr.length);
				}
			}
			this.arrayValues = ary;
			this.joinArrayValues();
		},
		
		/******************************************************************************
		 * This is a private function it should not be called from outside the object.
		 * Joins the values array into one string. Escapes characters as needed.<br />
		 * Example: <code>cookieObj.joinNameValuePairs()</code>
		 * @return {String} String delimited string of name value pairs.
		 *****************************************************************************/
		joinNameValuePairs: function() {
			var temp = [];
		
			for(var i in this.nameArrayValues) {
				temp[temp.length] = i + this.nameArrayInnerSeperator + this.nameArrayValues[i];
			}
			
			var v = temp.join(this.nameArraySeperator);
			this.value=v;
			return v;
		},
		
		/******************************************************************************
		 * This is a private function it should not be called from outside the object.
		 * Joins the values array into one string. Escapes characters as needed.<br />
		 * Example: <code>cookieObj.joinArrayValues()</code>
		 * @return {String} String delimited string of name value pairs.
		 *****************************************************************************/
		joinArrayValues: function() {
			var v = '';
			if (this.arrayValues.length>0){
				for (var i=0;i < this.arrayValues.length;i++) 
				{
					v += this.arrayValues[i] + this.arraySeperator;
				}
			}
			this.value = v;
			return v;
		},
		
		/******************************************************************************
		 * This function does date math to figure out the expiration date based
		 * on how many days are passed in<br />
		 * Example: <code>cookieObj.getDateOffset()</code>
		 * @return {String} String delimited string of name value pairs.
		 *****************************************************************************/
		getDateOffset: function(days) {
			var today = new Date();
			today.setTime( today.getTime() );
			if ( days ) 
			{
				var expires = days * 1000 * 60 * 60 * 24;
				var expires_date = new Date( today.getTime() + (expires) );
				return expires_date;
			}
		}
	};
/**
 * Beacon Data Library 2.0 
 * copyright 2012 Digital River, Inc. All rights reserved.
 */

/**
 * DataUtils defines a set of common utilities for use with the
 * Data Library
 */
;(function($) {

$.dr.DataUtils = (function() {
    var id = 0;
    var IDSTR = 'dr_element_';
    
    return {
        /**
         * Create unique chart ids
         */
        elementId: function() {
            id++;
            return IDSTR + id;
        }
    };
})();

/**
 * Defines a Custom Error object
 */
$.dr.DataError = function(type, msg) {
    this.name = type || 'Data Error';
    this.message = msg || "An unknown error has occured in the Data Package."; 
};

$.dr.DataError.prototype = new Error();
$.dr.DataError.constructor = $.dr.DataError;

/**
 * Defines a singleton object for providing sort functions
 * to sort a DataSource
 */
$.dr.DataSorter = (function() {
    var sorters = {
        'string': function(col, desc) {
            return function(a, b) {
                var astr = (typeof a.getValue(col.cid) === "string") ? a.getValue(col.cid).toLowerCase() : null;
                var bstr = (typeof b.getValue(col.cid) === "string") ? b.getValue(col.cid).toLowerCase() : null;
                var out = astr > bstr ? 1 : astr < bstr ? -1 : 0;
                return desc ? -out : out;
            };
        },
        'integer': function(col, desc) {
            return function(a, b) {
                var aint = parseInt(a.getValue(col.cid), 10);
                var bint = parseInt(b.getValue(col.cid), 10);
                if (isNaN(aint) || isNaN(bint)) {
                    return 0;
                }
                var out = aint > bint ? 1 : aint < bint ? -1 : 0;
                return desc ? -out : out;
            };
        },
        'number': function(col, desc) {
            return function(a, b) {
                var afloat = parseFloat(a.getValue(col.cid), 10);
                var bfloat = parseFloat(b.getValue(col.cid), 10);
                if (isNaN(afloat) || isNaN(bfloat)) {
                    return 0;
                }
                var out = afloat > bfloat ? 1 : afloat < bfloat ? -1 : 1;
                return desc ? -out : out;
            };
        },
        'date': function(col, desc) {
            return function(a, b) {
                // use the dr.date utility to construct a date 
                var adt = (a instanceof Date) ? a : $.dr.date(a.getValue(col.cid));
                var bdt = (b instanceof Date) ? b : $.dr.date(b.getValue(col.cid));
                
                if (isNaN(adt) || isNaN(bdt)) {
                    return 0;
                } else {
                    var out = adt > bdt ? 1 : adt < bdt ? -1 : 1;
                    return desc ? -out : out;
                }
            };
        },
        'default' : function(col, desc) {
            return function(a, b) {
                return a.getValue(col.cid) > b.getValue(col.cid) ? 1 : a.getValue(col.cid) < b.getValue(col.cid) ? -1 : 0;
            };
        }
    };
    
    return {
        getSorter: function(col, desc) {
            switch(col.dataType) {
                case 'string' : 
                    return sorters.string(col, desc);
                    break;
                case 'integer' : 
                    return sorters.integer(col, desc);
                    break;
                case 'float': 
                    return (typeof sorters['float'] === 'undefined') ? 
                        sorters.number(col, desc) : sorters['float'](col, desc);
                    break;
                case 'percent' : 
                    return (typeof sorters['percent'] === 'undefined') ? 
                        sorters.number(col, desc) : sorters['percent'](col, desc);
                    break;
                case 'currency' : 
                    return (typeof sorters['currency'] === 'undefined') ? 
                        sorters.number(col, desc) : sorters['currency'](col, desc);
                    break;
                case 'number' : 
                    return sorters.number(col, desc);
                    break;
                case 'date' : 
                    return sorters.date(col, desc);
                    break;
                case 'default' : 
                    return (typeof sorters[col.dataType] === 'undefined') ? 
                        sorters[col.dataType](col, desc) : sorters['default'](col, desc);
                    break;
            }
        },
        addSorter: function(type, sortFunc) {
            sorters[type] = function() {
                return sortFunc.apply(this, arguments);
            };
        }
    }
}());

/**
 * Defines a clients side storage object with an event API.
 * 
 * @param {Object} options an object of key/value pairs 
 * @param {Object/String} data an optional 
 * @param {Function} callback an optional callback to run after loadSucess. Only used 
 *     if the optional data parameter is not null.
 * @return {Object} the DataSource
 */

$.dr.DataSource = function(options, data, callback) {
    this.DEFAULT_PRECISION = 2;    // defines the default decimal precision.
    
    this.data = [];         // stores the data client-side
    this.cm;                // holds the column model. Should be $.dr.DataColumnModel object;
    
    // TODO this is here specifically to handle aborted requests. Can this be removed to the 
    // DataController class ? 
    this.xhrRequest = null; // holds a reference to the Ajax Request.
    this.requestParameters = {};

    // usage: new $.dr.DataSource(data);
    if (typeof options !== "object" && arguments.length === 1) {
        // assume that there are no options, only data is passed in
        data = options;
        options = {};
    }

    // usage: new $.dr.DataSource(data, callback);
    if ((arguments.length === 2 && typeof data === "function")) {
        callback = data;
        data = options;     
        options = {};
    }
    
    // set some default options
    // TODO Set Defaults to add a Default parsers for data types
    this.options = {
        dataType: 'xml'
    };
    
    // a private initialization function
    var init = function(o, d, c) {
        // first, set the column model if one was passed in, or create a new one
        try{
            this.setColumnModel(o.columnModel);
        } catch (e) {
            if (console && typeof console.log === "function") {
                // ignore catch for o.columnModel is undefined
            }
        }
        // set the options object
        this.setOptions(o);
        
        // Parse the data object if one was provided.
        // This will create and set a new column model, over-riding the column
        // model from the constructor if one was passed in.
        // TODO prefer the passed column model
        if (d !== undefined && d.contentType === "application/xml") {
            this.loadSuccessCallback.call(this, d, c);
        } else {
            this.setIsLoaded(false);
            this.setIsLoading(false);
        }
        
        // define the default parsers. Done here so that every 
        // instance of DataSource gets its own copy of the parsers
        this.parsers = [];
        this.addParser('xml', new $.dr.DataParser(function(xmlDoc) {
            var cm = this.getColumnModel();
            var $data = $('data', xmlDoc);
            var oThis = this;
            
            $data.find('row').each(function(rindex, row) {
                var temp = {}, i, l = cm.getLength(), col, fmt;
                for (i = 0; i < l; i++) {
                    col = cm.get(i);
                    temp[col.cid] =  $(this).find(col.cid).text() || '';
                }
                oThis.addRow(temp, true);
            });

            return true;            
        }));
        
        this.addParser('json', new $.dr.DataParser(function(jsonData){
            if (typeof jsonData !== 'undefined') {
                var oThis = this;
                $.each(jsonData.data.rows, function(index, row) {
                    oThis.addRow(row);
                });
                return true;
            }          
        }));
    };

    // run the private init function
    init.call(this, options || {}, data, callback);
};

$.dr.DataSource.prototype = {
    // Parser Interface
    getParser : function(dataType) {
        dataType = (dataType === undefined) ? this.getOption('dataType') : dataType;
        return this.parsers[dataType];
    },

    addParser : function(dataType, parser) {
        // make sure that we can use this parser. use instanceof or duck-typing
        if(parser instanceof $.dr.DataParser || $.isFunction(parser.parse)) {
            this.parsers[dataType] = parser;
        }
    },
    
    renderers : {
        'integer' : function(v) {
            return v;
        },
        'text' : function(v) {
            return v;
        },
        'currency' : function(v, row, col, rindex, cindex, formatOptions) {
            var o = {};
            var pos = formatOptions.currencyPosition || 'prefix';
            var p = formatOptions.precision || 2;
            
            if (formatOptions.currencySymbol) {
                o[pos] = formatOptions.currencySymbol;
            }
            return v.formatNum("","",p, o);
        },
        'number' : function(v, row, col, rindex, cindex, formatOptions) {
            return v.formatNum(formatOptions.precision || this.DEFAULT_PRECISION);            
        },
        'date' : function(v, row, col, rindex, cindex, formatOptions) {
            return v;            
        },
        'percent' : function(v, row, col, rindex, cindex, formatOptions) {
            v = v - 0; // cast to number
            if (isNaN(v)) {
                return v;
            } else {
                return v.formatNum("","",formatOptions.precision, {postfix: '%'});
            }
        }
    },
    /**
     * Get the renderer for this data type or the default renderer.
     * @param {String} type
     */
    getRenderer : function(type) {
        var r = this.renderers[type] || this.renderers['text'];
        return r;
    },
    // @deprecated
    getFormatFunction : function(cindex) {
        var cm = this.getColumnModel();
        var col;           // the dataColmn object referred to by cindex
        
        if (isNaN(cindex)) {
            cindex = this.getColumnIndex(cindex);
        }
        
        if (cindex !== -1) {
            col = cm.get(cindex);  
            if (col) {
                if ($.isFunction(col.renderer)) {
                    return col.renderer;
                } else {
                    return this.getRenderer(col.dataType);
                }
            } else {
                return this.getRenderer();
            }            
        }       
    },
    // Constructor functions
    setOptions : function(o) {
        // a special case for params
        var oSelf = this;
        if (o && o.params && typeof o.params === "object" ) {
            _.each(o.params, function(v, k) {
                oSelf.setParam(k, v);
            });
        }
        oSelf.options = $.extend(true, {}, oSelf.options, o); 
    },

    getOptions : function() {
        return this.options;
    },

    setOption : function(key, value) {
        this.options[key] = value;
    },

    getOption : function(key) {
        return this.options[key];
    },

    getDataUrl : function() {
        return this.getOption("url");
    },

    setDataUrl : function(url) {
        this.setOption("url",url);
    },

    // Data Interface
    getData : function() {
        return this.data;
    },
    /**
     * @deprecated Will move to visualization packages in future releases
     * 
     * An AM Charts specific function for providing data in the
     * the AM Charts format
     * @param {Object} formatOptions
     * @return {Array of Objects}
     */
    getDataProvider : function(formatOptions) {
        var dp = [], row;
        var cm = this.getColumnModel();

        if (typeof formatOptions === 'undefined') {
            formatOptions = {};
        }

        for (var rindex = 0 , l =  this.data.length; rindex < l; rindex ++) {
            if (this.data[rindex].display) {
                row = this.data[rindex].getData();
                // if we have set a renderer on the column, use it 
                for (var cindex = 0; cindex < cm.getLength(); cindex ++) {
                    var col = cm.get(cindex);
                    if ($.isFunction(col.renderer)) {
                        row[col.cid] = col.renderer.call(this, row[col.cid], row, col, rindex, cindex, formatOptions);
                    }
                }
                dp.push(row);
            }
        }
        return dp;
    },
    /**
     * Column Model Interface
     *
     * Get a list of column definitions
     * @return {Array of DataColumn Objects}
     */
    getColumns : function() {
        if (this.cm && this.cm instanceof $.dr.DataColumnModel){
            return this.cm.get();
        }
        return;
    },
    /**
     * Return the column model that is bound to this data source.
     * If column model was not set, or it was not an instance of DataColumnModel
     * a new column model will be created and returned.
     * 
     * @return {Object} the DataColumnModel
     */
    getColumnModel : function() {
        if (typeof this.cm !== 'undefined' && this.cm instanceof $.dr.DataColumnModel){
            return this.cm;
        } else {
            return new $.dr.DataColumnModel();
        }
    },
    /**
     * Set the column model
     * @param {Object} m An instance of $.dr.DataColumnModel or an object to be used
     *     in the columnModel constructor
     * @throws {$.dr.DataError} Throws an exception if column mode is null or      
     */
    setColumnModel : function(m) {
        if (m == null) {
            throw new $.dr.DataError("IllegalArgumentError", "Column Model is null or undefined");
        } else {
            if (m instanceof $.dr.DataColumnModel){
                this.cm = m;
            } else {
                try{
                    this.cm = new $.dr.DataColumnModel(m);
                } catch (ex) {
                    if (console && typeof console.error === "function") {
                        console.error(ex, m);
                    }
                    this.cm = new $.dr.DataColumnModel();
                }
            }
            $(this).drTriggerEach('dr-columnModelUpdate.datasource', [this]);
            return this.cm;
        }
    },
    /**
     * Clears the current column model
     */
    removeColumnModel: function() {
        this.cm = [];    
    },
    // TODO remove this from the prototype.
    _createColumnModel : function(xmlDoc){
        var cm = [];
        if (typeof xmlDoc === "undefined") {
            // request to get the columnModel
            return new $.dr.DataColumnModel();
        } else {
            switch(this.getOption('dataType')) {
                case 'json':
                    // TODO sanity checking in the column model
                    if (typeof xmlDoc.head !== 'undefined' &&
                            typeof xmlDoc.head.columns !== 'undefined') {
                        cm = xmlDoc.head.columns;
                    }
                break;
                default: 
                    $('columns column', xmlDoc).each(function(cindex, c){
                        var $c = $(c);
                        var o = {
                            cindex: cindex,
                            cid: $c.attr('id') || cindex,
                            displayName: $c.attr('caption') || c.cid,
                            dataType: $c.attr('stereotype') ? $c.attr('stereotype').toLowerCase() : 'string',
                            display: $c.attr('visible') === 'false' ? false : true,
                            trendType : $c.attr('trendtype') || ''
                        };
                        cm.push(o);
                    });
                break;
            }
            return new $.dr.DataColumnModel(cm);           
        }
    },
    /**
     * Retrieves the index of a column with the id that matches colmnNanme
     * @param {Object} columnName
     */
    getColumnIndex : function(columnName) {
        return this.getColumnModel().getColumnIndex(columnName);
    },
    /**
     * Add a new row of data to the store.
     * @param {$.dr.DataRow|Object|Array} ar A DataRow, Object or Array of data
     * @param {Boolean} display [optional - Default true] Sets the value of the display 
     *     property of this DataRow. 
     * @param {Number} index [optional] the index of the row. A 
     *     blank index appends to the end of the data set.
     * @return index The index of the row inserted.
     */
    addRow : function(ar, display, index, selectable) {
        var cm = this.getColumnModel();
        var l = cm.getLength();
        var oThis = this;
        var row = {};

        index = index || this.data.length; // if index is specified, splice the row. Otherwise, append
        // check the format of what we passed in.
        if (typeof ar === 'undefined') {
            ar = [];
        }

        if (ar instanceof $.dr.DataRow) {
            row = ar;
        } else {
            if ($.isArray(ar)) {
                for (var i = 0; i < l; i++) {
                    row[cm.get(i).cid] = ar[i] || '';
                }
            } else {
                for (var i = 0; i < l; i++) {
                    // make sure that the object has all of the columns represented
                    var cid = cm.get(i).cid;
                    row[cid] = ar[cid] || '';
                }
            }
            // call the DataRow constructor
            row = new $.dr.DataRow(row, display, index, selectable);
        }

        if (! this.data.length || index === this.data.length) {
            this.data.push(row);
        } else if (index >= 0 && index < this.data.length) {
            this.data.splice(index, 0, row);
        }

        $(this).trigger('dr-addrow.datasource', [this, row, index]);
        return index;
    },
    /**
     * @deprecated Use getRow(index).hide()
     * Sets the display property of the row at index to false
     * 
     * @param {Number} index
     * @return {Boolean} true for an index in bounds; false for an index out of bounds.
     */    
    hideRow : function(index) {
        var row = this.getRow(index);
        var r = false; 
        if (row && $.isFunction(row.hide)) {
            row.hide();
            r = true;
        }
        return r;
    },
    /**
     * @deprecated User getRow(index).show();
     * Sets the display property of the row at index to true
     * @param {Number} index
     * @return {Boolean} true for an index in bounds; false for an index out of bounds.
     */  
    showRow : function(index) {
        var row = this.getRow(index);
        var r = false; 
        if (row && $.isFunction(row.show)) {
            row.show();
            r = true;
        }
        return r;
    },
    /**
     * Remove the row from the data set and return it.
     * @param {$.dr.DataRow|Number} index
     * @return {Boolean} DataRow for an index in bounds; undefined for an index out of bounds.
     */  
    removeRow : function(index) {
        var r; // our return value
        // check the index is in bounds
        if (index instanceof $.dr.DataRow) {
            var indexToRemove = -1;
            _.each(this.getData(), function(r, i){
                if (_.isEqual(r.data, index.data)) {
                    indexToRemove = i;
                }
            });
            if (indexToRemove > -1 && indexToRemove < this.data.length) {
                r = this.data.splice(indexToRemove, 1)[0];
            }
        } else if (index > -1 && index < this.data.length) {
            // this.sortOnIndex();
            r = this.data.splice(index, 1)[0];
        }
        this._reIndex();
        return r;
    },
    /*
     * Remove all of the rows of data
     */
    removeAllRows : function( ){
        var oSelf = this;
        while(oSelf.data.length) {
            oSelf.removeRow(0);
        }
    },
    /**
     * resets the rindex property of each data row.
     */
    _reIndex : function() {
        for (var i = 0, l = this.data.length; i < l; i++) {
            var row = this.getRow(i).setIndex(i);
        }
    },
    /**
     * Returns the DataRow object specified by the row index argument. 
     * Returns undefined for index out of bounds. The object returned is 
     * a DataRow Object.
     * 
     * @param {Number} rindex The row index
     * @return {DataRow|undefined} The Data Row object
     */
    getRow : function(rindex) {
        if (rindex >= 0 && rindex < this.data.length) {
            return this.data[rindex];
        }
        return;
    },
    /**
     * Returns the JavaScipt object that represents data in a DataRow
     * Wraps getRow(index).getData();
     * 
     * @param {Object} rindex The index of the row
     * @return {Object} a JavaScript object or undefined
     */
    getRowData : function(rindex) {
        return this.getRow(rindex).getData();
    },
    /**
     * Returns the JavaScript object that represents a data row. 
     * The same as calling getRow(rindex).getData()
     * @param {Object} rindex
     * @return {Object|undefined} The object
     */
    getRowArray : function(rindex) {
        if (rindex >= 0 && rindex < this.data.length) {
            var cm = this.getColumnModel();
            var row = this.getRow(rindex).getData();
            var ar = [];
            
            
            // TODO is map more efficient?
            for (var i = 0, l = cm.getLength(); i < l; i++) {
                try {
                    var col = cm.get(i);
                    ar.push(row[col.cid]);
                } catch (e) {
                    ar.push('');
                }
            }
            return ar;
        }
        return;
    },
    /**
     * Get the display property of the row at index.
     * @param {Object} index
     * @return {Boolean} The display property or undefined for an index 
     *     out of bounds.
     */
    getRowDisplay : function(index){
        try {
            return this.getRow(index).display;
        } catch (ex) {
            return undefined;
        }
    },
    
    // Column Interface
    /**
     * Add a new column and optionally insert the column data into
     * each DataRow. 
     * 
     * @param {Object} index The index of the column to add
     * @param {Object} def The column definition
     * @param {Object} insData Data to insert
     * @param {Object} fmt A function to format the data before inserting
     */
    addColumn : function(index, def, insData, fmt) {
        var cm = this.getColumnModel();
        if (typeof index === 'object') {
            fmt = insData;
            insData = def;
            def = index;
            index = cm.getLength();            
        }

        def.cindex = index;   
        
        var col = cm.addColumn(def, index);

        var v, data = this.getData();
        if (insData && $.isArray(insData)) {
            for (var rindex = 0, numRows = data.length; rindex < numRows; rindex ++) {
                v = (insData.length > rindex) ? insData[rindex] : '';
                v = $.isFunction(fmt) ? fmt.call(this, v, data[rindex], col, rindex, index) : v;
                data[rindex][col.cid] = v;
            }
        }
        $(this).trigger('dr-columnModelUpdate.datasource', [cm]);
        // return the index if it is not out-of-bounds
        return index; 
    },
    /**
     * Set the column display property to true
     * @param {Object} index The index of the column. If isNaN(index) is 
     *     true, it is assumed that a string for a column name was passed
     *     and the column index will be determined by calling getColumnIndex(index)
     */
    showColumn : function(index) {
        index = (isNaN(index)) ? this.getColumnIndex(index) : index;
        var cm = this.getColumnModel();
        if (index >= 0 && index < cm.getLength()) {
            if (cm.get(index)) {
                cm.get(index).display = true;
            }
            $(this).trigger('dr-columnModelUpdate.datasource', [cm]);
            return true; // return true if the index is not out-of-bounds
        }
        return false; // index out of bounds
    },
    /**
     * Set the column display property to false
     * @param {Object} index The index of the column. If isNaN(index) is 
     *     true, it is assumed that a string for a column name was passed
     *     and the column index will be determined by calling getColumnIndex(index)
     */
    hideColumn : function(index) {
        index = (isNaN(index)) ? this.getColumnIndex(index) : index;
        var cm = this.getColumnModel();
        if (index >= 0 && index < cm.getLength()) {
            if (cm.get(index)) {
                cm.get(index).display = false;
            }
            $(this).trigger('dr-columnModelUpdate.datasource', [cm]);
            return true; // return true if the index is not out-of-bounds
        }
        return false; // index out of bounds
    },
    /**
     * Remove a column from the column model. Remove the column from the data from the data rows.
     * 
     * @param {Object} index The index of the column. If isNaN(index) is 
     *     true, it is assumed that a string for a column name was passed
     *     and the column index will be determined by calling getColumnIndex(index)
     * @return {DataColumn} for an index in bounds. undefined for an index out of bounds.
     */
    removeColumn : function(index) {
        var cm = this.getColumnModel();
        var col, key, row;
        index = (isNaN(index)) ? this.getColumnIndex(index) : index;

        if (index >= 0 && index < cm.getLength()) {
            col = cm.get(index);
            key = col.cid;
            cm.removeColumn(index);
            for(var i = 0, l = this.data.length; i < l; i++) {
                row = this.getRow(i).getData();
                try {
                    delete row[key];
                } catch (e) {
                    // ignore catch for row[key] does not exist.
                }
            }
            return col; // return the index if it is not out-of-bounds
        }
        return;
    },
    /**
     * Get the display name of the column 
     * @param {Object} index The index of the column. If isNaN(index) is 
     *     true, it is assumed that a string for a column name was passed
     *     and the column index will be determined by calling getColumnIndex(index)
     */
    getColumnDisplayName : function(index) {
        var cindex = (isNaN(index)) ? this.getColumnIndex(index) : index;
        var cm = this.getColumnModel();
        if (cindex !== -1) {
            return cm.get(cindex).displayName;
        }    
    },
    /**
     * Return the column definintion for the column at index
     * 
     * @param {Object} index The index of the column;
     * @return DataColumn or undefined for an index out of bounds
     */
    getColumn : function(index) {
        var cm = this.getColumnModel();
        var cindex  = parseInt(index, 10);
        var col;

        if (isNaN(cindex)) {
            // assume the index passed in was the column name.
            cindex = this.getColumnIndex(index);
        }
        if (cindex != null && (cindex > -1 && cindex < cm.getLength())) {
            col = cm.get(cindex);
        }
        return col;
    },
    // @deprecated Use getColumn
    getColumnDefinition : function(index) {
        index = (isNaN(index)) ? this.getColumnIndex(index) : index;
        var cm = this.getColumnModel();
        if (index >= 0 && index < cm.getLength()) {
            return cm.get(index);
        } 
    },

    // Data Interface
    load : function(callback, errorCallback) {
        var oThis = this;
        var o = this.getOptions();

        if ($(this).triggerHandler('dr-beforeLoad.datasource', [this]) !== false) {
            // set the request parameters
            $.dr.chartDataController.setParams(this.getRequestParameters(), true);
            this.setIsLoading(true);
            this.setIsLoaded(false);
        
            // abort any running ajax requests on this object.
            if (typeof this.xhrRequest !== 'undefined' && this.xhrRequest !== null) {
                if ($.isFunction(this.xhrRequest.abort)){
                    this.xhrRequest.abort();
                }
            }
            // set the caching option in the data controller 
            if (o.cache !== false) {
                $.dr.chartDataController.setOption('cache', true);
            } else {
                $.dr.chartDataController.setOption('cache', false);
            }
            $.dr.chartDataController.setOption('dataType', this.getOption('dataType'));
            
            this.xhrRequest = $.dr.chartDataController.getData(
                o.url, 
                function(xml) {
                    oThis.xhrRequest = null;
                    oThis.loadSuccessCallback.call(oThis, xml, callback);
                },  
                function(xhr,status,error) { //this will be errorCallback inside getData
                    $(oThis).trigger("dr-loadingError.datasource",[xhr,status,error]);
                    if (errorCallback && typeof errorCallback === 'function') {
                        errorCallback.call(oThis, xhr, status, error);
                    }                       
                    oThis.xhrRequest = null;
                }
            );
        }
    },

    loadSuccessCallback : function(xmlDoc, callback) {
        var cm;
        
        this.data = [];

        // TODO this is specific to XML data
        if (! (this.cm instanceof $.dr.DataColumnModel) ) {
            cm = this._createColumnModel(xmlDoc);
            this.setColumnModel(cm);
        }
        
        // saved the request parameters
        this.setRequestParameters(xmlDoc);
        this.getParser().parse.call(this, xmlDoc);
        
        this.isLoading = false;
        this.isLoaded = true;

        // run the callback 
        $(this).trigger('dr-load.datasource', [xmlDoc]);
        if (callback && typeof callback === "function") {
            callback.call(this, xmlDoc);
        }
    },

    update : function(obj, callback, errorCallback) {
        if ($.isFunction(obj)) {
            if (callback && $.isFunction(callback)) {
                errorCallback = callback;
            }
            callback = obj;
            obj = null;
        }

        if (obj && typeof obj === "object") {
            this.setOptions(obj);
        }
        var oThis = this;
        var o = this.getOptions();
       
        if ($(this).triggerHandler('dr-beforeLoad.datasource', [this]) !== false) {
            // set the request parameters
            $.dr.chartDataController.setParams(this.getRequestParameters(), true);
            $.dr.chartDataController.setOption('dataType', this.getOption('dataType'));
    
            this.isLoading = true;
            this.isLoaded = false;   
         
            if (typeof this.xhrRequest !== 'undefined' && this.xhrRequest !== null) {
                if ($.isFunction(this.xhrRequest.abort)) {
                    this.xhrRequest.abort();
                    this.xhrRequest = null;
                    this.isLoading = false;
                }
            }

            // set the caching option in the data controller 
            if (o.cache !== false) {
                $.dr.chartDataController.setOption('cache', true);
            } else {
                $.dr.chartDataController.setOption('cache', false);
            }
            $.dr.chartDataController.setOption('dataType', this.getOption('dataType'));
            this.xhrRequest = $.dr.chartDataController.getData(
                o.url, 
                function(xml) {
                    oThis.xhrRequest = null;
                    oThis.updateSuccessCallback.call(oThis, xml, callback);
                }, 
                function(xhr, status, error) { //this will be errorCallback inside getData
                    oThis.xhrRequest = null;
                    $(oThis).trigger("dr-loadingError.datasource", [xhr, status, error]);
                    if (errorCallback && typeof errorCallback === 'function') {
                        errorCallback.call(oThis, xhr, status, error);
                    }
                    oThis.xhrRequest = null;
                }
            );
        }
    },

    updateSuccessCallback : function(xmlDoc, callback) {
        var oThis = this;
        this.xhrRequest = null;
        // update will replace this.data, leaving the column model the same.
        // this.removePivot();
        this.data = [];

        // saved the request parameters
        this.setRequestParameters(xmlDoc);
        this.getParser().parse.call(this, xmlDoc);
        
        this.isLoading = false;
        this.isLoaded = true;

        // run the callback 
        $(this).trigger('dr-update.datasource', [xmlDoc]);
        if (callback && typeof callback === "function") {
            callback.call(oThis, xmlDoc);
        }
    },

    /**
     * Takes the parameters from the data document meta-data and stores them.
     * Used to persist settings and set paging, sorting, etc.
     * 
     * @param {Object} xmlDoc
     */
    setRequestParameters : function(unparsedData) {
        var oThis = this;
        switch (this.getOption('dataType')) {
            case 'json':
                // TODO change this to use parameter mapping
               try {
                   $.each(unparsedData.head.params, function(param) {
                       oThis.requestParameters[param] = unparsedData.head.params[param];
                   });
                   
                   if(unparsedData.totalItems != null){
				   	oThis.requestParameters['totalItems'] = unparsedData.totalItems;
				   }else if(typeof unparsedData.data.totalItems !== 'undefined'){
				   	oThis.requestParameters['totalItems'] = unparsedData.data.totalItems;
				   }
				   
               } catch(e) {
                   // ignore errors for object does not exist.
               }
            break;
            case 'xml'  : 
                // fall through.. xml is the default
            default: 
                $('param', unparsedData).each(function() {
                    var id = $(this).attr('id'); // the id of the parameter
                    var v = $(this).attr('value');  // the value of the parameter
        
                    if (id) {
                        oThis.requestParameters[id] = v || '';
                    }
                });
                // look in one of two places for a row count.
                var $data = $('data', unparsedData);
                var count;
                if (count = $data.attr('rows')) {
                    this.requestParameters['totalItems'] = count;
                } else if (count = $data.find('row').eq(0).find('row_count')) {
                    this.requestParameters['totalItems'] = count;
                }
            break;         
        }
    },
    
    getRequestParameters : function() {
        return this.requestParameters;
    },
    
    getRequestParameter : function(key) {
        return this.requestParameters[key];
    },

    setRequestParameter : function(k,v) {
        this.requestParameters[k] = v;            
    },

    // convenience wrapper
    setParam : function(k,v) {
        this.setRequestParameter(k,v);    
    },
    
    // @deprecated
    getElement : function() {
        return $(this);
    },
    /**
     * Get the isLoaded property
     * @return {Boolean} Has this data store successfully loaded data.
     */
    getIsLoaded : function() {
        return this.isLoaded;
    },
    /**
     * Sets the isLoaded property
     * @param {Object} bLoaded A boolean flag to check if data has been loaded.
     */
    setIsLoaded : function(bLoaded) {
        this.isLoaded = !! bLoaded; // cast the argument as a boolean
    },
    /**
     * Get the isLoading property
     * @return {Boolean} Should be true if the DataSource is loading data from a remote source.
     */
    getIsLoading : function() {
        return this.isLoading;
    },
    /**
     * Set the isLoading property
     * @param {Object} bLoading 
     */
    setIsLoading : function(bLoading) {
        this.isLoading = !! bLoading;
    },

    defaultExportOptions: {
        zeroFill: true  
    },
    
    /**
     * restores the data sort order based on the rindex property of each row
     */ 
    sortOnIndex : function() {
        this.data.sort(function(a, b){
            return a.rindex > b.rindex ? 1 : a.rindex < b.rindex ? -1 : 0;
        });
    },
    /**
     * Sort the data on the specified column. 
     * 
     * @param {DataColumn} col The column to use for sorting
     * @param {Boolean} desc true to sort DESC. false or null for ASC
     */
    sortData : function(col, desc) {
        if (col instanceof $.dr.DataColumn) {
            this.data.sort($.dr.DataSorter.getSorter(col, desc));
        }
        $(this).trigger('dr-dataSort.datasource', [this, col, desc]);
    },
    /**
     * Future features
     */
    _getIsPivoted : function() {
        // future feature
    },

    removePivot : function() {
        // future feature
    },
    
    exportCSV : function() {
        var csv = {};
        var cm = this.getColumnModel();
        for (var i = 0, len = cm.getLength(); i < len; i += 1 ) {
            var col = this.getColumn(this.cm[i], this.getOption('exportFn'));
            csv[this.cm[i].cid] = col.join(",");
        }
        return csv;
    }
};

/**
 * A Class to define columns. Implemented by DataColumnModel
 * @param {Object} obj An object to define the column. A cid should be 
 *     provided, although the constructor will supply reasonable values 
 *     for missing parameters.
 */
$.dr.DataColumn = (function() {
    var i = 0;
    return function(obj) {
        this.cid = obj.cid || 'column-' + (i++);
        this.displayName = obj.displayName || 'Column ' + i;
        this.cindex = obj.cindex;
        this.dataType = obj.dataType || 'text'
        this.display = obj.display || false;  
        this.renderer = obj.renderer || undefined;     
    }
}());

$.dr.DataColumn.prototype =  {
    /**
     * Override the Function prototype. 
     * @return the displayName property of the object.
     */
    toString : function() {
        return this.displayName;
    },
    /**
     * Get the displayName property of the object.
     */
    getDisplayName : function() {
        return this.displayName;
    },
    setDisplayName: function(v) {
        this.displayName = v;
    },
    /**
     * Set a custom function to render the value of this column. Used 
     * by visualization libraries; call signature will vary based on
     * the implementing visualization library.
     * @param {Object} fn
     */
    setRenderer : function(fn) {
        if ($.isFunction(fn)) {
            this.renderer = fn;
        }
    }
};

/**
 * A Class to define rows of data. Implemented by DataSource
 * @param {Object} data The data of this row.
 * @param {Boolean} display [optional - default true] Does the row display
 * @param {Integer} rindex [optional] The index of the row. 
 */
$.dr.DataRow = function(data, display, rindex, selectable) {
    this.data = data;
    this.display = (display !== false) ? true : false;  
    this.rindex = rindex; 
    this._selectable = (selectable !== false) ? true : false;
};

$.dr.DataRow.prototype = {
    /** 
     * Get the data object for this row
     * @return {Object}
     */
    getData: function() {
        return this.data;
    },
    /**
     * Get the value of a column in this row. 
     * @param {Object} colid The column id (cid property)
     */
    getValue: function(colid) {
        return this.data[colid] || undefined;
    },
    /**
     * gets the display property of the DataRow
     * @return {Boolean}
     */
    getDisplay: function() {
        return this.display;
    },
    /**
     * Get the rindex property of this row.
     */
    getIndex : function() {
        return this.rindex;
    },
    /**
     * Set the rindex property of the row
     * @param {Integer} i The index
     */
    setIndex : function(i) {
        this.rindex = i;
    },
    /**
     * Set the display property of the row to false
     */
    hide: function() {
        this.display = false;
    },
    /**
     * Set the display property of the row to true
     */
    show: function() {
        this.display = true;
    },
    /**
     * Override the built in method from the prototype to provide the 
     * values of the data object as a comma delimited string.
     */
    valueOf : function() {
        var temp = [];
        for (var i in this.data) {
            temp.push(this.data[i]);
        }
        return temp.join(",");
    },
    /**
     * Override the built in method from the prototype to provide the 
     * values of the data object as a comma delimited string.
     */
    toString : function() {
        var temp = [];
        for (var i in this.data) {
            temp.push(this.data[i]);
        }
        return temp.join(",");        
    },
	selectable: function() {
		return this._selectable;
	}
};
/**
 * A class to defined a collection of DataColumn Objects.
 * 
 * @param {Object} ar An array of JavaScript Objects or DataColumn objects
 *     to define the columns in a DataSource.
 */
$.dr.DataColumnModel = function(ar) {
    this.columns = [];
    for (var i in ar) {
        if (ar.hasOwnProperty(i)) {
            this.columns.push(new $.dr.DataColumn(ar[i]));
        }
    }
};

$.dr.DataColumnModel.prototype = {
    /**
     * Add a column to the model; if index is null column is appended
     *    to the column collection.
     * @param {DataColumn || Object} def A DataColumn object or an Object to 
     *     define a column that will be passed to the DataColumn constructor
     * @param {Integer} index
     * @return {Integer} returns the index of the column inserted 
     */
    addColumn : function(def, index) {
        index = index || this.getLength();
        var col = (def instanceof $.dr.DataColumn) ? def : new $.dr.DataColumn(def);
        this.get().splice(index, 0, col);
        this._reindexCm();
        return index;
    },
    /**
     * Remove a column from the collection.
     * @param {Object} index
     * @return {DataColumn} returns the column removed.
     */
    removeColumn : function(index) {
        var col;
        if (this._isIndexInBounds(index)) {
            col = this.get().splice(index, 1);
            this._reindexCm();
        }
        return col;  
    },
    /**
     * Moves a column fromIndex to toIndex. If both fromIndex and toIndex
     * are in bounds, the DataColumnModel will be re-indexed. 
     * 
     * @param {Integer} fromIndex
     * @param {Integer} toIndex
     */
    moveColumn :  function(fromIndex, toIndex) {
        var cm = this.get();
        if (this._isIndexInBounds(fromIndex) &&  this._isIndexInBounds(toIndex)) {
            // remove at fromIndex the column inserting a place holder to keep the indexing correct.
            var col1 = cm.splice(fromIndex, 1, {cid: 'temp col'});

            // put the removed column in at toIndex, keeping the removed item
            var col2 = cm.splice(toIndex, 1, col1[0]);
            
            // put the second col in at fromIndex
            cm.splice(fromIndex, 1, col2[0]);
        }
        this._reindexCm();  
    },
    
    _isIndexInBounds : function(index) {
        if (index != null && (index >= 0 && index < this.getLength())) {
            return true;
        } else {
            return false;
        }
    },
    /** 
     * Called without an index will return the collection of columns.
     * Called with an index in bounds, returns the DataColumn at that index. 
     * @param {Object} index
     * @return {Array of DataColumn Objects || DataColumn} Returns undefined if
     *     index is included but is out of bounds.
     */
    get: function(index) {
        if (typeof index === 'undefined') {
            return this.columns;
        } else {
            if (this._isIndexInBounds(index)) {
                return this.columns[index];
            }
        }
        return;
    },
    /**
     * returns the number of columns in the collection
     * @return {Integer} the length of the collection.
     */
    getLength: function() {
        return this.columns.length;
    },
    /**
     * Returns the index of the first column with a cid property that matches columnName;
     * @param {Object} columnName
     * @returns {Integer} The index of the column. Returns -1 if columnName 
     *    does not match the cid property of any object in the collection.
     */
    getColumnIndex : function(columnName) {
        var cm = this.columns;
        for (var i=0, l=this.columns.length; i<l; i++) {
            var c = cm[i];
            if (c.cid === columnName) {
                return i;
            }
        }
        return -1;
    },
    /**
     * Returns the cid of the first column of dataType = 'date' in the collection. 
     * Returns the cid of the first column if there are not columns with dataType = 'date'
     * in the collection.
     */
    getSeries : function(){
        var series, col, cindex,
            cm = this;

        for (var cindex = 0; cindex < cm.getLength(); cindex += 1) {
            col = cm.get(cindex);
            if (col.dataType === 'date') {
                series = col.cid;
                break;
            }
        }
        if (! series && cm.getLength() > 0) {
            series = cm.get(0).cid;
        }
        return series;
    },
    // return the first visible column.
    getDefaultSortColumn : function() {
        var cm = this, col;
        for (var i = 0, l = this.getLength(); i < l; i++) {
            col = cm.get(i);
            if (col.display) {
                return col;
            }
        }
    },
    _reindexCm : function() {
        // resets the cindex property of each column
        var cm = this.get();
        for (var i = this.getLength() - 1; i >= 0; i--) {
            cm[i].cindex = i;
        }
    },
    /**
     * Returns the displayNames in a comma-delimited string
     * @returns {String}
     */
    toString : function() {
        var sb = [];
        for (var i  = 0, l = this.getLength(); i < l; i++) {
            sb.push(this.get(i).toString());
        }
        return sb.join();
    }
};

/**
 * A class to provide an interface for functions to parse data
 * documents in a DataSource.
 * @param {Object} fn
 */
$.dr.DataParser = Class.create({
    init: function(fn) {
        if ($.isFunction(fn)) {
            this.parse = fn;
        }
    },

    parse: function(data) {
        // over ride this method in implementations
    }
});

// alias for the charting module
$.dr.ChartDataSource = $.dr.DataSource;
$.dr.chartDataSource = $.dr.DataSource;

})(jQuery);
/**
 * copyright 2012 Digital River, Inc. All rights reserved.
 *
 * A singleton object for retrieving and caching data files in a special
 * format from a server.
 * 
 * @param {Object} $ jQuery
 */
;(function($) {

$.dr.dataController = function() {
    // privileged variables and methods
    var cache = {};
    var dataUrl;
    var params = {};
    var defaults = {
        cache : true,
        dataType : 'xml'
    };
    var options = $.extend(true, {}, defaults);

    // public methods 
    return {
        /**
         * @param {Object} key
         * @param {Object} dataSource [optional] the url of the datafile
         * @param {Object} callback [optional] a function to run after the data is loaded
         * @param {Object} errorCallback [optional] a function to run if the load failed
         */
        getData : function (dataSource, callback, errorCallback) {
            if (typeof dataSource === 'function') {
                errorCallback = (typeof callback === "function") ? callback : undefined;
                callback = dataSource;
                dataSource = null;
            }

            if (! dataSource) {
                dataSource = this.getDataUrl();
            }

            // if it is still not set ...
            if (! dataSource) {
                if (typeof errorCallback === "function") {
                    setTimeout(function() {
                        errorCallback.call(this, null, "dataSource is not set.");
                    }, 0);
                }
                return false;
            }

            var key = [dataSource, $.param(this.getParams())].join('?');

            if (cache[key] && this.getOption('cache') !== false) {
                if (typeof callback === 'function'){
                    callback.call(this, cache[key]);
                }
            } else {
                var oThis = this;
                var xhr = $.ajax({
                    url: dataSource,
                    cache: false,
                    data: this.getParams(),
                    dataType : this.getOptions()['dataType'],
                    success: function(resp) {
                        // check to see if caching is turned on
                        if (oThis.getOption('cache')) {
                            cache[key] = resp;
                        }
                        if (typeof callback === 'function') {
                            callback.call(oThis, resp);
                        }
                    },
                    error : function(xhr, status, error) {
                        if (errorCallback && typeof errorCallback === 'function') {
                            errorCallback.call(oThis, xhr, status, error);
                        }
                    }
                });
                return xhr;
            }
        },
        /**
         * Sets the url for retrieving requests. Only needs to be set once, unless the URL changes.
         * @param {Object} url
         */
        setDataUrl : function(url) {
            dataUrl = url;
        },
        /**
         * Retrieves the current URL 
         * @returns {String} the url
         */
        getDataUrl : function() {
            return dataUrl;
        },
        /**
         * Set the parameters for the request.
         * @param {Object} obj An object containing parameter values
         * @param {Boolean} replace Replace (true) or append (false) the current
         *                  parameter values with the values in obj
         */
        setParams: function(obj, replace) {
            if (typeof obj === "object") {
                if (replace) {
                    params = {};
                }
                var t, i;
                for (i in obj) {
                    var param = obj[i];
                    if (param.name && param.value) {
                        // assume jQuery serializeArray
                        switch (typeof params[param.name]) {
                            case "array": // fall through
                            case "object":
                                params[param.name].push(param.value);
                                break;
                            case "string":
                                t = params[param.name];
                                params[param.name] = [t, param.value];
                                break;
                            case "undefined":
                                params[param.name] = param.value;
                                break;
                            default:
                                break;
                        }
                    } else {
                        switch (typeof params[i]) {
                            case "array": // fall through
                            case "object":
                                params[i].push(obj[i]);
                                break;
                            case "string":
                                t = params[i];
                                params[i] = [t, obj[i]];
                                break;
                            case "undefined":
                                params[i] = obj[i];
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
        },
        /**
         * Retrieve the current parameters.
         */
        getParams : function() {
            return params;
        },
        /**
         * Clear the cached values.
         */
        clearCache : function() {
            cache = {};
        },
        /**
         * Retrieve the options settings 
         */
        getOptions : function() {
            return options;
        },
        /**
         * Set an Option
         * @param {String} key
         * @param {String|Number|Array|Object|Function} value
         */
        setOption : function(key, value) {
            options[key] = value;
        },
        /**
         * Retieves a specific setting
         * @param {String} key
         */
        getOption : function(key) {
            return options[key];
        },
        /**
         * Set all of the options in one call using an object
         * @param {Object} opt The options.
         * @param {Object} replace Replace (true) or extend(false) the current Options.
         */
        setOptions : function(opt, replace) {
            if (typeof opt === 'object') {
                if (replace) {
                    options = opt;
                } else {
                   options = $.extend(true, {}, defaults, opt);
                }
            }
            // if the user set the option cache to false, clear the cache now
            if (options.cache === false) {
                this.clearCache();
            }
        }
    };
}();

/** 
 * Support for legacy naming
 */
$.dr.chartDataController = $.dr.dataController;

})(jQuery);


/******************************************************************************
* All properties and utility methods could be defined as "Date." but this
was intentionally ommitted to reduce file size. They are automatically scoped
because of the Date object being the prototype for the dr.date
******************************************************************************/
(function($) {
	
	/******************************************************************************
	* Default to the ISO 8601 format of yyyy-mm-dd. Do not try to set directly.
	* Use $.dr.date.setDefaultFormat(fmt); This will make sure that everything is in sync.
	******************************************************************************/
	var DEFAULT_DATE_FORMAT = "yyyy-mm-dd",
	DATE_FORMAT_PATTERN,
	PARSED_DATE_SEGMENTS,
	DAY_POS,
	MONTH_POS,
	YEAR_POS,
	REG_EX_PAT;

    /*
     * Localized Messages
     */
    var messages = {
        DATE: "The value for {LABEL} is not a valid date format. Valid format is {FORMAT}.",
        TIME: "The value for {LABEL} is not a valid time. Valid format is {EXAMPLE}.",
        YEAR: "The value for {LABEL} is not a valid year. Valid format is {EXAMPLE}."
    }
	
	
	//Private Class/Utility methods
	
	/******************************************************************************
	* This is an internal utility method that returns an index position for the passed
	* in segment str. This position is used to help parsed out the coresponding value of
	* dateStr for the date object that is being constructed.<br />
	* Example: <code>var monthPos = findSegPos("m", ["mm", "/", "dd", "/", "yyyy"]);</code>
	* @author bziegler
	* @param {segStr} string to be found in the passed in segment array
	* @param {parsedFmtSegments} Array of containing segments of the parsed date 
	*         format. ["mm", "/", "dd", "/", "yyyy"]
	* @return {Number} array index number for the matched segment. If segement is 
	*         not found -1 is returned.
	*****************************************************************************/
	var findSegPos = function(segStr, parsedFmtSegments) {
		for(var i = 0; i < parsedFmtSegments.length; i++) {
			if (parsedFmtSegments[i].indexOf(segStr) != -1) {
				return i;
			} 
		}
		return -1;
	}
	
	/******************************************************************************
	* This is an internal utility method that splits the passed in date format into
	* an array. Each segment is determined by the following character not matching
	* the previous character. Possible date segments "mdy./- ". Month and day patterns
	* can be 1 - 2 characters, year pattern can be 2 or 4 characters.<br />
	* Example: <code>var parsedDateSegments = parseDateFmt("mm.dd.yyyy");</code>
	* @author bziegler
	* @param {fmt} string representing the date format "mm.dd.yyyy"
	* @return {Array} array of each date format segment including separators. Null 
	*         is returned if not date segments are found. 
	*****************************************************************************/
	var parseDateFmt = function(fmt) {
		var regEx = /(([y]{2,4}|[m]{1,2}|[d]{1,2})|([-\/ .]+?))/gi
		return fmt.toLowerCase().match(regEx);
	}
	
	/******************************************************************************
	* This is an internal utility method that dynamically constructs a regular 
	* expression that will be used to validate a date to the supplied format.<br />
	* Example: <code>var dateRegEx = buildRegEx(["mm", ".", "dd", ".", "yyyy"]);</code>
	* @author bziegler
	* @param {parsedPattern} Array of date segments ["mm", ".", "dd", ".", "yyyy"]
	* @return {String} regular expression pattern based on supplied dateFmt argument. 
	*****************************************************************************/
	var buildRegEx = function(parsedPattern) {
		//add null check
		var regExPat = "^";
		for(var i = 0; i < parsedPattern.length; i++) {
			if(/[mdy]/i.test(parsedPattern[i])) {
				// found day, month or year
				
				if(typeof parsedPattern[i]!='undefined'){
					var segMin = parsedPattern[i].length;
					var segMax = segMin;
					if (segMin == 1) {
						segMax = 2;
					} 
					regExPat += "(\\d{" + segMin + "," + segMax + "})";
				}
			} else {
				// found separator
				regExPat += "([\\" + parsedPattern[i] + "]{1})";
			} 
		}
		//End end of input characters to prevent extract numbers or characters from seeming valid
		return (regExPat + "$");	
	}
	
	var parseFormat = function(format) {
		//Set to defaults if format was not passed in. 
		var parsedFmtSegments = (format) ? parseDateFmt(format) : PARSED_DATE_SEGMENTS;
		var datePos = (format) ? findSegPos("d", parsedFmtSegments) : DAY_POS;
		var monthPos = (format) ? findSegPos("m", parsedFmtSegments) : MONTH_POS;
		var yearPos = (format) ? findSegPos("y", parsedFmtSegments) : YEAR_POS;
		var regExPat = (format) ? buildRegEx(parsedFmtSegments) : REG_EX_PAT;
		var formatObj = {
			format: format,
			yearPos: yearPos,
			monthPos: monthPos,
			datePos: datePos,
			regExPat: regExPat,
			segments: parsedFmtSegments
		};
		
		return formatObj;
	}
	/******************************************************************************
	* This method parses a date str based on the optional format when the date is
	* constructed. This will map the formatted day, month, year to the standard
	* javascript format and construct a date object. This is called internally.<br />
	* Example: <code>var dateRegEx = dateObj.parseDate("dd/mm/yyyy", "25/03/2008");</code>
	* @author bziegler
	* @param {fmt} String representing the date format "dd/mm/yyyy"
	* @param {dateStr} String representing the date "25/03/2008"
	* @return {Date} valid date object or null if invalid. 
	*****************************************************************************/
	var parseDate = function(dateStr, format) {
		var formatObj = parseFormat(format);
		var dateSegments = new RegExp(formatObj.regExPat).exec(dateStr);
		var dateObj = {};
		var isValid = false;
		var date, month, year;
		if (dateSegments) {
			dateSegments = dateSegments.slice(1);
			date = dateSegments[formatObj.datePos] ;
			//subtract 1 to make month zero based to match date object
			month = Number(dateSegments[formatObj.monthPos])-1;
			year = dateSegments[formatObj.yearPos];
			dateObj = new Date(((year.length == 2) ? ((year < 70)? Number("20" + year): Number("19" + year)) : year), month, date);
			var doDay = dateObj.getDate();
			var doMonth = dateObj.getMonth();
		
			var doYear = (year.length == 2) ? String(dateObj.getFullYear()).slice(2) : dateObj.getFullYear();
			//verify that day, month, year are in range, (ie don't roll to the next one);
			if (doDay == date && doMonth == month && doYear == year) { isValid	= true; }
		} 
		return (isValid) ? dateObj : null;
	}


	/******************************************************************************
	* Creates a date object based on the format passed in or the default format
	* on extended on the date object. The default date format is the ISO 8601,
	* which is formatted as yyyy-mm-dd<br />
	* Example: <code>var dateObj = new $.dr.date('25-03-2008', 'dd-mm-yyyy');</code>
	* @author bziegler
	* @param {dateStr} string of the date to be parsed
	* @param {fmt} Optional argument to set a format for this instance. If it is 
	*              not specified the extended default date format will be used.
	* @return standard javascript date object. If an invalid date is passed in an
	* invalid date object will be returned. The returned value varies between 
	* browsers which matches the behavior of the javascript date object. An 
	* isValid method (dateObj.isValid()) has been added to simplify date validation.
	*****************************************************************************/
	$.dr.date = function(dateStr, fmt) {
		//check against class fmt to see if it is different
		//Set to class defaults if fmt was not passed in. 
		var format = (fmt == null || fmt == "" || fmt == 'undefined') ? DATE_FORMAT_PATTERN : fmt;
		var date = null;
		if(dateStr instanceof Date){
			if(dateStr.isValid()){
				date = dateStr;
			}
		}else{
			date = parseDate(dateStr, format);
		}
		
		if (date == null) {
			// if the date is null, then it means that the dateStr passed in is not valid for the format
			return (new Date("invalid date"));
		} else {
			date.format = format;
			return date;
		}
	}
	
	$.dr.date.prototype = new Date();
	
	/******************************************************************************
	* This helper method that normalizes the differences between browsers to simplfy
	* testing for an invalid date. Each browser returns and invalid date differently. 
	* False is returned if the date instance is not valid.<br />
	* Example: <code>if(dateObj.isValid()) { do something }</code>
	* @author bziegler
	* @return {Boolean} return false if the dateObj instance is not a valid date. 
	*****************************************************************************/
	Date.prototype.isValid = function() {
		var dateObj = this;
		//just return the test
		return !(dateObj === null || dateObj === undefined 
				|| (typeof dateObj == "object" && dateObj == "Invalid Date") 
				|| (typeof dateObj == "object" && dateObj == "NaN"));
	}
	
	Date.prototype.getFormat = function(){
		return this.format;
	}
	//outputFmt is optional
	Date.prototype.toFormattedString = function(outputFmt) {
		var year = this.getFullYear();
		var day = this.getDate();
		var month = this.getMonth()+1;
		//use output format, if null, use this.format, if null use default
		var format = (outputFmt) ? outputFmt : ((this.format) ? this.format : DEFAULT_DATE_FORMAT);
		var segments = parseFormat(format).segments;
		var formattedDate = "";
		for (var i=0; i < segments.length; i++) {
			var s = segments[i];
			var d = s;
			switch(s.toLowerCase().charAt(0)){
				case "m":
						if(s.length==2){
							month = (month < 10) ? "0" + month : month;
						}
						d=month;
					break;
				case "d":
						if(s.length==2){
							day = (day < 10) ? "0" + day : day;
						}
						d = day;
					break;
				case "y":
						if(s.length==2 ){
							//coerce the year into a string to get the substring function to work
							year = (year+"").substring(2);
						}
						d=year;
					break;
			}
			formattedDate += d;
		}
		
		return formattedDate;
	}
	
	/******************************************************************************
	* This utility method is used to set the default format for the date class. 
	* this format will be used if one is not passed into dr.date constructor. The
	* default format is the ISO 8601 format of yyyy-mm-dd. This function ensures
	* that all properties are generated and in sync.  <br />
	* Example: <code>$.dr.date_setDefaultFormat("dd/mm/yyyy");</code>
	* @author bziegler
	* @param {fmt} String representing the date format "dd/mm/yyyy"
	*****************************************************************************/
	$.dr.date.setDefaultFormat = function(fmt) {
		DATE_FORMAT_PATTERN = fmt;
		PARSED_DATE_SEGMENTS = parseDateFmt(fmt);
		MONTH_POS = findSegPos("m", PARSED_DATE_SEGMENTS);
		YEAR_POS = findSegPos("y", PARSED_DATE_SEGMENTS);
		Day_POS = findSegPos("d", PARSED_DATE_SEGMENTS);
		REG_EX_PAT = buildRegEx(PARSED_DATE_SEGMENTS);
	};
	
	$.dr.date.setDefaultFormat(DEFAULT_DATE_FORMAT);
	
	$.dr.date.getDefaultFormat = function() {
		return DATE_FORMAT_PATTERN;
	};
	
	$.dr.date.getDateFromTime = function(time){
		var arr = time.split(":");
		var hh = Number(arr[0]);
		var arr2 = arr[1].split(" ");
		var mm = arr2[0];
		if(arr2.length==2){
			var ampm = arr2[1].toLowerCase();
			if(ampm=='pm' && hh!=12){
				hh = hh + 12;
			}else if (hh==12 && ampm=='am'){
				hh = hh - 12;
			} 
		}
		var date = new Date();
		var r = new Date(date.getFullYear(),date.getMonth(),date.getDate(),hh,mm);
		return r;
	};
    /**
     * Returns a date object from a Year, Month, Day arguments
     * @author Christopher Pryce <cpryce@digitalriver.com>
     * 
     * @param {String|Number} year The Year
     * @param {String|Number} month The month
     * @param {String|Number} day The day
     * @returns {$.dr.date} A new date object
     */
    $.dr.date.getISODate = function(year, month, day) {        
        // == null tests for both null and undefined.
        year   = parseInt(year, 10);
        month  = parseInt(month, 10);
        day    = parseInt(day, 10);

        if (arguments.length === 0 || isNaN(year)) {
            return new $.dr.date(new Date().toFormattedString('yyyy-mm-dd'), 'yyyy-mm-dd');
        }
        
        if (isNaN(month)) {
            month = 1;
        }
        if (isNaN(day)) {
            day = 1;
        }

        if (year.length < 100) {
            year = (year < 70) ? year + 2000 : year + 1900;
        }
        
        // zero pad and convert to strings 
        day = (day < 10) ? "0" + day : day.toString();
        month = (month < 10) ? "0" + month : month.toString();
        
        return new $.dr.date([year.toString(), month, day].join("-"), 'yyyy-mm-dd');
    };
	
	/******************************************************************************
	* Calculates if a given year is a leap year
	* @param {String} year 4-digit year (yyyy) to test
	* @return true or false
	* @private
	*****************************************************************************/
	$.dr.date.isLeapYear = function(year) {
		// convert to integer
		year = parseInt(year,10);
		
		if ( ( (year%4 === 0)&&(year%100 !== 0) ) || (year%400 === 0) ) {
			return true;
		} else {
			return false;
		}
	};
	
	var addDateValidators = function(){
		// Add Date/Time/Year validators to the form dataType validators, if it exists
		if(typeof $.dr.form.addDataTypeValidator == 'function'){
			$.dr.form.addDataTypeValidator( 
			{
				/******************************************************************************
				 * Validates if the string is a valid date. The format argument allows for validating other locales.<br />
				 * Example: <code>$.dr_isValid('date',val,format)</code><br />
				 * @return {Boolean} True or false depending on whether the string is a valid date
				 *****************************************************************************/
				date: [messages.DATE, "", function( val, format ){
						if(val===null || val===undefined){return false;}
						
						var date = new $.dr.date(val,format);
						//log(date.getDay)
						return date.isValid();
					}
				],
				
				/******************************************************************************
				 * Validates if the string is a valid 12-hr time. The format argument allows for 24 hour.<br />
				 * Example: <code>$.dr_isValid('time12hr',val)</code><br />
				 * @return {Boolean} True or false depending on whether the string is a valid time12hr
				 *****************************************************************************/
				time12hr: [messages.TIME, "hh:mm", function( val ){
						var re = new RegExp("^([1-9]|[0][1-9]|[1][0,1,2])(:([0-5][0-9])){1,2}?( ([aApP][mM])?)?$");
						return re.test(val)
					}
				],
				
				/******************************************************************************
				 * Validates if the string is a valid 24-hr time. The format argument allows for 24 hour.<br />
				 * Example: <code>$.dr_isValid('time24hr',val)</code><br />
				 * @return {Boolean} True or false depending on whether the string is a valid time
				 *****************************************************************************/
				time24hr: [messages.TIME, "HH:MM", function( val ){
						return  /^(24:00)|(([0-1][0-9]|2[0-3])[:]([0-5][0-9]))$/.test(val)
					}
				],
				
				/******************************************************************************
				 * Validates if the string is a valid year. The format argument allows for validating other locales.<br />
				 * Example: <code>$.dr_isValid('year',val,format)</code><br />
				 * @return {Boolean} True or false depending on whether the string is a valid year
				 *****************************************************************************/
				year: [messages.YEAR, "yyyy", function(val, format ){
						if(val===null || val===undefined){return false;}
						if ( !format ) {format = 'yyyy';}
						if(format.toLowerCase()=='yy' && val.length==2 && !isNaN(val)){
							//valid two digit year
							return true;
						}else if(format.toLowerCase()=='yyyy' && val.length==4 && !isNaN(val)){
							//valid four digit year
							return true;
						}
						return false;
					}
				]
			});
		}
	};
	
	
	/*
	 * Add the addDateValidators function to the domReady event
	 */
	$(document).bind('dr-beforeinitforms',addDateValidators);
	
})(jQuery);
;(function($){
    $.dr.utils.evalString = function(str, errorMsg){
        var o;
        if(!str)return;
        if(str.trim().length==0)return;
        try{
            eval('o='+str);
        }catch(e){
            if(errorMsg){
                $.dr.utils.logError(errorMsg,e);
            }
            o = 'error';
        }
        return o;
    };
})(jQuery);
;(function($){
    //Credit to Tim Banks and Ryan Wheale
    //http://devblog.foliotek.com/2009/12/07/getting-the-width-of-a-hidden-element-with-jquery-using-width/         
    $.namespace("dr.utils",{
        getHiddenDimensions: function(includeMargin) {
            var $item = this,
            props = { position: 'absolute', visibility: 'hidden', display: 'block' },
            dim = { width:0, height:0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 },
            $hiddenParents = $item.parents().andSelf().not(':visible'),
            includeMargin = (includeMargin == null)? false : includeMargin;
            if (typeof this == "undefined" || this.length == 0) {
                return dim;
            }
            var oldProps = [];
            $hiddenParents.each(function() {
                var old = {};
                for ( var name in props ) {
                    old[ name ] = this.style[ name ];
                    this.style[ name ] = props[ name ];
                }
                oldProps.push(old);
            });
            dim.width = $item.width();
            dim.outerWidth = $item.outerWidth(includeMargin);
            dim.innerWidth = $item.innerWidth();
            dim.height = $item.height();
            dim.innerHeight = $item.innerHeight();
            dim.outerHeight = $item.outerHeight(includeMargin);
            dim.left = $item.offset().left;
            dim.top = $item.offset().top;
            $hiddenParents.each(function(i) {
                var old = oldProps[i];
                for ( var name in props ) {
                    this.style[ name ] = old[ name ];
                }
            });
            return dim;
        }
    });
})(jQuery);
;(function($){
	$.dr.getScript = function(scriptUrl, callback, useCache){
		if (useCache !== false) {
			useCache = true;
		}
		return $.ajax({
			url: scriptUrl,
			dataType: 'script',
			global: false,
			cache: useCache,
			success: function(data, textStatus){
				// Put a delay in here, to make sure the script has been fully parsed and executed, before the callback runs
				if($.isFunction(callback)){
					setTimeout(function(){
						callback(data, textStatus);
					}, 0);
				}
			}
		});
	};
})(jQuery);
;(function($){
    $.dr.utils.isPeriodCountry = function(locale) {
        var arr = locale.split("_");
        if (arr.length != 2) {
            arr = ['en', 'US'];
        }
        var language = arr[0].toLowerCase();
		var country = arr[1].toUpperCase();
        var isDecimalCountry = (language == 'en');
        if (!isDecimalCountry) {
            for (var i = 0; i < $.dr.periodCountries.length; i++) {
                if ($.dr.periodCountries[i].toUpperCase() == country) {
                    isDecimalCountry = true;
                    break;
                }
            }
        }
		return isDecimalCountry;
    };
})(jQuery);
;(function($){
    /*
     * Maps a list of legacy tokens (i.e. options, messages, events) to current tokens.
     * Context may be a widget object or the map hash itself.
     */
    $.dr.utils.legacyMap = function(hash,map){
        map = map || {};
        hash = hash || {};
        for (var token in hash) {
            if (hash.hasOwnProperty(token)) {
                if (map[token] !== undefined) {
                    hash[map[token]] = hash[token];
                }
            }
        }
        return hash;
    };
})(jQuery);
;(function($){
    $.dr.utils.logError = function(errorMsg,err){
        if (window.console){
            console.error(errorMsg);
            if(err){
                console.error('Error: ', err);
            }
        }
    };
})(jQuery);
	/******************************************************************************
	 * Utility function that opens a popup window<br />
	 * Example: <code>$.dr.popup(options)</code><br />
	 * @param {Object} options contains internal properties below<br />
	 * Internal Properties
	 * {String} url Url to open in a popup window<br />
	 * {String} width Width of the popup window<br />
	 * {String} height Height of the popup window<br />
	 * {String} target Target for the popup window<br />
	 * {Boolean} centered Should the popup be automatically centered on the screen<br />
	 * {String} type Determines whether it is resizable, has scrollbars, and has a menubar.  Options are: <b>console</b> (resizable), <b>fixed</b> (status), <b>normal</b> (toolbar, scrollbars, resizable, location), and <b>full</b> (toolbar, menubar, scrollbars, resizable, location)
	 * 
	 * @return window.open
	 * 
	 *****************************************************************************/

;(function($) {
	
	var defaults = {
		url:'',
		width:740,
		height:500,
		target:'',
		centered:true,
		type:'normal'
			
	}
	
	$.dr.popup = function(options) {
		options = $.extend({},defaults,options);
		if(options.url == '' || options.url == null){
			$.dr.utils.logError("Must supply a url");
			return;
		}
		
		var s ="";
		switch (options.type){
			case "console": s="resizable,scrollbars,height="+options.height+",width="+options.width;break;
			case "fixed": s="status,scrollbars,height="+options.height+",width="+options.width;break;
			case "normal": s="toolbar,scrollbars,resizable,location,height="+options.height+",width="+options.width; break;
			case "full": s="toolbar,menubar,scrollbars,resizable,location,height="+options.height+",width="+options.width; break;
			default: if(options.type){ s=options.type; }break;
		}
		
		if(options.centered){
			if(window.screen){
		    	var l = (screen.width-parseInt(options.width,10))/2;
		    	var t = (screen.height-parseInt(options.height))/2;
		    	s+=',left='+l+',top='+t;
			}			
		}

		tg = options.target;
		
		return window.open(options.url, tg, s);
	}
	
})(jQuery);

;(function(){
	/*
	 * Credit: http://blog.stevenlevithan.com/archives/faster-than-innerhtml
	 * ReplaceHtml can insert and replace html fragments faster than innerHTML
	 * 
	 * IMPORTANT NOTE: This function removes the parent of the element so use caution if you have events bound to the parent element
	 */
    $.namespace('dr.utils', {
        replaceHtml: function(html) {
            var el = this[0];
            var oldEl = typeof el === "string" ? document.getElementById(el) : el;
            if ($.browser.msie) {
            // Pure innerHTML is slightly faster in IE
                oldEl.innerHTML = html;
                return oldEl;
            }
            var newEl = oldEl.cloneNode(false);
            newEl.innerHTML = html;
            oldEl.parentNode.replaceChild(newEl, oldEl);
            /* Since we just removed the old element from the DOM, return a reference
            to the new element, which can be used to restore variable references. */
            return newEl;        
        }
    });
})(jQuery);
;(function($){
	$.fn.setData = function(nameValueObject){
		return this.each(function(){
			for (var namedProperty in nameValueObject) {
				$(this).data(namedProperty, nameValueObject[namedProperty]);
			}
		});
	};
})(jQuery);
;(function($){
	/******************************************************************************
	 * Utility function that strips all spaces from a string<br />
	 * Example: <code>myStr.stripSpaces()</code>
	 * @return {String} String with spaces stripped out
	 *****************************************************************************/
	String.prototype.stripSpaces = function(){
		return this.replace(/ /g, '');
	};

	/******************************************************************************
	 * Utility function that strips all whitepace from a string<br />
	 * Example: <code>myStr.stripWhitepace()</code>
	 * @return {String} String with all whitespace stripped out
	 *****************************************************************************/
	String.prototype.stripWhitepace = function(){
		return this.replace(/\s/g, '');
	};
	
	/******************************************************************************
	 * Utility function that replaces multiple whitepace characters with a<br />
	 * single character. The default replacement is a space.<br />
	 * Example: <code>myStr.squeezeWhitespace()</code>
	 * @return {String} String with only single spaces remaining
	 *****************************************************************************/
	String.prototype.squeezeWhitespace = function(replacement){
		return this.replace(/\s+/g, (arguments.length === 1) ? replacement : ' ');
	};

	/******************************************************************************
	 * Utility function that strips all tabs and line breaks from a string<br />
	 * Example: <code>myStr.stripLineBreaksAndTabs()</code>
	 * @return {String} String with line breaks and tabs stripped out
	 *****************************************************************************/
	String.prototype.stripLineBreaksAndTabs = function(){
		return this.replace(/\n|\t/g, '');
	};
	
	if (!String.prototype.trim) {
	/******************************************************************************
	 * Trims leading whitespace from string<br />
	 * Example: <code>myStr.ltrim()</code><br />
	 * @return {String} Trimmed string
	 *****************************************************************************/
	  String.prototype.trimLeft = String.prototype.ltrim = function(){ // Leave existing �ltrim� method intact for backwards-compatibility
	    return this.replace(/^\s+/,'');
	  };
	  
	/******************************************************************************
	 * Trims trailing whitespace from string<br />
	 * Example: <code>myStr.rtrim()</code><br />
	 * @return {String} Trimmed string
	 *****************************************************************************/
	  String.prototype.trimRight = String.prototype.rtrim = function(){// Leave existing �rtrim� method intact for backwards-compatibility
	    return this.replace(/\s+$/,'');
	  };
	  
	/******************************************************************************
	 * Trims leading and trailing whitespace from string<br />
	 * Example: <code>myStr.trim()</code><br />
	 * @return {String} Trimmed string
	 *****************************************************************************/
	  String.prototype.trim = function(){
	    return this.trimLeft().trimRight();
	  };
	} else {
		String.prototype.ltrim = String.prototype.trimLeft;
		String.prototype.rtrim = String.prototype.trimRight;		
	}

	
	/******************************************************************************
	 * Replaces {0}...{n} with its corresponding parameter,<br />
	 * in the order they were passed in<br />
	 * Example: <code>myStr.replaceTokens('a','b')</code><br />
	 * @return {String} String
	 *****************************************************************************/
	String.prototype.replaceTokens = function(){
		var args = arguments;
		return this.replace(/\{(\d+)\}/g, function(token, index){
			return (index < args.length) ? args[index] : token;
		});
	};
	
	/******************************************************************************
	 * Replaces {0} with &lt;br /&gt;<br />
	 * Example: <code>myStr.replaceBreaks()</code><br />
	 * @return {String} String
	 *****************************************************************************/
	String.prototype.replaceBreaks = function(){
		return this.replaceTokens("<br/><br/>");
	};

	/******************************************************************************
	 * Trim Last letter of string, regardless if it is mult-byte
	 * Example: <code>myStr.trimLastLetter()</code>
	 * @return {String} String
	 *****************************************************************************/	
	String.prototype.trimLastLetter = function (){
		var charLength = this.length;
		
		var lastLetterCode = encodeURI(this.substr(charLength-1,charLength));
		var numLetters = 1;
		if ($.browser.msie && lastLetterCode=="%0A")
		{
			// IE counts a carriage return as 2 length, and FF only as 1 length
			numLetters=2;
		}
		
		return this.substr(0,charLength-numLetters);
	};
	

	/******************************************************************************
	 * Remove double quotes from a string
	 * Example: <code>myStr.stripDoubleQuotes()</code>
	 * @return {String} String
	 *****************************************************************************/	
	String.prototype.stripDoubleQuotes = function(){
		return this.replace(/"/g,'');
	};
		
 
	/******************************************************************************
	 * Validates if the string is empty, or contains only spaces<br />
	 * Example: <code>myStr.isBlank()</code>
	 * @return {Boolean} True or false depending on whether the string is empty
	 * 
	 *****************************************************************************/
	String.prototype.isBlank = function(){
		return /^\s*$/.test(this);
	};

		
	/******************************************************************************
	 * Returns a string that fits a limit of chars<br />
	 * Example: <code>myStr.makeUT8CharsFitLength()</code><br />
	 * @return {String}
	 *****************************************************************************/
	String.prototype.makeUT8CharsFitLength = function(byteCount,maxLength){
		
		if(byteCount===0 || byteCount == maxLength)
		{
			return this;
		}
			
		var limitFound = false;
		var charLength =  this.length;
		
		var byteRatio = charLength/byteCount; // byteRatio should always be lower than 1
		var startChar = Math.round(maxLength * byteRatio,0); // example: 50 * .8 = 40

		var finalChars;
		var iterator = "";
		var reversedDirection = false;
		var charPosition = startChar;
		var i = 0;
		
		//DR_Utils_Logger.log('Guessing the start point: ' + startChar);
		
		while(!limitFound && i<100)
		{
			var tempChars = this.substr(0,charPosition);
			var tempByteCount = DR.Utils.FormUtils.getUTF8Bytes(tempChars).byteCount;
			
			/*
			 * Possible conditions
			 * 
			 * A - the startChar is too low - ie, we need to iterate upward
			 * 
			 * B - the startChar is too high - ie, we need to iterate downward
			 * 
			 * C - we have it exactly right
			 * 
			 * D - there is a multipbyte char at the last position, so remove it
			 *     this will lead to there being 1 or 2 open spots
			 * 
			 */
			
			//DR_Utils_Logger.log('tempByteCount:' + tempByteCount,false);
			
			if(tempByteCount==maxLength )
			{
				limitFound=true;
				finalChars = tempChars;
				//DR_Utils_Logger.log('Exact Match Found: ' + charPosition,false);
			}
			else if(tempByteCount<maxLength && reversedDirection){
				limitFound=true;
				finalChars = tempChars;
				//DR_Utils_Logger.log('Best Match Found: ' + charPosition,false);
			}
			else
			{
				if(tempByteCount<maxLength)
				{
					if(iterator=="negative")
					{
						//there is a multipbyte char at the last position, so remove it
						reversedDirection = true;
					}
					
					charPosition++;
					
					//DR_Utils_Logger.log('Move Position Up: ' + charPosition,false);
					iterator="positive";
					
				}
				else if(tempByteCount>maxLength)
				{
					if(iterator=="positive")
					{
						//there is a multipbyte char at the last position, so remove it
						reversedDirection = true;
					}
					charPosition--;
					//DR_Utils_Logger.log('Move Position Down: ' + charPosition,false);
					iterator="negative";
				}
			} 
			
			//DR_Utils_Logger.log('iterator: ' + iterator,false);
			
		}
		
		return finalChars;

	};
	/******************************************************************************
	 * Returns a string with the first character capitalized
	 * Example: <code>myStr.capitalize()</code>
	 * @return {String}
	 *****************************************************************************/	
	String.prototype.capitalize = function() {
 		return this.charAt(0).toUpperCase() + this.slice(1);
	}

	/******************************************************************************
	 * Returns a string converted from one locale to another in the specified format.
	 * Example: <code>"20000".formatNum("en_US",2,{prefix:"", postfix:"USD"})</code>
	 * @param {String} Which locale the number you are formatting is in 
     * @param {String} Which locale you want the number formatted to
     * @param {Number or Boolean} Number of trailing decimals rounded up. This can be disabled by setting it to false
     * @param {Object} Defines the prefix and postfix currency symbols. For example, prefix would be '$', and postfix would be 'USD'
     * 
     * All arguments are optional
     * 
	 * @return {String}
	 *****************************************************************************/	
	String.prototype.formatNum = function(fromlocale, locale, precision, currencyObj){
		var defaultLocale = $.dr.USER_LOCALE, defaultPrec = 2, defaultCurr = { prefix: "", postfix: "" };	
		var isLocale = function(locale){
			return (locale && locale.length == 5 && locale.toString().substr(2, 1) == "_" && isNaN(parseInt(locale, 10)));
		}
		var isPrecision = function(precision){
			return (precision === false || !isNaN(parseInt(precision, 10)));
		}
		var isCurrObj = function(c) {
			return (typeof c == "object");
		}
		var validCurrObj = function(c) {return (c.postfix || c.prefix);}
		switch(arguments.length) {
			case 1:
				if (isPrecision(fromlocale)) {
					precision = fromlocale;
				}
				if (isCurrObj(fromlocale)) {
					currencyObj = fromlocale;
				}
				if (isLocale(fromlocale)) {
					locale = fromlocale;
					fromlocale = defaultLocale;
				}
				
			break;
			case 2:
			if (isLocale(fromlocale) && isCurrObj(locale)) {
				currencyObj = locale;
				locale = fromlocale;
				fromlocale = "";
			}
			if (isLocale(fromlocale) && isPrecision(locale)) {
				precision = locale;
				locale = fromlocale;
			}
			if (isPrecision(fromlocale) && isCurrObj(locale)) {
				currencyObj = locale;
				precision = fromlocale;
			}
			break;
			case 3:
			if (isLocale(fromlocale) && isPrecision(locale) && isCurrObj(precision)) {
				currencyObj = precision;
				precision = locale;
				locale = fromlocale;
				fromlocale = defaultLocale;				
			}
			if (isLocale(fromlocale) && isLocale(locale) && isCurrObj(precision)) {
				currencyObj = precision;
			}
			break;
		}
		fromlocale = (locale != undefined && isLocale(fromlocale)) ? fromlocale : defaultLocale;
		locale = (locale != undefined && isLocale(locale)) ? locale : defaultLocale;
		precision = (isPrecision(precision)) ? precision : defaultPrec;
		currencyObj  = (isCurrObj(currencyObj) && validCurrObj(currencyObj)) ? $.extend(defaultCurr,currencyObj) : defaultCurr;
		
		var val = (precision === false) 
			? parseFloat($.dr.utils.normalizeNumber(this,fromlocale)).toString() 
			: parseFloat($.dr.utils.normalizeNumber(this,fromlocale)).toFixed(precision);
		if (isNaN(val)) return this.toString();
		var seps = ($.dr.utils.isPeriodCountry(locale)) ? {t:",",d:"."} :{t:".",d:","};
		var nums = val.split("."); //split on . because its been normalized		

		
		var formatNum = function(thousandsSep, decSep){
			nums[0] = nums[0].replace(/\d{1,3}(?=(\d{3})+(?!\d))/g, "$&" + thousandsSep);
			return nums.join(decSep);
		}
		return ((currencyObj.prefix!="") ? currencyObj.prefix : "") 
			+ formatNum(seps.t, seps.d)
			+ ((currencyObj.postfix!="") ? '\xA0'+currencyObj.postfix : "");				
		
	}
	//This guy is a freeloader. Move him someplace else?
	Number.prototype.formatNum = function(fromlocale, locale, precision, currencyObj) {
		return this.toString().formatNum(fromlocale, locale, precision, currencyObj);
	}

})(jQuery);
;(function($) {

	// check to see if underscore object exists
	if(typeof _ === 'function' ){
		// override the default tokens	
		_.templateSettings = {
			evaluate    : /<#([\s\S]+?)#>/g,
			interpolate : /<#~([\s\S]+?)#>/g,
			escape      : /<#=([\s\S]+?)#>/g
		};
	}else{
		if (window.console && window.console.error){
			$.dr.logError('underscore.js must be included on page for templating to work');
		}
	}
	function createSelector(htmlID) {
		if ($(htmlID).length > 0) {
			return htmlID
		}
		return htmlID.toString().charAt(0) === "#" ? htmlID : "#"+htmlID;
}
	/*
	 * Store of compiled templates
	 */
	$.dr.templates = [];

	/*
	 * Wrapper around underscore templates.
	 */
	$.dr.template = {

		compile: function(id){
			if(!id){
				$("script[type='text/html']").each(function(){
					if(this.id!=='undefined'){
						// compile and cache
						$.dr.templates[this.id] = _.template($(this).html());
					}
				});
			}else{
				var $template = $(createSelector(id));
				if($template.length){
					var template = _.template( $template.html() );
					$.dr.templates[id] = template;
					return template;
				}else{
					// template does not exist
					$.dr.utils.logError("Template does not exist with ID = " + id);
					return false;
				}
			}
		},

		// returns HTML string of a template and data
		getHTML: function(id, data){
			var template = $.dr.templates[id];
			var html = "";
			if(typeof template === 'undefined'){
				template = $.dr.template.compile(id);
			}
			if(template){
				html = template(data);
			}
			return html;
		},

		// replace html for a given html ID using a template and data
		renderHTML: function(htmlID,id,data){
			var html = $.dr.template.getHTML(id,data);
			$(createSelector(htmlID)).html($.trim(html));
		}
	};

})(jQuery);
;(function($){
     /**
     * 
     * @param empty, intended to be overwritten with custom function
     * 
     * return {Boolean} returns a default value.  This is intended to be overwritten with custom function.
     */
    $.dr.userdata = {
        save: function(){},
        load: function(){}
    };
})(jQuery);
;(function($){
    // Returns the following:
    // -1, if first is less than second 
    // 0, if first is equal to second 
    // 1, if first is greater than second 
    $.dr.utils.versionCompare = function(first, second){
        first = (first && first.toString()) || '0';
        second = (second && second.toString()) || '0';
        var firstSplit = first.split('.');
        var secondSplit = second.split('.');
        var firstLength = firstSplit.length;
        var secondLength = secondSplit.length;
        var least = Math.min(firstLength, secondLength);
        var result = 0, numericFirst = 0, numericSecond = 0;
        for (var i=0;i<least;i++) {
            numericFirst = parseInt(firstSplit[i],10);
            numericSecond = parseInt(secondSplit[i],10);
            if (numericFirst < numericSecond) {
                result = -1;
                break;
            }
            else if (numericFirst > numericSecond) {
                result = 1;
                break;
            }
            else if ((i === (least-1)) && (firstLength !== secondLength)) {
                result = (firstLength === least) ? -1 : 1;
            }
        }
        return result;
    };
})(jQuery);
;(function($){
    /**
     * 
     * @param {String} name the node name
     * @param {String} value the value of the node
     * @param {Object} attr a javascript object with key/value pairs to set attributes 
     * on the node
     * 
     * return {String} the node as a String;
     */
    $.dr.utils.xmlElement = function(name, value, attr) {
        var formatAttributes = function(attributes) {
            var QUOTE = '"';
            var quot_pos;
            var att_str = '';
            var result = [];
            for (var att in attributes) {
                // Find first quote marks if any
                quot_pos = attributes[att].toString().indexOf(QUOTE);
                // Determine which quote type to use around the attribute value
                if (quot_pos === -1) {
                    att_str = ' ' + att + '="' +  attributes[att] +  '"';
                    result.push(att_str);
                } else {
                    // Escape only the right kind of quote
                    att_str = att + '="' +  attributes[att].replace(/"/g, '&quot;') + '"';
                    result.push(att_str);
                }
            }
            return result.join(' ');
        };
        var attr_str = '';
        if (attr) {
            attr_str = formatAttributes(attr);
        }
        var xml;
        if (typeof value === 'undefined' || value === null){
            xml = '<' + name + attr_str + '/>';
        } else {
            xml = '<' + name + attr_str + '>' + value + '</'+name+'>';
        }
        return xml;
    };
})(jQuery);
;
(function($){
    /* 
     * Defaults
     * For a list of the options supported, see the jQuery UI documentation:
     * http://jqueryui.com/demos/accordion/
     *
     * In addition, the widget set the following additional defaults
     *
     * refreshOnChange:Boolean Default = false
     * Set to true, and the accordion will use ajax to reload the content each time
     * the panel is activated. The default is to load the content only the first time
     * the panel is shown.
     *
     * followRemoteLinks: Boolean Default = true
     * Set to false, and the accordion won't do an ajax load of the content if it encounters
     * a remote link.
     *
     */
    var defaults = {
        active: 0,
        autoHeight: false,
        collapsible: false,
        refreshOnChange: false,
        followRemoteLinks: true,
        defaultUnit: 'px',
        header: '>dt'
    };
    /*
     * A function that is called when the accordion panel changes
     * it's active panel. It's also called right after the accordion panel
     * is first set up.
     */
    var loadUrlOnChange = function(event, ui){
        var $dd;
        // examine the panel header. If it has an anchor with an href attribute load that URL.
        if (ui.newHeader.length === 0) {
            if (typeof ui.oldHeader === "undefined" || ui.oldHeader.length === 0) {
                // this was an initial call ... 
                $.dr.utils.logError("Panel not formattted correctly. No header tag.");
            }
            return;
        } else {
            $dd = ui.newHeader.next();
        }
        var oThis = this;
        var header = $(ui.newHeader).find('a');
        if (header.length === 0) {
            // $.dr.utils.logError("Panel not formatted correctly, no enclosing A tag.");
            return;
        }
        var dataSource = header[0].getAttribute('href');
        
        var fn = function(res, statusStr){
            if (statusStr === "success") {
                /*
                 * Trigger a custom event to let any component that wants to know that
                 * the accordion panel has done an async load of content.
                 */
                $(this).trigger('accordionload', [$dd, res]);
            }
        };
        if (dataSource && dataSource.indexOf('#') == -1) {
            var dataUrl;
            var dataOptions = header[0].getAttribute('data-options');
            if (dataOptions) {
                var dO = $.dr.utils.evalString(dataOptions);
                if (typeof dO.selector === "string") {
                    dataUrl = [dataSource, dO.selector].join(" ");
                }
            } else {
                dataUrl = dataSource;
            }
            var followRemoteLinks = (ui.options && ui.options.followRemoteLinks) || null;
            if (followRemoteLinks == null) {
                try {
                    followRemoteLinks = $dd.parents(".accordion:first").data("uiAccordion").options.followRemoteLinks;
                } catch(e) {
                    followRemoteLinks = dataUrl != null && dataUrl.length > 0;
                }
            }
            if (followRemoteLinks && $dd && !$($dd).dr.ajaxpanel.loaded()) {
                    setTimeout(function(){
                        $($dd).dr.ajaxpanel({
                            url:dataUrl, 
                            params:{ajaxTime:(new Date()).getTime()},
                            afterrender: function(e, data, textStatus, XMLHttpRequest) {
                                    fn.call(oThis, data, textStatus);
                                } 
                            });
                    },0);   
            }
        }
    };
    
    var findActive = function(selector, $headers) {
        return selector 
            ? typeof selector == "number"
                ? $headers.filter(":eq(" + selector + ")")
                : $headers.not($headers.not(selector))
            : selector === false
                ? $([])
                : $headers.filter(":eq(0)");
    };
        
    $.namespace('dr', {
        accordion: function(accordionOptions){
            /*
             * determine how this was called. If there are no
             * arguments, assume it was called unobtrusively.
             */
            var isUnobtrusive = arguments.length === 0 ? true : false;
            return this.each(function(){
                if (typeof $(this).accordion !== "undefined") {
                    /*
                     * if this accordion panel was set up unobtrusively, add the default change function.
                     */
                    var extendedOptions = {};
                    if (isUnobtrusive) {
                        defaults.change = loadUrlOnChange;
                        var dataOptions = this.getAttribute('data-options');
                        if (dataOptions) {
                            extendedOptions = $.dr.utils.evalString(dataOptions, 'Error parsing accodion data-options for (' + this.id || 'accordian' + ')');
                            if (typeof accordionOptions === "error") {
                                extendedOptions = {};
                            }
                        }
                    }
                    
                    var options = $.extend(true, {}, defaults, accordionOptions, extendedOptions);
                    /*
                     * If height is set this way, several options don't makes sense. Default them.
                     */
                    if($.browser.msie && !options.height){
                        options.animated = false;
                    }
                    
                    if (options.height) {
                        options.active = 0;
                        options.collapsible = false;
                        options.fillSpace = true;

                        /*
                         * Create a wrapper element
                         */
                        $(this).wrap('<div class="acc-wrapper"></div>');
                        /*
                         * Find the wrapper and set its height
                         */
                        $(this).parent('.acc-wrapper').height(parseInt(options.height, 10) + options.defaultUnit);
                        if (options.width) {
                            /*
                             * If the width needs to be set, set it on the wrapper element.
                             */
                            $(this).parent('.acc-wrapper').width(parseInt(options.width, 10) + options.defaultUnit);
                        }
                    } else if (options.width) {
                        /*
                         * If the height is not being set, a wrapper element is not needed
                         */
                        $(this).width(parseInt(options.width, 10) + options.defaultUnit);
                    }
                    
                    // store the options so that they can be accessed by a public method.
                    $.dr.accordion.setOptions(options);
                    
                    /*
                     * Call the jQueryUI constructor
                     */
                    $(this).accordion(options);
                    
                    // disable text selection of header for IE, since this cannot be set in in CSS
                    if($.browser.msie){
                         $(this).find(options.header).each(function(){
                            this.onselectstart = function(){return false;}
                         })
                    }
                    
                    /*
                     * Manually check the first active panel to see if it has a remote data link
                     * and load it if it does.
                     */
                    if (options.active !== false) {
                        var header = $(this).find(options.header).eq(options.active);
                        if (header) {
                            var ui = {
                                newContent: header.next().children(),
                                newHeader: header,
                                options: options
                            };
                            // the setTimeout is here on purpose to give other un-obtrusive UI components time to register..
                            setTimeout(function() {
                                loadUrlOnChange("change", ui);
                            }, 0);
                        }
                    }
                } else {
                    /*
                     * If the .accordion function can't be found, assume that jQueryUI is not loaded.
                     */
                    $.dr.utils.logError("The jquery-ui js file is not present on this page.");
                }
            });
        }
    });
    /*
     * Public Methods
     */
    $.dr.accordion = {
        options: {},
        getDefaults: function(){
            return defaults;
        },
        setDefaults: function(newOptions){
            if (newOptions) {
                $.extend(defaults, newOptions);
            }
            $(document).trigger('afterAccordionSetDefaults', [newOptions]);
        },
        setOptions : function(object) {
            this.options = object;   
        },
        getOptions : function() {
           return this.options;
        }
    };
    
    // Create a plugin to show any accordion panel
    $.namespace('dr.accordion.show', function(selector, callback){
        return this.each(function(){
            var $acc = $(this);
      
            if ($acc.is('.accordion')) {
                var defaults = $.dr.accordion.getOptions();
                var $headers = $(defaults.header, this);

                // passing in false closes all the panels.
                if (selector !== false ) {
                    var currentActiveIndex = $headers.index($headers.filter(".ui-state-active"));
                    var newIndex = $headers.index(findActive.call(this, selector, $headers));
    
                    if (typeof callback === "function" && newIndex !== currentActiveIndex) {
                        $acc.one("accordionchange", function(event, ui) {
                            callback.call(this, event, ui);
                        });
                    } else {
                        if (callback && typeof callback === "function") {
                            callback.call(this);
                        }
                    }
                }

                $acc.accordion('activate', selector);
            }
        });
    });
    /*
     * a method to invoke Unobtrusive API
     */
    var initAccordion = function(evt, context){
        $('.accordion', context).dr.accordion();
    };
    
    $.dr.addUnobtrusiveEvent(initAccordion, 'unobtrusiveEventEarly');
})(jQuery);

;(function($) {
		
	var messages = {
		LOADING: $.dr.strings.LOADING,
		PROCESSING: $.dr.strings.PROCESSING,
		SAVING_CHANGES: "\u66F4\u6539\u4FDD\u5B58\u5230{0}",
		SAVE_SUCCESSFUL:  "{0}\u7684\u66F4\u6539\u5DF2\u6210\u529F\u4FDD\u5B58\u3002",
		UNSAVED_CHANGES_CONFIRM_TITLE: "\u66F4\u6539\u672A\u4FDD\u5B58",
		UNSAVED_CHANGES_CONFIRM_QUESTION: "\u6267\u884C\u8BF7\u6C42\u7684\u64CD\u4F5C\u524D\uFF0C\u662F\u5426\u5C06\u66F4\u6539\u4FDD\u5B58\u5230{0}\uFF1F",
		UNSAVED_CHANGES_CONFIRM_QUESTION_LOAD: "\u52A0\u8F7D{1}\u524D\u662F\u5426\u5C06\u66F4\u6539\u4FDD\u5B58\u5230{0}\uFF1F"
	}

	var defaults = {
		messages: {},
		selector: "", // not implemented
		url: "",
		params:"",
		postingMaskEnabled:false,
		isSaveMode:false,
		showSuccessOverlay:false,
		preventCache:true,
		preventCacheParamName:'ajaxTime',
		title: "",
		newTitle: "",
		height: '',
		width: '',
		loadingMaskDelay: 500,
		postingMaskDelay: 1500,
		autoLoad:true,
		
		// Events
		beforeload: null,
		loadsuccess: null,
		loaderror: null,
		beforepost: null,
		postsuccess: null,
		posterror: null,
		beforerender: null,
		afterrender: null,
		resize: null,
		ajaxcomplete: null
		
	}


	
	/*-----------------------------------------------------------------------------------------------
	 * The AjaxPanel is a region on the page used to display forms that are loaded
	 * and submitted using ajax.
	 * 
	 * Currently the AjaxPanel is only meant to have a single form in the ajax resonse.
	 * ---------------------------------------------------------------------------------------------*/		
	 	
	var ajaxPanel = function(panelId,isModal){
		this.settingName = "";
		this.newSettingName = "";
		this.panelId = panelId;
		this.content = (typeof panelId === 'string') ? $('#'+panelId)[0] : panelId;
		this.$content = $(this.content);
		this.currentForm = null;
		this.loaded=false;
		this.loading = false;
		this.saving = false;
		this.isSaveMode = true;
		this.url = "";
		this.queryStringData = "";
		this.errors=[];
		this.showSuccessMessage=true;
		this.saveCallback=null;
		this.loadCallback=null;
		this.checkChangeCallback=null;
		this.isModal = (isModal) ? true : false;
		this.options = {
			messages:messages,
			loadingMaskDelay:500,
			postingMaskDelay:500,
			preventCache:true,
			preventCacheParamName:'ajaxTime'
		};
	}
	
	ajaxPanel.prototype = {

		setOptions: function(options){
			options = $.extend(true, {}, defaults, this.options, options);
			// legacy properties
			this.url = options.url;
			//this.content = options.container;
			this.panelId = options.id;
			this.settingName = options.title;
			this.newSettingName = options.newTitle;
			this.isModal = options.postingMaskEnabled;
			this.showSuccessMessage = options.showSuccessOverlay;
			this.isSaveMode = options.isSaveMode;
			if(typeof options.params == 'object'){
				this.queryStringData = $.param(options.params, true);
			}else if(typeof options.params == 'string'){
				this.queryStringData = options.params;
			}
			
			if(this.content && options.width !=''){
				$(this.content).css('width',$.dr.utils.normalizeCSSDimension(options.width));
			}
			
			if(this.content && options.height !=''){
				$(this.content).css('height',$.dr.utils.normalizeCSSDimension(options.height));
			}
	
			this.options = options;
		},
		
		get: function(url,queryStringData){
			
			// TODO - check if save is occurring
			var oSelf = this;

			// if any beforeload event returns false, cancel the ajax request.
			if( oSelf.$content.drTriggerEach('beforeload') !== false){
				
				oSelf.markLoading();
				oSelf.url = url;
				if (queryStringData) {
					oSelf.queryStringData = queryStringData;
					url = $.dr.utils.appendParam(url, queryStringData);
				}
				
				if(oSelf.options.preventCache){
					url = $.dr.utils.appendParam(url, oSelf.options.preventCacheParamName + '='+(new Date()).getTime());
				}
						
				$.ajax({
					url: url,
					type: "GET",
					dataType: "html",
					success: function(data, textStatus, XMLHttpRequest){
						oSelf.loaded = true;
						oSelf.loading = false;
						if(oSelf.$content.drTriggerEach('loadsuccess',[data, textStatus, XMLHttpRequest]) !== false){
							if(oSelf.$content.drTriggerEach('beforerender',[data, textStatus, XMLHttpRequest]) !== false){
	
								oSelf.render(data);
								
								// legacy callback
								if($.isFunction(oSelf.loadCallback)){
									setTimeout(function() {
										oSelf.loadCallback(data);
									},0);
								}
								
								setTimeout(function() {
									oSelf.$content.drTriggerEach('afterrender', [data, textStatus, XMLHttpRequest]);
								}, 0 );
							}
						}
						
						// Force the ajaxcomplete event to fire after the afterrender event
						setTimeout(function() {
							oSelf.$content.drTriggerEach('ajaxcomplete', [data, textStatus, XMLHttpRequest]);
						}, 1 );
					},
					error: function(XMLHttpRequest, textStatus, errorThrown){
						oSelf.loaded = true;
						oSelf.loading = false;
						oSelf.saving = false;
						if(oSelf.$content.drTriggerEach('loaderror', [XMLHttpRequest, textStatus, errorThrown]) !== false){
							if(XMLHttpRequest.status=='500'){
								// Internal server error
								oSelf.render(XMLHttpRequest.responseText);
							}else if(XMLHttpRequest.status=='403'){
								// Session timeout
								window.location=$.dr.LOGIN_URL;
							}
						}
						// Force the ajaxcomplete event to fire after the afterrender event
						setTimeout(function() {
							oSelf.$content.drTriggerEach('ajaxcomplete', [XMLHttpRequest.responseText, textStatus, XMLHttpRequest]);
						}, 1 );
					}
				});
			}
			// legacy function
			if($.isFunction(oSelf.beforeLoadCallback)){
				oSelf.beforeLoadCallback();
			}	
			oSelf.loading = true;
			
		},
		
		refresh: function(){
			this.get(this.url,this.queryStringData);
		},
		
		render: function(html){
			if($.browser.msie){
				// IE has a bug where if the first element is a <script> tag, there must be a block element before
				// or that script will not be added to the DOM
				html = html.replace('<script','<br style="display:none"/> <script');
			}
			
			/*
			 * Do not use jquery style html() here otherewise scripts in html response get run twice.
			 * also IE6 is much slower with large forms using .html()
			 * investigate if we should fork the code here for the various browsers
			 */
			//$(this.content).html(html);
			this.content.innerHTML=html; 
			
			// remove references to the old forms
			if(this.currentForm!==null){
				var _form = this.currentForm;
				$(_form).dr.form.destroy();
			}
			
			// fire unobtrusive events on the new content
			$.dr.triggerUnobtrusiveEvents(this.content);
			
			
			var $forms = $("form",this.content);
			if($forms.length==0 && this.currentForm!==null){
				$forms.dr.form.destroy();
				this.currentForm = null;
			}else{
				for (var i=0; i < $forms.length; i++) {
					var _form = $forms[i];
					this.currentForm = _form;
					this.addHijackForm();
				}
			}
			
			// run all the scripts in the response.
			this.runScripts();
		},
		
		/*
		 * After the html has been injected via innerHTML, we eval any scripts present in the ajax response
		 */
		runScripts: function()
		{
			var div = this.content;
			var scripts = $('script',div);
			this.errors = [];
			var safariScripts=[];
			var isSafari = (navigator.userAgent.indexOf('Safari')>-1 && navigator.userAgent.indexOf('Chrome')==-1) ? true : false;
			for (var i=0; i < scripts.length; i++) {
				var script = scripts[i];
				var h = script.innerHTML;
				if(h.indexOf('document.write')==-1){
					if (script.src){
						$.dr.getScript(script.src);
				    }
				    else if (h){
						if (isSafari) {
							// eval.call does not work in older versions of Safari, so we have to use window.setTimeout(h,0)
							safariScripts.push(h);
						}
						else {
							try {
								if (window.execScript) {
									//  Internet Explorer only function
									window.execScript(h);
								}
								else {
									eval.call(window, h);
								}
							}
							catch (e) {
								this.errors[this.errors.length] = e;
							}
							this.displayScriptErrors();
						}
				   	}
				}
			}
			if (isSafari) {
				var oSelf = this;
				var safariFunc = function(){
					for (var i = 0; i < safariScripts.length; i++) {
						// put a try/catch around each script block
						try{
							eval(safariScripts[i]);
						}catch(e){
							oSelf.errors.push(e);
						}
					}
					oSelf.displayScriptErrors();
				}
				window.setTimeout( safariFunc, 0);
			}
		},
		
		displayScriptErrors: function(){
			if(this.errors.length>0 && $.dr.IS_INTERNAL_USER){
				$.dr.alert('There were javascript errors when loading '+this.settingName+':<br/><br/>'+this.errors.join("<br/><br/>"));
			}
		},


		addHijackForm: function(){

			var oSelf=this;

			var existingOnsubmit = this.currentForm.onsubmit;
			
			this.currentForm.onsubmit = function(allowHijack){
				var okToHijack = true;
				if ($.isFunction(existingOnsubmit)) {
					okToHijack = (existingOnsubmit.call(this) !== false);
				}
				if (okToHijack && (allowHijack !== false)) {
					oSelf.hijackForm();
					okToHijack = false;
				}
				return okToHijack;
			};
		},
				
		hijackForm: function(callback){
			var oSelf = this;
			var formData = $(this.currentForm).serialize();
			if( oSelf.$content.drTriggerEach('beforepost', [formData]) !== false){
				var url = $.dr.utils.appendParam(this.url, this.queryStringData, this.options.preventCacheParamName + '='+(new Date()).getTime());
				
				var hijackFailureCallback = function(XMLHttpRequest, textStatus, errorThrown){
					oSelf.hijackFailureCallback(XMLHttpRequest, textStatus, errorThrown);
				};
				var hijackCallback;
				
				this.loaded=false;
					
				// Standard forms are submitted via Ajax
				
				hijackCallback = function(data, textStatus, XMLHttpRequest){
					oSelf.hijackSaveCallback(data, textStatus, XMLHttpRequest);
					if($.isFunction(callback)){
						callback();
					}
				};
	
				var _form = this.currentForm;
				// there seems to be a problem here, the reIndex function does not seem to run
				$(_form).dr.form.reIndex();
				
				$.ajax({
					type:"POST",
					url:url,
					success: hijackCallback,
					error: hijackFailureCallback,
					data:formData
				});
				
				this.saving=true;
				this.markSaving();
			}
		},

		hijackSaveCallback: function(data, textStatus, XMLHttpRequest){
			var oSelf = this;
			if(data !== undefined)
			{
				this.saving=false;
				this.loaded=true;
				if(typeof $.dr.processingDialog == 'object'){
					//console.log('hijackSaveCallback: '+this.url)
					$.dr.processingDialog.hide();
				}
				if(this.showSuccessMessage){
					var msg = this.options.messages.SAVE_SUCCESSFUL.replace('{0}',this.settingName);
					$.dr.success(msg);	
				}

				if($.isFunction(this.checkChangeCallback)){
					this.checkChangeCallback();
				}else{

					if(oSelf.$content.drTriggerEach('postsuccess',[data, textStatus, XMLHttpRequest]) !== false){
						if(oSelf.$content.drTriggerEach('beforerender', [data, textStatus, XMLHttpRequest]) !== false){
							
							oSelf.render(data);
							
							// legacy callback 
							if($.isFunction(oSelf.saveCallback)){
								oSelf.saveCallback(data);
							}
							setTimeout(function() {
									oSelf.$content.drTriggerEach('afterrender', [data, textStatus, XMLHttpRequest]);
							}, 0 );
						}
					}
				}
			}
			// Force the ajaxcomplete event to fire after the afterrender event
			setTimeout(function() {
				oSelf.$content.drTriggerEach('ajaxcomplete', [data, textStatus, XMLHttpRequest]);
			}, 1 );
			
		},
		
		hijackFailureCallback: function(XMLHttpRequest, textStatus, errorThrown){
			var oSelf = this;
			if(typeof $.dr.processingDialog == 'object'){
				$.dr.processingDialog.hide();
			}
			if(oSelf.$content.drTriggerEach('posterror', [XMLHttpRequest, textStatus, errorThrown]) !== false){
				if (XMLHttpRequest.status=='403'){
					window.location=$.dr.LOGIN_URL;
				}else if (XMLHttpRequest.status=='500'){
					oSelf.render(XMLHttpRequest.responseText);
				}
			}
			// Force the ajaxcomplete event to fire after the afterrender event
			setTimeout(function() {
				oSelf.$content.drTriggerEach('ajaxcomplete', [XMLHttpRequest.responseText, textStatus, XMLHttpRequest]);
			}, 1 );
			
		},

		markLoading: function(){
			if(!this.saving){
				this.loaded=false;
				var oSelf = this;
				var func = function(){
					if(!oSelf.loaded){
						var title = (oSelf.settingName.length>0) ?  ' ' + oSelf.settingName : '' ;
						var msg = oSelf.options.messages.LOADING.replace('...', title + "...");
						oSelf.showLoadingMask(msg);
					}
				};
				setTimeout(func,this.options.loadingMaskDelay);
			}
		},

		markSaving: function(){
			if(!this.loading){
				this.saving=true;
				var oSelf = this;
				var func = function(){
					//console.log('markSaving: oSelf.loaded='+oSelf.loaded)
					if(!oSelf.loaded){
						if(oSelf.isModal){
							var processsingMsg = (oSelf.isSaveMode) ? oSelf.options.messages.SAVING_CHANGES : oSelf.options.messages.PROCESSING ;
							var title = (oSelf.settingName.length>0) ?  ' ' + oSelf.settingName : '' ;
							var msg = processsingMsg.replace('{0}', title + "...");
							oSelf.showLoadingMask(msg);
						}else{
							if(typeof $.dr.processingDialog == 'object'){
								$.dr.processingDialog.show();
							}
						}
					}
				};
				setTimeout(func,this.options.postingMaskDelay);
			}
		},
		
		showLoadingMask:function(msg){
			var h = Math.max(150, $(this.content).height());
			var halfHeight = Math.round(h/2)-9;
			var loadingDiv = '<div class="loadingTabContent" style="height:'+h+'px;" ><span style="margin-top:'+halfHeight+'px">' +msg + '</span></div>';
			this.content.innerHTML = loadingDiv;
		},
		
		checkChanges: function(callback){
			// Start out assuming no changes
			
			// Have we loaded anything yet?
			if(this.currentForm==null){
				callback(false);
				return false;	
			}
			
			var formChanges = this.checkFormChanges();

			// If current tab or child tab has changes, prompt the user to save
			if(formChanges){
				if(this.currentForm!==undefined){
					var _onSubmit = this.currentForm.onsubmit;
					if($.isFunction(_onSubmit)){
						var check = _onSubmit(false);
						if(check === false){
							return false;
						}
					}
				}
				
				// Store off reference to callback, it will run after user is shown the warning
				this.checkChangeCallback = callback;
				
				var oSelf = this;
				var confirmCallback = function(saveChanges){
					oSelf.checkChangesConfirmCallback(saveChanges);
				};
				
				var q;
				if(this.settingName==this.newSettingName){
					q = this.options.messages.UNSAVED_CHANGES_CONFIRM_QUESTION;
					q = q.replace('{0}',this.settingName);
				}else{
					q = this.options.messages.UNSAVED_CHANGES_CONFIRM_QUESTION_LOAD;
					q = q.replace('{0}',this.settingName);
					q = q.replace('{1}',this.newSettingName);
				}

				$.dr.warning(q,confirmCallback,{title:this.options.messages.UNSAVED_CHANGES_CONFIRM_TITLE});
				return true;
			}else{	
				// No changes, so run the callback
				callback(false);
				return false;
			}
		},	
				
		checkFormChanges: function(){
			var _form = this.currentForm;
		
			if(!_form){
				return false;
			}

			if($(_form).dr.form.get().checkChanges){
				if($(_form).dr.form.checkForChanges()){
					return true;
				}
			}
			return false;
		},
			  
		checkChangesConfirmCallback: function(saveChanges){

			var validationError = false;

			if(saveChanges){	
				var _form = this.currentForm;
				if($(_form).dr.form.validate()){
					this.hijackForm();
					return;
				}else{
					validationError=true;
				}	
			}
			
			if(!validationError){
				this.checkChangeCallback();
			}
		},

		busy: function(){
			return (this.loading || this.saving)
		},
		
		isLoading: function(){
			return (this.loading)
		},
			
		isLoaded: function(){
			return (this.loaded)
		},

		posting: function(){
			return (this.saving)
		},

		getCurrentForm: function(){
			var _form = this.currentForm;
			return _form;
		}
	
	}
	
		
	/*
	 * jQuery API to ajaxpanel
	 */
	
	$.namespace('dr.ajaxpanel',function(panelOptions){
		var timeStamp = new Date().getTime();
		var options = $.extend(true, {}, defaults, panelOptions);
		return this.dr.bindPluginEvents({
			'beforeload': options.beforeload,
			'loadsuccess': options.loadsuccess,
			'loaderror': options.loaderror,
			'beforerender': options.beforerender,
			'afterrender': options.afterrender,
			'beforepost': options.beforepost,
			'postsuccess': options.postsuccess,
			'posterror': options.posterror,
			'resize': options.resize,
			'ajaxcomplete': options.ajaxcomplete
		}).each(function(){
			options = $.extend(true, {}, options);
			var container = $(this);
			options.container = container;
			var panel = container.data('ajaxpanel'),
				url = options.url
			
			if(!panel){
				panel = new ajaxPanel(container[0],options.postingMaskEnabled);
			}
			
			panel.setOptions(options);
	
			if(options.autoLoad && url.length!==0 && !panel.busy()){
				panel.refresh();
			}
			container.data('ajaxpanel', panel);
		});
	});
	
	// Create plugin events
	$.dr.utils.createPluginEvents(
		'dr.ajaxpanel',[
			'beforeload',
			'loadsuccess',
			'loaderror',
			'beforepost',
			'postsuccess',
			'posterror',
			'beforerender',
			'afterrender',
			'resize',
			'ajaxcomplete'
	]);
	
	/*
	 * panelCommand takes two or more arguments, the first is the command to run, the remaining arguments 
	 * will be passed to the command.
	 * 
	 * The command is a string that must match a prototyped function on ajaxPanel.
	 * 
	 * The command is then run on each panel in the collection, which in most cases is just one panel.
	 * 
	 * panelCommand will return the result of the function unless it is void, which in that case the
	 * jQuery collection will be returned.
	 * 
	 * If the command is called and there is no panel in the data attribute, nothing will happen
	 * and the jQuery collection will be returned.
	 * 
	 */
	var panelCommand = function(){
		var myReturn = this;
		args = Array.prototype.slice.call(arguments);
		var defaultReturn = args.shift();
		var command = args.shift();
		this.each(function(){
			var ajaxpanel = $(this).data('ajaxpanel');
			if(ajaxpanel){
				if ( $.isFunction(ajaxpanel[command])){
					var r = ajaxpanel[command].apply(ajaxpanel,args);
					if(typeof r !== 'undefined'){
						myReturn = r;
					} 
				}
			}else{
				myReturn = defaultReturn;
			}
		});
		return myReturn;
	}
	
	/*
	 * Public API to ajaxpanel
	 */
	$.namespace('dr.ajaxpanel',{
		setOptions: function(options){
			panelCommand.call(this, this, 'setOptions',options);
		},
		
		refresh: function(){
			panelCommand.call(this, this, 'refresh');
			return this;
		},
			
		render: function(html){
			if(!panelCommand.call(this, false, 'busy')){
				panelCommand.call(this, this,  'render', html);
			}
			return this;
		},

		posting: function(){
			return panelCommand.call(this, false, 'posting');
		},
		
		loaded: function(){
			return panelCommand.call(this, false, 'isLoaded');
		},

		loading: function(){
			return panelCommand.call(this, false, 'isLoading');
		},

		busy: function(){
			return panelCommand.call(this, false, 'busy');
		},
				
		checkChanges: function(callback){
			return panelCommand.call(this, false, 'checkChanges', callback);
		}
		
	});
	
	
})(jQuery);

/*
 * Autocomplete - jQuery plugin 1.0.2
 *
 * Copyright (c) 2007 Dylan Verheul, Dan G. Switzer, Anjesh Tuladhar, Jörn Zaefferer
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * Revision: $Id: Autocomplete.js,v 1.7 2010/12/07 23:06:57 nschneirov Exp $
 *
 */



;(function($) {
	
	var defaults = {
		comboBox:false,
		minChars: 1,
		delay: 400,
		matchCase: false,
		matchSubset: true,
		matchContains: false,
		cacheLength: 10,
		max: 10000,
		mustMatch: false,
		extraParams: {},
		selectFirst: false,
		formatItem: function(row) { return row[0]; },
		formatMatch: null,
		autoFill: false,
		width: 0,
		multiple: false,
		multipleSeparator: ", ",
		highlight: function(value, term) {
			return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1") + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<strong>$1</strong>");
		},
	    scroll: true,
	    scrollHeight: 180
	};
	
	var autocompleteSelection = function(field, start, end) {
		if( field.createTextRange ){
			var selRange = field.createTextRange();
			selRange.collapse(true);
			selRange.moveStart("character", start);
			selRange.moveEnd("character", end);
			selRange.select();
		} else if( field.setSelectionRange ){
			field.setSelectionRange(start, end);
		} else {
			if( field.selectionStart ){
				field.selectionStart = start;
				field.selectionEnd = end;
			}
		}
		field.focus();
	};
	
	var autocompleteCache = function(options) {
	
		var data = {};
		var length = 0;
		
		function matchSubset(s, sub) {
			if (!options.matchCase) 
				s = s.toLowerCase();
			var i = s.indexOf(sub);
			if (i == -1) return false;
			return i == 0 || options.matchContains;
		};
		
		function add(q, value) {
			if (length > options.cacheLength){
				flush();
			}
			if (!data[q]){ 
				length++;
			}
			data[q] = value;
		}
		
		function populate(){
			if( !options.data ) return false;
			// track the matches
			var stMatchSets = {},
				nullData = 0;
	
			// no url was specified, we need to adjust the cache length to make sure it fits the local data store
			if( !options.url ) options.cacheLength = 1;
			
			// track all options for minChars = 0
			stMatchSets[""] = [];
			
			// loop through the array and create a lookup structure
			for ( var i = 0, ol = options.data.length; i < ol; i++ ) {
				var rawValue = options.data[i];
				// if rawValue is a string, make an array otherwise just reference the array
				rawValue = (typeof rawValue == "string") ? [rawValue] : rawValue;
				
				var value = options.formatMatch(rawValue, i+1, options.data.length);
				if ( value === false )
					continue;
					
				var firstChar = value.charAt(0).toLowerCase();
				// if no lookup array for this character exists, look it up now
				if( !stMatchSets[firstChar] ) 
					stMatchSets[firstChar] = [];
	
				// if the match is a string
				var row = {
					value: value,
					data: rawValue,
					result: options.formatResult && options.formatResult(rawValue) || value
				};
				
				// push the current match into the set list
				stMatchSets[firstChar].push(row);
	
				// keep track of minChars zero items
				if ( nullData++ < options.max ) {
					stMatchSets[""].push(row);
				}
			};
	
			// add the data items to the cache
			$.each(stMatchSets, function(i, value) {
				// increase the cache size
				options.cacheLength++;
				// add to the cache
				add(i, value);
			});
		}
		
		// populate any existing data
		setTimeout(populate, 25);
		
		function flush(){
			data = {};
			length = 0;
		}
		
		return {
			flush: flush,
			add: add,
			populate: populate,
			load: function(q) {
				if (!options.cacheLength || !length)
					return null;
				/* 
				 * if dealing w/local data and matchContains than we must make sure
				 * to loop through all the data collections looking for matches
				 */
				if( !options.url && options.matchContains ){
					// track all matches
					var csub = [];
					// loop through all the data grids for matches
					for( var k in data ){
						// don't search through the stMatchSets[""] (minChars: 0) cache
						// this prevents duplicates
						if( k.length > 0 ){
							var c = data[k];
							$.each(c, function(i, x) {
								// if we've got a match, add it to the array
								if (matchSubset(x.value, q)) {
									csub.push(x);
								}
							});
						}
					}				
					return csub;
				} else 
				// if the exact item exists, use it
				if (data[q]){
					return data[q];
				} else
				if (options.matchSubset) {
					for (var i = q.length - 1; i >= options.minChars; i--) {
						var c = data[q.substr(0, i)];
						if (c) {
							var csub = [];
							$.each(c, function(i, x) {
								if (matchSubset(x.value, q)) {
									csub[csub.length] = x;
								}
							});
							return csub;
						}
					}
				}
				return null;
			}
		};
	};
	
	var autocompleteSelect = function (options, input, select, config, selectCallback, inputWrapper) {
		var CLASSES = {
			ACTIVE: "ac_over"
		};
		
		var listItems,
			active = -1,
			data,
			term = "",
			needsInit = true,
			popup,
			list,
			shadow;
		
		// Create results
		function init() {
			if (!needsInit)
				return;
			
			var div = $('<div />').addClass('ac_abs').prependTo('body');
			popup = $('<div />').appendTo(div);
			
			popup.addClass('ac_popup').dr.shadows();
			
			shadow = div;
			shadow.css({zIndex:1,position:'absolute'});
			
			list = $("<ul/>").appendTo(popup).mouseover( function(event) {
				if(target(event).nodeName && target(event).nodeName.toUpperCase() == 'LI') {
		            active = $("li", list).removeClass(CLASSES.ACTIVE).index(target(event));
				    $(target(event)).addClass(CLASSES.ACTIVE);            
		        }
			}).click(function(event) {
				$(target(event)).addClass(CLASSES.ACTIVE);
				
				// maps to selectCurrent();
				var selected = select();

				if( selected!==null) {
					selectCallback(selected);
				}
				
				// TODO provide option to avoid setting focus again after selection? useful for cleanup-on-focus
				input.focus();
				return false;
			}).mousedown(function() {
				config.mouseDownOnSelect = true;
			}).mouseup(function() {
				config.mouseDownOnSelect = false;
			});
			
			if( options.width > 0 )
				popup.css("width", options.width);
			

				
			needsInit = false;
		} 
		
		function target(event) {
			var popup = event.target;
			while(popup && popup.tagName != "LI")
				popup = popup.parentNode;
			// more fun with IE, sometimes event.target is empty, just ignore it then
			if(!popup)
				return [];
			return popup;
		}
	
		function moveSelect(step) {
			listItems.slice(active, active + 1).removeClass(CLASSES.ACTIVE);
			movePosition(step);
	        var activeItem = listItems.slice(active, active + 1).addClass(CLASSES.ACTIVE);
	        if(options.scroll) {
	            var offset = 0;
	            listItems.slice(0, active).each(function() {
					offset += this.offsetHeight;
				});
	            if((offset + activeItem[0].offsetHeight - list.scrollTop()) > list[0].clientHeight) {
	                list.scrollTop(offset + activeItem[0].offsetHeight - list.innerHeight());
	            } else if(offset < list.scrollTop()) {
	                list.scrollTop(offset);
	            }
	        }
		};
		
		function movePosition(step) {
			active += step;
			if (active < 0) {
				active=0;
				//active = listItems.size() - 1;
			} else if (active >= listItems.size()) {
				active=listItems.size()-1;
				//active = 0;
			}
		}
		
		function limitNumberOfItems(available) {
			return options.max && options.max < available
				? options.max
				: available;
		}
		
		function fillList() {
			list.empty();
			var max = limitNumberOfItems(data.length);
			for (var i=0; i < max; i++) {
				if (!data[i])
					continue;
				var formatted = options.formatItem(data[i].data, i+1, max, data[i].value, term);
				if ( formatted === false )
					continue;
				var li = $("<li/>").html( options.highlight(formatted, term) ).addClass(i%2 == 0 ? "ac_even" : "ac_odd").appendTo(list)[0];
				$.data(li, "ac_data", data[i]);
			}
			listItems = list.find("li");
			if ( options.selectFirst ) {
				listItems.slice(0, 1).addClass(CLASSES.ACTIVE);
				active = 0;
			}
		}
		
		return {
			display: function(d, q) {
				
				if(active!=-1){
					active=0;
				}
				init();
				data = d;
				term = q;
				fillList();
			},
			next: function() {
				moveSelect(1);
			},
			prev: function() {
				moveSelect(-1);
			},
			pageUp: function() {
				if (active != 0 && active - 9 < 0) {
					moveSelect( -active );
				} else {
					moveSelect(-9);
				}
			},
			pageDown: function() {
				if (active != listItems.size() - 1 && active + 9 > listItems.size()) {
					moveSelect( listItems.size() - 1 - active );
				} else {
					moveSelect(9);
				}
			},
			hide: function() {
				
				popup && popup.slideUp(function(){inputWrapper.parent().removeClass('ac_open');shadow.hide();});
				listItems && listItems.removeClass(CLASSES.ACTIVE);
				active = -1;
			},
			visible : function() {
				return shadow && shadow.is(":visible");
			},
			current: function() {
				return this.visible() && (listItems.filter("." + CLASSES.ACTIVE)[0] || options.selectFirst && listItems[0]);
			},
			show: function() {
				var width = input.offsetWidth-2;
				var offset = $(input).offset();
				inputWrapper.parent().addClass('ac_open');
				popup.css({
					width: typeof options.width == "string" || options.width > 0 ? options.width : width
				});
				//console.log(input.offsetHeight)
				//inputWrapper.css({height:input.offsetHeight})
				
				
				//shadow.css({top: input.offsetHeight - 1}).show();
				popup.show();
				shadow.show();
							
				var _offsetX = -(20/2);
				var _offsetY = -1;
				
				if($.browser.msie && parseInt($.browser.version,10) <= 7){
					// IE6 currently only has no shadow, so we don't need to offset anything
					_offsetX = 0;
					//_offsetY = 0;
				}
				
				var edgeX = 'Left';
				var edgeY = 'Bottom';
				var drawDirectionX = "Right";
				var drawDirectionY = "Down";
							
				DR.Utils.Position.snapTo(input,shadow[0], _offsetX, _offsetY, edgeX, edgeY, drawDirectionX, drawDirectionY,false);
				
				
	            if(options.scroll) {
	                list.scrollTop(0);
	                list.css({
						maxHeight: options.scrollHeight
						,	overflow: 'auto'
					});
					
	                if($.browser.msie && typeof document.body.style.maxHeight === "undefined") {
						var listHeight = 0;
						listItems.each(function() {
							listHeight += this.offsetHeight;
						});
						var scrollbarsVisible = listHeight > options.scrollHeight;
	                    list.css('height', scrollbarsVisible ? options.scrollHeight : listHeight );
						if (!scrollbarsVisible) {
							// IE doesn't recalculate width when scrollbar disappears
							listItems.width( list.width() - parseInt(listItems.css("padding-left")) - parseInt(listItems.css("padding-right")) );
						}
	                }
	                
	                
	            }
			},
			selected: function() {
				var selected = listItems && listItems.filter("." + CLASSES.ACTIVE).removeClass(CLASSES.ACTIVE);
				return selected && selected.length && $.data(selected[0], "ac_data");
			},
			emptyList: function (){
				list && list.empty();
			},
			unbind: function() {
				popup && popup.remove();
			}
		};
	};	

	var autocomplete = function(input, options, dataCallback) {
	
		var KEY = {
			UP: 38,
			DOWN: 40,
			DEL: 46,
			TAB: 9,
			RETURN: 13,
			ESC: 27,
			COMMA: 188,
			PAGEUP: 33,
			PAGEDOWN: 34,
			BACKSPACE: 8
		};
		
		var $input = $(input),
		originalInput = input,
		boundInput = null;
		
		var widthOffset = ($.browser.msie) ? 6 : 4;
		//var heightOffset = ($.browser.msie) ? 6 : 6;
		
		//var ieoffset = ($.browser.msie) ? -2 : 0;
		// get the current width and height of the existing input
		var computedWidth = $input.dr.computedWidth()+widthOffset;
		//var computedHeight = $input.dr.computedHeight()+heightOffset;
		
	
		
		// if the height is returned as zero, then set it to be 19, which works for inputs, but textreas will not work.
		
		
		//console.log(input.id,  input.offsetWidth, computedWidth)
		
		computedWidth = (computedWidth>widthOffset) ? computedWidth : (input.offsetWidth);
		//computedHeight = (computedHeight>heightOffset) ? computedHeight : 19;
		
		//console.log(input.id,  input.offsetWidth, computedWidth , input.offsetHeight, computedHeight)
		
		
		//console.log(computedWidth, input.offsetWidth,  computedHeight, input.offsetHeight)
		
		//wrap a DIV around the input
		var wrapper = $('<div class="ac_wrapper" style="width:'+computedWidth+'px;" />');
		
	
		
		//v ar wrapperWrapper = $('<div class="autocomplete" />');
		//wrapper.appendTo(wrapperWrapper);
		//wrapperWrapper.append(wrapper);
		
		//v ar inputHTML = '<input type="text" />';
		boundInput = $input.clone();
		boundInput.removeAttr('name').removeAttr('id');
		
		
		// create a new input element - it will not post because it has no name attribute
		if(input.tagName.toLowerCase()=='textarea'){
			//inputHTML = '<textarea style="max-width:'+(input.offsetWidth)+'px;max-height:'+input.offsetHeight+'px;" rows="'+$input.attr('rows')+'" cols="'+$input.attr('cols')+'"  />';
			boundInput.css('max-width',input.offsetWidth+'px').css('max-height',input.offsetHeight+'px');		
			wrapper.addClass('ac_textareaWrapper');
		}
		boundInput.appendTo(wrapper);
		//boundInput = $(inputHTML).addClass($input.attr('class')).appendTo(wrapper);
		
		boundInput.val($input.val());
		
		boundInput.attr('data-expand-collapse','false');
		$input.attr('data-expand-collapse','false');
		$input.data('validationEnabled', false);
		
		wrapper.insertBefore($input);
		
		wrapper.wrap('<div class="autocomplete" />');

		// hide the original input
		$input.hide();
		
		// change the $input reference to the newly created boundInput
		$input = boundInput;
		
		// change the reference to the newly created input
		input = boundInput[0];
		var inputcopy = input;

		//var func = function(evt){
			//var fields = $(input);
			// $(input.form).dr.form.initFields(fields,true);
		//};
		
		//$(input.form).bind('dr-afterindexfields',func);
				
		// create loading layer
		var $loading = $('<span class="loading" />').appendTo(wrapper).hide();
		

		// if the input is a "comboBox" then we add a handle the user can click
		if(options.comboBox){
			wrapper.addClass('ac_comboBox');
			var handle = $('<span class="handle" />').appendTo(wrapper)
			.mousedown(function(evt){
				// if the controls is already focused to, leave the focus there
				evt.preventDefault();
			})
			.click(function(evt) {
				
				var func = function(){
					var show=true;
					// hide select because it is open
					if(typeof select !== 'undefined'){
						
						if(select.visible()){
							select.hide();
							show=false;
						}
					}
					if(show){
						// show select when clicking in a focused field
						input.focus();
						hasFocus = 1;
						onChange(0, true);
					}

				}
				var pause = ($.browser.msie) ? 200 : 20;
				setTimeout(func,pause);
				evt.preventDefault();
			});
		}
		

		var updateBoundValue = function(){
			// if we have created a dummy input to type into, then we must update the original
			// value when the user selects a value
			
			if(boundInput!==null){
				//val = arguments[0][0];
				
				//if(typeof arguments[0][1] !== 'undefined' && typeof arguments[1][1][1] !== 'undefined'){
				//	val = arguments[1][1];
				//}
				
				$(originalInput).val(boundInput.val());
			}
		}
		
		var validate = function(){
			if($.dr && $.dr.form && $.dr.form.validateField){
				$.dr.form.validateField(input,true);
			}
		}
		
		/*
		var dataCallback  = function(){
			updateBoundValue();
			if(typeof callBack == 'function'){
				callBack(arguments[0],arguments[1],arguments[2]);
			}
		}
		*/
	
		// Create $ object for input popup
		$input = $(input).attr("autocomplete", "off");
	
		var timeout,
		previousValue = "",
		cache = new autocompleteCache(options),
		hasFocus = 0,
		lastKeyPressCode,
		config = {
			mouseDownOnSelect: false
		},
		select = new autocompleteSelect(options, input, selectCurrent, config, doCallback,wrapper),
		blockSubmit;
		
		// prevent form submit in opera when selecting with return key
		$.browser.opera && $(input.form).bind("submit.autocomplete", function() {
			if (blockSubmit) {
				blockSubmit = false;
				return false;
			}
		});
		
		function doCallback(selected){
			validate();
			// called when the user has selected an item
			if(!selected){
				return;
			}
			updateBoundValue();
			
			// check to see if there was a optional callback setup
			if(typeof options.callback == 'function'){
				var func = function(){
				 	options.callback(selected[0], selected[1]);
				 }
				setTimeout(func,10);
			}
		}
	
		
		// only opera doesn't trigger keydown multiple times while pressed, others don't work with keypress at all
		$input.bind(($.browser.opera ? "keypress" : "keydown") + ".autocomplete", function(event) {
			// track last key pressed
			lastKeyPressCode = event.keyCode;
			switch(event.keyCode) {
			
				case KEY.UP:
					event.preventDefault();
					if ( select.visible() ) {
						select.prev();
					} else {
						onChange(0, true);
					}
					break;
					
				case KEY.DOWN:
					event.preventDefault();
					if ( select.visible() ) {
						select.next();
					} else {
						onChange(0, true);
					}
					break;
					
				case KEY.PAGEUP:
					event.preventDefault();
					if ( select.visible() ) {
						select.pageUp();
					} else {
						onChange(0, true);
					}
					break;
					
				case KEY.PAGEDOWN:
					event.preventDefault();
					if ( select.visible() ) {
						select.pageDown();
					} else {
						onChange(0, true);
					}
					break;
				
				// matches also semicolon
				case options.multiple && $.trim(options.multipleSeparator) == "," && KEY.COMMA:
				case KEY.TAB:
				case KEY.RETURN:

					var selected = selectCurrent();

					if( selected!==null) {
						// stop default to prevent a form submit, Opera needs special handling
						//event.preventDefault();
						//blockSubmit = true;
						//return false;
						blockSubmit = true;
						if( !options.multiple ) {
							// JS: No need to blur; just tab away
							// JS: $input.blur();
							
							// JS: Made the following conditional
							// JS: Basically if we're going to issue
							// JS: a tab event we need it to bubble
							if(event.keyCode==KEY.RETURN){
								event.keyCode = KEY.TAB;
								event.preventDefault();
							}else{
								event.keyCode = KEY.TAB;
								
							}
						} else {
							event.preventDefault();
						}
						
						doCallback(selected);

					}
					break;
					
				case KEY.ESC:
					select.hide();
					break;
					
				default:
					clearTimeout(timeout);
					timeout = setTimeout(onChange, options.delay);
					break;
			}
			updateBoundValue();
			validate();
		}).focus(function(){
			// track whether the field has focus, we shouldn't process any
			// results if the field no longer has focus
			hasFocus++;
		}).blur(function(evt) {
			validate();
			updateBoundValue();
			hasFocus = 0;
			if (!config.mouseDownOnSelect) {
				hideResults();
			}
		}).click(function() {
			// show select when clicking in a focused field
			if ( hasFocus++ > 1 && !select.visible() ) {
				onChange(0, true);
			}
		}).dblclick(function(){
			if($.browser.msie){
				if ( !select.visible() ) {
					onChange(0, true);
				}				
			}
		}).bind("search", function() {
			// TODO why not just specifying both arguments?
			var fn = (arguments.length > 1) ? arguments[1] : null;
			function findValueCallback(q, data) {
				var result;
				if( data && data.length ) {
					for (var i=0; i < data.length; i++) {
						if( data[i].result.toLowerCase() == q.toLowerCase() ) {
							result = data[i];
							break;
						}
					}
				}
				// fn is used in dr.autocomplete.search
				if( typeof fn == "function" ) fn(result);
				else doCallback(result);
			}
			$.each(trimWords($input.val()), function(i, value) {
				request(value, findValueCallback, findValueCallback);
			});
		}).bind("flushCache", function() {
			cache.flush();
		}).bind("setOptions", function() {
			$.extend(options, arguments[1]);
			// if we've updated the data, repopulate
			if ( "data" in arguments[1] )
				cache.populate();
		}).bind("unautocomplete", function() {
			select.unbind();
			$input.unbind();
			$(input.form).unbind(".autocomplete");
		});


		function selectCurrent() {

			var selected = select.selected();
			if( !selected )
				return false;
			
			var v = selected.result;
			previousValue = v;
			
			if ( options.multiple ) {
				var words = trimWords($input.val());
				if ( words.length > 1 ) {
					v = words.slice(0, words.length - 1).join( options.multipleSeparator ) + options.multipleSeparator + v;
				}
				v += options.multipleSeparator;
			}
			
			$input.val(v);
			hideResultsNow();
			
			return [selected.data, selected.value];

		}
		
		function onChange(arg1, skipPrevCheck) {
			if( lastKeyPressCode == KEY.DEL ) {
				select.hide();
				return;
			}
			
			var currentValue = $input.val();
			
			if ( !skipPrevCheck && currentValue == previousValue )
				return;
			
			previousValue = currentValue;
			
			currentValue = lastWord(currentValue);
			if ( currentValue.length >= options.minChars) {
				$loading.show();
				if (!options.matchCase)
					currentValue = currentValue.toLowerCase();
				request(currentValue, receiveData, hideResultsNow);
			} else {
				stopLoading();
				select.hide();
			}
		};
		
		function trimWords(value) {
			if ( !value ) {
				return [""];
			}
			var words = value.split( options.multipleSeparator );
			var result = [];
			$.each(words, function(i, value) {
				if ( $.trim(value) )
					result[i] = $.trim(value);
			});
			return result;
		}
		
		function lastWord(value) {
			if ( !options.multiple )
				return value;
			var words = trimWords(value);
			return words[words.length - 1];
		}
		
		// fills in the input box w/the first match (assumed to be the best match)
		// q: the term entered
		// sValue: the first matching result
		function autoFill(q, sValue){
			// autofill in the complete box w/the first match as long as the user hasn't entered in more data
			// if the last user key pressed was backspace, don't autofill
			if( options.autoFill && (lastWord($input.val()).toLowerCase() == q.toLowerCase()) && lastKeyPressCode != KEY.BACKSPACE ) {
				// fill in the value (keep the case the user has typed)
				$input.val($input.val() + sValue.substring(lastWord(previousValue).length));
				// select the portion of the value not typed by the user (so the next character will erase)
				autocompleteSelection(input, previousValue.length, previousValue.length + sValue.length);
			}
		};
	
		function hideResults() {
			clearTimeout(timeout);
			timeout = setTimeout(hideResultsNow, 200);
		};
	
		function hideResultsNow() {
			var wasVisible = select.visible();
			select.hide();
			clearTimeout(timeout);
			stopLoading();
			if (options.mustMatch) {
				// call search and run callback
				$input.dr.autocomplete.search(
					function (result){
						// if no value found, clear the input box
						if( !result ) {
							if (options.multiple) {
								var words = trimWords($input.val()).slice(0, -1);
								$input.val( words.join(options.multipleSeparator) + (words.length ? options.multipleSeparator : "") );
							}
							else
								$input.val( "" );
						}
					}
				);
			}
			if (wasVisible)
				// position cursor at end of input field
				autocompleteSelection(input, input.value.length, input.value.length);
		};
	
		function receiveData(q, data) {
			if ( data && data.length && hasFocus ) {
				stopLoading();
				select.display(data, q);
				autoFill(q, data[0].value);
				select.show();
			} else {
				hideResultsNow();
			}
		};
	
		function request(term, success, failure) {
			if (!options.matchCase)
				term = term.toLowerCase();
			var data = cache.load(term);
			// recieve the cached data
			if (data && data.length) {
				success(term, data);
			// if an AJAX url has been supplied, try loading the data now
			} else if( (typeof options.url == "string") && (options.url.length > 0) ){
				
				var extraParams = {
					ajaxTime: new Date()
				};
				$.each(options.extraParams, function(key, param) {
					extraParams[key] = typeof param == "function" ? param() : param;
				});
				
				$.ajax({
					// try to leverage ajaxQueue plugin to abort previous requests
					mode: "abort",
					// limit operation to this input
					port: "autocomplete" + input.name,
					dataType: options.dataType,
					url: options.url,
					data: $.extend({
						query: lastWord(term),
						limit: options.max
					}, extraParams),
					success: function(data) {
						
						var parsed = options.parse && options.parse(data) || parse(data);
						cache.add(term, parsed);
						success(term, parsed);
					},
					error: function(XMLHttpRequest, textStatus, errorThrown){
						if(typeof options.errorCallback=='function'){
							options.failureCallback(XMLHttpRequest, textStatus, errorThrown);
						}
					}
				});
			} else {
				// if we have a failure, we need to empty the list -- this prevents the the [TAB] key from selecting the last successful match
				select.emptyList();
				failure(term);
			}
		};
		
		function parse(data) {
			var parsed = [];
			var rows = data.split("\n");
			for (var i=0; i < rows.length; i++) {
				var row = $.trim(rows[i]);
				if (row) {
					row = row.split("|");
					parsed[parsed.length] = {
						data: row,
						value: row[0],
						result: options.formatResult && options.formatResult(row, row[0]) || row[0]
					};
				}
			}
			return parsed;
		};
	
		function stopLoading() {
			$loading.hide();
		};
		
		return {
			boundInput:$input
		}
	
	};
	


	/*
	 * The autocomplete needs to be fired early for two reasons
	 * 
	 *  1 - the plugin changes the appearence of the control, so its good to have the change
	 *  	fire early.
	 *  2 - the autocomplete fields need to be added to the dom before the form indexer runs
	 */
	
	var unobtrusiveInit = function(evt){
	
		// Find all the autocomplete fields in the context, usually a form.
		var a = $('input.autocomplete, textarea.autocomplete, input.combobox',this);
		
		if(a.length>0){
			a.dr.autocomplete();
		}
	}
	
	// bind to all forms, or future forms created with ajax, etc
	//$('form').live('dr-beforeindexfields',unobtrusiveInit);

	$(document).delegate('form', 'dr-beforeindexfields', unobtrusiveInit);   
	
	$.dr.autocomplete = {
		setDefaults: function(options){
			if(options) {
				// Example of options being passed:
				// autocomplete.setDefaults( {max:100} );
				$.extend(defaults, options);
			}
		}
	};
		
	/*
	 * The dr.autocomplete plugin hooks up an autocomplete.
	 * Usually used for setting up single autocomplete with javascript
	 */
	$.namespace('dr',{
		autocomplete: function(dataSource, jsDataOptions) {
			
			var isUnobtrusive = false,
				isUrl = (typeof dataSource == "string") ? true : false;
			if(!jsDataOptions){jsDataOptions = {};};
			
			// hook up autocomplete unobtrusively
			if(arguments.length==0){
				isUnobtrusive=true;
			}

			return this.each(function() {
				var jObj = $(this);
				if(!jObj.data('autocomplete_inited')){
					var options = jsDataOptions;
	
					if(isUnobtrusive){
						isUrl = false;
						dataSource = jObj.attr('data-source');
						
						// there should only be a data-source OR a data-url defined
						var dataUrl = jObj.attr('data-url');
						dataOptions = jObj.attr('data-options');
						
						if(!dataSource){
							if(!dataUrl){
								$.dr.utils.logError('('+this.id+') did not contain a data-url or data-source attribute');
								return;
							}else{
								isUrl = true;
								dataSource = dataUrl;
							}
						}else{
							dataSource = $.dr.utils.evalString(dataSource, 'The referenced data-source for ('+this.id+') does not exist.');
							if(typeof dataSource == 'error'){return};
						}
			
						if(dataOptions){
							options = $.dr.utils.evalString(dataOptions, 'Error parsing autocomplete data-options for ('+this.id+')');
							if(typeof options == 'error'){return};
						}
					}
					
					if(this.tagName.toLowerCase()=='textarea'){					
						if(typeof options.multiple == 'undefined'){
							// assume that all textareas are multiple, unless they are specifically saying multiple:false
							options.multiple=true;
						}
					}
	
					var extendOptions = $.extend({}, defaults, {
						url: isUrl ? dataSource : null,
						data: isUrl ? null : dataSource,
						delay: isUrl ? defaults.delay : 10
					}, options);
					
					if(jObj.hasClass('combobox')){
						extendOptions.comboBox = true;
					}
					
					// if highlight is set to false, replace it with a do-nothing function
					extendOptions.highlight = extendOptions.highlight || function(value) { return value; };
					
					// if the formatMatch option is not specified, then use formatItem for backwards compatibility
					extendOptions.formatMatch = extendOptions.formatMatch || extendOptions.formatItem;
	
					jObj.data('autocomplete_inited','true');
					var ac = new autocomplete(this, extendOptions);
					
					jObj.data('autocomplete',ac);
					if(!isUnobtrusive){
						// the new field needs to be indexed so it has the normal field events.
						$(this.form).dr.form.initFields(ac.boundInput);
					}
				}
			});
		}
	});
	
	$.namespace('dr.autocomplete',{
		search: function(handler) {
			return this.trigger("search", [handler]);
		},
		
		flushCache: function() {
			return this.trigger("flushCache");
		},
		
		setOptions: function(options){
			return this.trigger("setOptions", [options]);
		},
		
		destroy: function() {
			return this.trigger("unautocomplete");
		}
	});


	
})(jQuery);
;(function($){
    var oppositeAxis = {"Y":"X", "X":"Y"};
    function getBackgroundData(strg){
        var res = strg.replace(/left|top/g,'0px').replace(/right|bottom/g,'100%').replace(/([0-9\.]+)(\s|\)|$)/g,"$1px$2").match(/(-?[0-9\.]+)(px|\%|em|pt)\s(-?[0-9\.]+)(px|\%|em|pt)/);
        return {"X":parseFloat(res[1],10),"XUnit":res[2], "Y":parseFloat(res[3],10), "YUnit":res[4]};
    }
    function interpolate(start, end, step) {
        return ((1 - step) * start) + (step * end);
    }
    function stop($elem, animatingAxis) {
        var intv = $elem.data("animationInterval"+animatingAxis) || null;
        if (!intv) { return null; }
        clearInterval(intv);
        $elem.data()["animationInterval"+animatingAxis] = intv = null;
        return true;
    }
    function animate($elem, animatingAxis, end, unit, data) {
        var start = data[animatingAxis], interval = $.fx.interval || 13, step = 0.0, steps = 200/interval, perStep = 1/steps, staticPos = data[oppositeAxis[animatingAxis]]+data[oppositeAxis[animatingAxis]+"Unit"];
        var calcPositions = (animatingAxis==="X")?function() {return interpolate(start, end, step) + unit + " "+ staticPos;}:function() {return staticPos + " "+ interpolate(start, end, step)+unit;};
        stop($elem, animatingAxis,staticPos, end, unit);
        $elem.data("animationInterval"+animatingAxis, setInterval(function(){
            if (step >= 1.0) {
                //interpolation can be inaccurate, so we manually set the end position when we're done and close enough
                $elem.css("background-position", (animatingAxis==="Y" ? staticPos : end+unit)+" "+(animatingAxis==="X" ? staticPos : end+unit));
                return stop($elem, animatingAxis, staticPos, end, unit);
            } else {
               $elem.css("background-position", calcPositions());
            }
            step = step + perStep;
        }, interval));
    }
    $.namespace('dr', {
        //offsets should be converted to actual values
        bgAnimate: function(animatingAxis, opts) {
            animatingAxis = animatingAxis.toUpperCase();
            var bp = $(this).css("background-position");
            bp = (!bp || bp.split(" ").length === 4) ? $(this).css("background-position-x") +" "+ $(this).css("background-position-y") : bp;
            var data = getBackgroundData(bp);
            animate($(this), animatingAxis, (opts.offset ? data[animatingAxis] + opts.offset : opts.end), data[animatingAxis+"Unit"], data);
        }
    });
})(jQuery);

;(function($){

	$.namespace('dr.button', {
	
		disable: function(buttonText){
			var simpleDisable = (buttonText===false) ? true : false;
			if (!simpleDisable && typeof $.dr.processingDialog == 'object') {
				$.dr.processingDialog.disable();
			}
			return this.each(function(){
				if (this.tagName.toLowerCase() == 'button') {
					if(!simpleDisable){
						var $button = $(this);
						if(!$button.data('originalText')){
							$button.data('originalText', $button.text());
						}
						var text = (buttonText) ? buttonText : ($button.hasClass('search')) ? $.dr.strings.SEARCHING : ($button.hasClass('login')) ? $.dr.strings.AUTHORIZING : $.dr.strings.PROCESSING;
						$button.html('<span><span><span>' + text + '</span></span></span>').addClass("processing");
					}
					this.disabled = true;
				}
			});
		},
		
		enable: function(){
			return this.each(function(){
				var $button = $(this);
				var originalText = $button.data('originalText');
				if(originalText){
					$button.dr.button.text(originalText);
				}
				$button.removeClass("processing");
				this.disabled = false;
			});
			if (typeof $.dr.processingDialog == 'object') {
				$.dr.processingDialog.enable();
			}
		},
		
		text: function(label, oldIconCSSClass, newIconCSSClass, rightAlign){
			return this.each(function(){
				if (this.tagName.toLowerCase() == 'button') {
					var $button = $(this);
					if (rightAlign===true) {
						$button.addClass('rightAlign');
					}else if(rightAlign===false){
						$button.removeClass('rightAlign');
					}
					if(label && label.length>0){
						$button.data('originalText', label);
						$button.html('<span><span><span>' + label + '</span></span></span>');	
					}
					if (newIconCSSClass) {
						$button.removeClass(oldIconCSSClass).addClass(newIconCSSClass);
					}
				}
			});
		}
		
	});
	
})(jQuery);

(function($){
    var defaults = {
        header: ':first',
        containerCls: 'drui-collapsible-container',
        selector: '.collapsible',
        preventDefault: true,
        change: function(event, vis, options){
        }
    };
    
    /*
     * Private Methods
     */
    $.namespace('dr', {
        collapsible: function(cOptions){
            return this.each(function(i){
				var dataOptions = $(this).attr('data-options');
				if(dataOptions && !cOptions){
					cOptions =  $.dr.utils.evalString(dataOptions);
				}
	            var options = $.extend(true, {}, defaults, cOptions);
           
				
                var self = $(this);
                if (typeof options.change === "function") {
                    $(this).bind("collapsiblechange", options.change);
                }
                $(this).data('options', options);
                $(this).find(options.header).each(function(){
                    /*
                     * Add some drui- class names to the header and container
                     */
                    $(this).addClass("drui-collapsible-header");
                    /*
                     * Treat the next sibling as the container. Add a class to the
                     * container.
                     */
                    $(this).next().addClass(options.containerCls);
                    /*
                     * Check to see if the header has the class name collapsed.
                     * If it does collapse the container and trigger the change event.
                     */
                    if ($(this).hasClass('collapsed') || $(this).hasClass('drui-collapsible-collapsed')) {
                        $(this).removeClass('collapsed');
                        $(this).parents(options.selector).dr.collapsible.collapse();
                    } else {
                        $(this).parents(options.selector).dr.collapsible.expand();
                    }
                    
                    /*
                     * Bind mouse over
                     */
                    $(this).bind("mouseover", function(){
                        $(this).addClass("dr-state-hover");
                    });
                    /*
                     * Bind mouse out
                     */
                    $(this).bind("mouseout", function(){
                        $(this).removeClass("dr-state-hover");
                    });
                    /*
                     * Bind click
                     */
                    $(this).bind("click", function(evt, obj){
                        if ($(this).hasClass('drui-collapsible-collapsed')) {
                            $(this).parents(options.selector).dr.collapsible.expand();
                        } else {
                            $(this).parents(options.selector).dr.collapsible.collapse();
                        }
                        
                        if (options.preventDefault) {
                            evt.preventDefault();
                        }
                    });
                });
            });
        }
    });
    
    /*
     * Public Methods
     */
    $.namespace('dr.collapsible', {
        collapse: function(evt){
            var options = $(this).data('options');
            if ($(options.header, this).hasClass('drui-collapsible-collapsed')) {
                return this;
            }
            $(this).trigger('collapsiblechangestart', [false, options]);
            
            if ($.browser.msie) {
                $('.' + options.containerCls, this).hide();
                $(this).parents(options.selector).trigger("collapsiblechange", [false, options]);
            } else {
                if ($(this).is(':visible')) {
                    // fix a FF 5 issue when the collapsible is not visible at page load.
                    $('.' + options.containerCls, this).slideUp("fast", function() {
                        $(this).parents(options.selector).trigger("collapsiblechange", [false, options]);
                    });                     
                } else {
                    $('.' + options.containerCls, this).hide();
                    $(this).parents(options.selector).trigger("collapsiblechange", [false, options]);                    
                }
            }
            
            $(options.header, this).addClass('drui-collapsible-collapsed').removeClass('drui-collapsible-active');
            
            return this;
        },
        expand: function(evt){
            var options = $(this).data('options');
            if ($(options.header, this).hasClass('drui-collapsible-active')) {
                return this;
            }
            $(this).trigger('collapsiblechangestart', [true, options]);
            
            if ($.browser.msie) {
	            $('.' + options.containerCls, this).show();
                $(this).parents(options.selector).trigger("collapsiblechange", [true, options])                
            } else {
                if ($(this).is(':visible')) {
                    $('.' + options.containerCls, this).slideDown("fast", function(){
                        $(this).parents(options.selector).trigger("collapsiblechange", [true, options]);
                    });                    
                } else {
	                $('.' + options.containerCls, this).show();
                    $(this).parents(options.selector).trigger("collapsiblechange", [true, options])                     
                }
            }

            $(options.header, this).removeClass('drui-collapsible-collapsed').addClass('drui-collapsible-active');
            
            return this;
        },
        toggle: function(vis){
            if (!!vis) {
                this.dr.collapsible.expand();
            } else {
                this.dr.collapsible.collapse();
            }
        }
    });  
    var initCollapsible = function(evt, context){
        $('.collapsible', context).dr.collapsible();
    };
    
    $.dr.addUnobtrusiveEvent(initCollapsible, 'unobtrusiveEventEarly');
})(jQuery);
/**
 *
 * Color picker
 * Author: Stefan Petre www.eyecon.ro
 * 
 * Dual licensed under the MIT and GPL licenses
 * 
 */
(function ($) {
	var ColorPicker = function () {
		var
			ids = {},
			inAction,
			charMin = 65,
			visible,
			tpl = '<div class="colorpicker"><div class="colorpicker_color"><div><div></div></div></div><div class="colorpicker_hue"><div></div></div><div class="colorpicker_new_color"></div><div class="colorpicker_current_color"></div><div class="colorpicker_hex"><input type="text" maxlength="6" size="6" /></div><div class="colorpicker_rgb_r colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_g colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_h colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_s colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_submit"></div></div>',
			defaults = {
				eventName: 'click',
				onShow: function () {},
				onBeforeShow: function(){},
				onHide: function () {},
				onChange: function () {},
				onSubmit: function () {},
				color: 'ffffff',
				livePreview: true,
				flat: false
			},
			fillRGBFields = function  (hsb, cal) {
				var rgb = HSBToRGB(hsb);
				$(cal).data('colorpicker').fields
					.eq(1).val(rgb.r).end()
					.eq(2).val(rgb.g).end()
					.eq(3).val(rgb.b).end();
			},
			fillHSBFields = function  (hsb, cal) {
				$(cal).data('colorpicker').fields
					.eq(4).val(hsb.h).end()
					.eq(5).val(hsb.s).end()
					.eq(6).val(hsb.b).end();
			},
			fillHexFields = function (hsb, cal) {
				$(cal).data('colorpicker').fields
					.eq(0).val(HSBToHex(hsb)).end();
			},
			setSelector = function (hsb, cal) {
				$(cal).data('colorpicker').selector.css('backgroundColor', '#' + HSBToHex({h: hsb.h, s: 100, b: 100}));
				$(cal).data('colorpicker').selectorIndic.css({
					left: parseInt(150 * hsb.s/100, 10),
					top: parseInt(150 * (100-hsb.b)/100, 10)
				});
			},
			setHue = function (hsb, cal) {
				$(cal).data('colorpicker').hue.css('top', parseInt(150 - 150 * hsb.h/360, 10));
			},
			setCurrentColor = function (hsb, cal) {
				$(cal).data('colorpicker').currentColor.css('backgroundColor', '#' + HSBToHex(hsb));
			},
			setNewColor = function (hsb, cal) {
				$(cal).data('colorpicker').newColor.css('backgroundColor', '#' + HSBToHex(hsb));
			},
			keyDown = function (ev) {
				var pressedKey = ev.charCode || ev.keyCode || -1;
				if ((pressedKey > charMin && pressedKey <= 90) || pressedKey == 32) {
					return false;
				}
				var cal = $(this).parent().parent();
				if (cal.data('colorpicker').livePreview === true) {
					change.apply(this);
				}
			},
			change = function (ev) {
				var cal = $(this).parent().parent(), col;
				if (this.parentNode.className.indexOf('_hex') > 0) {
					cal.data('colorpicker').color = col = HexToHSB(fixHex(this.value));
				} else if (this.parentNode.className.indexOf('_hsb') > 0) {
					cal.data('colorpicker').color = col = fixHSB({
						h: parseInt(cal.data('colorpicker').fields.eq(4).val(), 10),
						s: parseInt(cal.data('colorpicker').fields.eq(5).val(), 10),
						b: parseInt(cal.data('colorpicker').fields.eq(6).val(), 10)
					});
				} else {
					cal.data('colorpicker').color = col = RGBToHSB(fixRGB({
						r: parseInt(cal.data('colorpicker').fields.eq(1).val(), 10),
						g: parseInt(cal.data('colorpicker').fields.eq(2).val(), 10),
						b: parseInt(cal.data('colorpicker').fields.eq(3).val(), 10)
					}));
				}
				if (ev) {
					fillRGBFields(col, cal.get(0));
					fillHexFields(col, cal.get(0));
					fillHSBFields(col, cal.get(0));
				}
				setSelector(col, cal.get(0));
				setHue(col, cal.get(0));
				setNewColor(col, cal.get(0));
				cal.data('colorpicker').onChange.apply(cal, [col, HSBToHex(col), HSBToRGB(col)]);
			},
			blur = function (ev) {
				var cal = $(this).parent().parent();
				cal.data('colorpicker').fields.parent().removeClass('colorpicker_focus');
			},
			focus = function () {
				charMin = this.parentNode.className.indexOf('_hex') > 0 ? 70 : 65;
				$(this).parent().parent().data('colorpicker').fields.parent().removeClass('colorpicker_focus');
				$(this).parent().addClass('colorpicker_focus');
			},
			downIncrement = function (ev) {
				var field = $(this).parent().find('input').focus();
				var current = {
					el: $(this).parent().addClass('colorpicker_slider'),
					max: this.parentNode.className.indexOf('_hsb_h') > 0 ? 360 : (this.parentNode.className.indexOf('_hsb') > 0 ? 100 : 255),
					y: ev.pageY,
					field: field,
					val: parseInt(field.val(), 10),
					preview: $(this).parent().parent().data('colorpicker').livePreview					
				};
				$(document).bind('mouseup', current, upIncrement);
				$(document).bind('mousemove', current, moveIncrement);
			},
			moveIncrement = function (ev) {
				ev.data.field.val(Math.max(0, Math.min(ev.data.max, parseInt(ev.data.val + ev.pageY - ev.data.y, 10))));
				if (ev.data.preview) {
					change.apply(ev.data.field.get(0), [true]);
				}
				return false;
			},
			upIncrement = function (ev) {
				change.apply(ev.data.field.get(0), [true]);
				ev.data.el.removeClass('colorpicker_slider').find('input').focus();
				$(document).unbind('mouseup', upIncrement);
				$(document).unbind('mousemove', moveIncrement);
				return false;
			},
			downHue = function (ev) {
				var current = {
					cal: $(this).parent(),
					y: $(this).offset().top
				};
				current.preview = current.cal.data('colorpicker').livePreview;
				$(document).bind('mouseup', current, upHue);
				$(document).bind('mousemove', current, moveHue);
			},
			moveHue = function (ev) {
				change.apply(
					ev.data.cal.data('colorpicker')
						.fields
						.eq(4)
						.val(parseInt(360*(150 - Math.max(0,Math.min(150,(ev.pageY - ev.data.y))))/150, 10))
						.get(0),
					[ev.data.preview]
				);
				return false;
			},
			upHue = function (ev) {
				fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				$(document).unbind('mouseup', upHue);
				$(document).unbind('mousemove', moveHue);
				return false;
			},
			downSelector = function (ev) {
				var current = {
					cal: $(this).parent(),
					pos: $(this).offset()
				};
				current.preview = current.cal.data('colorpicker').livePreview;
				$(document).bind('mouseup', current, upSelector);
				$(document).bind('mousemove', current, moveSelector);
			},
			moveSelector = function (ev) {
				change.apply(
					ev.data.cal.data('colorpicker')
						.fields
						.eq(6)
						.val(parseInt(100*(150 - Math.max(0,Math.min(150,(ev.pageY - ev.data.pos.top))))/150, 10))
						.end()
						.eq(5)
						.val(parseInt(100*(Math.max(0,Math.min(150,(ev.pageX - ev.data.pos.left))))/150, 10))
						.get(0),
					[ev.data.preview]
				);
				return false;
			},
			upSelector = function (ev) {
				fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
				$(document).unbind('mouseup', upSelector);
				$(document).unbind('mousemove', moveSelector);
				return false;
			},
			enterSubmit = function (ev) {
				$(this).addClass('colorpicker_focus');
			},
			leaveSubmit = function (ev) {
				$(this).removeClass('colorpicker_focus');
			},
			clickSubmit = function (ev) {
				var cal = $(this).parent();
				var col = cal.data('colorpicker').color;
				cal.data('colorpicker').origColor = col;
				setCurrentColor(col, cal.get(0));
				cal.data('colorpicker').onSubmit(col, HSBToHex(col), HSBToRGB(col), cal.data('colorpicker').el);
			},
			show = function (ev) {
				var cal = $('#' + $(this).data('colorpickerId'));
				cal.data('colorpicker').onBeforeShow.apply(this, [cal.get(0)]);
				var pos = $(this).offset();
				var viewPort = getViewport();
				var top = pos.top + this.offsetHeight;
				var left = pos.left;
				if (top + 176 > viewPort.t + viewPort.h) {
					top -= this.offsetHeight + 176;
				}
				if (left + 356 > viewPort.l + viewPort.w) {
					left -= 356;
				}
				cal.css({left: left + 'px', top: top + 'px'});
				if (cal.data('colorpicker').onShow.apply(this, [cal.get(0)]) != false) {
					cal.show();
				}
				$(document).bind('mousedown', {cal: cal}, hide);
				return false;
			},
			hide = function (ev) {
				if (!isChildOf(ev.data.cal.get(0), ev.target, ev.data.cal.get(0), ev.data.cal)) {
					if (ev.data.cal.data('colorpicker').onHide.apply(this, [ev.data.cal.get(0)]) != false) {
						ev.data.cal.hide();
					}
					$(document).unbind('mousedown', hide);
				}
			},
			isChildOf = function(parentEl, el, container, cal) {
				if (parentEl == el) {
					return true;
				}else if(el == cal.data('colorpicker').el){
					return true;
				}else if($(el).parent('.colorPickerSample').length>0){
					return true;
				}else if (parentEl.contains) {
					return parentEl.contains(el);
				}else if ( parentEl.compareDocumentPosition ) {
					return !!(parentEl.compareDocumentPosition(el) & 16);
				}
				var prEl = el.parentNode;
				while(prEl && prEl != container) {
					if (prEl == parentEl)
						return true;
					prEl = prEl.parentNode;
				}
				return false;
			},
			getViewport = function () {
				var m = document.compatMode == 'CSS1Compat';
				return {
					l : window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),
					t : window.pageYOffset || (m ? document.documentElement.scrollTop : document.body.scrollTop),
					w : window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth),
					h : window.innerHeight || (m ? document.documentElement.clientHeight : document.body.clientHeight)
				};
			},
			fixHSB = function (hsb) {
				return {
					h: Math.min(360, Math.max(0, hsb.h)),
					s: Math.min(100, Math.max(0, hsb.s)),
					b: Math.min(100, Math.max(0, hsb.b))
				};
			}, 
			fixRGB = function (rgb) {
				return {
					r: Math.min(255, Math.max(0, rgb.r)),
					g: Math.min(255, Math.max(0, rgb.g)),
					b: Math.min(255, Math.max(0, rgb.b))
				};
			},
			fixHex = function (hex) {
				var len = 6 - hex.length;
				if (len > 0) {
					var o = [];
					for (var i=0; i<len; i++) {
						o.push('0');
					}
					o.push(hex);
					hex = o.join('');
				}
				return hex;
			}, 
			HexToRGB = function (hex) {
				var hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
				return {r: hex >> 16, g: (hex & 0x00FF00) >> 8, b: (hex & 0x0000FF)};
			},
			HexToHSB = function (hex) {
				return RGBToHSB(HexToRGB(hex));
			},
			RGBToHSB = function (rgb) {
				var hsb = {
					h: 0,
					s: 0,
					b: 0
				};
				var min = Math.min(rgb.r, rgb.g, rgb.b);
				var max = Math.max(rgb.r, rgb.g, rgb.b);
				var delta = max - min;
				hsb.b = max;
				if (max != 0) {
					
				}
				hsb.s = max != 0 ? 255 * delta / max : 0;
				if (hsb.s != 0) {
					if (rgb.r == max) {
						hsb.h = (rgb.g - rgb.b) / delta;
					} else if (rgb.g == max) {
						hsb.h = 2 + (rgb.b - rgb.r) / delta;
					} else {
						hsb.h = 4 + (rgb.r - rgb.g) / delta;
					}
				} else {
					hsb.h = -1;
				}
				hsb.h *= 60;
				if (hsb.h < 0) {
					hsb.h += 360;
				}
				hsb.s *= 100/255;
				hsb.b *= 100/255;
				return hsb;
			},
			HSBToRGB = function (hsb) {
				var rgb = {};
				var h = Math.round(hsb.h);
				var s = Math.round(hsb.s*255/100);
				var v = Math.round(hsb.b*255/100);
				if(s == 0) {
					rgb.r = rgb.g = rgb.b = v;
				} else {
					var t1 = v;
					var t2 = (255-s)*v/255;
					var t3 = (t1-t2)*(h%60)/60;
					if(h==360) h = 0;
					if(h<60) {rgb.r=t1;	rgb.b=t2; rgb.g=t2+t3}
					else if(h<120) {rgb.g=t1; rgb.b=t2;	rgb.r=t1-t3}
					else if(h<180) {rgb.g=t1; rgb.r=t2;	rgb.b=t2+t3}
					else if(h<240) {rgb.b=t1; rgb.r=t2;	rgb.g=t1-t3}
					else if(h<300) {rgb.b=t1; rgb.g=t2;	rgb.r=t2+t3}
					else if(h<360) {rgb.r=t1; rgb.g=t2;	rgb.b=t1-t3}
					else {rgb.r=0; rgb.g=0;	rgb.b=0}
				}
				return {r:Math.round(rgb.r), g:Math.round(rgb.g), b:Math.round(rgb.b)};
			},
			RGBToHex = function (rgb) {
				var hex = [
					rgb.r.toString(16),
					rgb.g.toString(16),
					rgb.b.toString(16)
				];
				$.each(hex, function (nr, val) {
					if (val.length == 1) {
						hex[nr] = '0' + val;
					}
				});
				return hex.join('');
			},
			HSBToHex = function (hsb) {
				return RGBToHex(HSBToRGB(hsb));
			},
			restoreOriginal = function () {
				var cal = $(this).parent();
				var col = cal.data('colorpicker').origColor;
				cal.data('colorpicker').color = col;
				fillRGBFields(col, cal.get(0));
				fillHexFields(col, cal.get(0));
				fillHSBFields(col, cal.get(0));
				setSelector(col, cal.get(0));
				setHue(col, cal.get(0));
				setNewColor(col, cal.get(0));
			};
		return {
			init: function (opt) {
				opt = $.extend({}, defaults, opt||{});
				if (typeof opt.color == 'string') {
					opt.color = HexToHSB(opt.color);
				} else if (opt.color.r != undefined && opt.color.g != undefined && opt.color.b != undefined) {
					opt.color = RGBToHSB(opt.color);
				} else if (opt.color.h != undefined && opt.color.s != undefined && opt.color.b != undefined) {
					opt.color = fixHSB(opt.color);
				} else {
					return this;
				}
				return this.each(function () {
					if (!$(this).data('colorpickerId')) {
						var options = $.extend({}, opt);
						options.origColor = opt.color;
						var id = 'collorpicker_' + parseInt(Math.random() * 1000);
						$(this).data('colorpickerId', id);
						var cal = $(tpl).attr('id', id);
						if (options.flat) {
							cal.appendTo(this).show();
						} else {
							cal.appendTo(document.body);
						}
						options.fields = cal
											.find('input')
												.bind('keyup', keyDown)
												.bind('change', change)
												.bind('blur', blur)
												.bind('focus', focus);
						cal
							.find('span').bind('mousedown', downIncrement).end()
							.find('>div.colorpicker_current_color').bind('click', restoreOriginal);
						options.selector = cal.find('div.colorpicker_color').bind('mousedown', downSelector);
						options.selectorIndic = options.selector.find('div div');
						options.el = this;
						options.hue = cal.find('div.colorpicker_hue div');
						cal.find('div.colorpicker_hue').bind('mousedown', downHue);
						options.newColor = cal.find('div.colorpicker_new_color');
						options.currentColor = cal.find('div.colorpicker_current_color');
						cal.data('colorpicker', options);
						cal.find('div.colorpicker_submit')
							.bind('mouseenter', enterSubmit)
							.bind('mouseleave', leaveSubmit)
							.bind('click', clickSubmit);
						fillRGBFields(options.color, cal.get(0));
						fillHSBFields(options.color, cal.get(0));
						fillHexFields(options.color, cal.get(0));
						setHue(options.color, cal.get(0));
						setSelector(options.color, cal.get(0));
						setCurrentColor(options.color, cal.get(0));
						setNewColor(options.color, cal.get(0));
						if (options.flat) {
							cal.css({
								position: 'relative',
								display: 'block'
							});
						} else {
							$(this).bind(options.eventName, show);
						}
					}
				});
			},
			showPicker: function() {
				return this.each( function () {
					if ($(this).data('colorpickerId')) {
						show.apply(this);
					}
				});
			},
			hidePicker: function() {
				return this.each( function () {
					if ($(this).data('colorpickerId')) {
						$('#' + $(this).data('colorpickerId')).hide();
					}
				});
			},
			setColor: function(col) {
				if (typeof col == 'string') {
					col = HexToHSB(col);
				} else if (col.r != undefined && col.g != undefined && col.b != undefined) {
					col = RGBToHSB(col);
				} else if (col.h != undefined && col.s != undefined && col.b != undefined) {
					col = fixHSB(col);
				} else {
					return this;
				}
				return this.each(function(){
					if ($(this).data('colorpickerId')) {
						var cal = $('#' + $(this).data('colorpickerId'));
						cal.data('colorpicker').color = col;
						cal.data('colorpicker').origColor = col;
						fillRGBFields(col, cal.get(0));
						fillHSBFields(col, cal.get(0));
						fillHexFields(col, cal.get(0));
						setHue(col, cal.get(0));
						setSelector(col, cal.get(0));
						setCurrentColor(col, cal.get(0));
						setNewColor(col, cal.get(0));
					}
				});
			}
		};
	}();
	
	$.fn.extend({
		ColorPicker: ColorPicker.init,
		ColorPickerHide: ColorPicker.hidePicker,
		ColorPickerShow: ColorPicker.showPicker,
		ColorPickerSetColor: ColorPicker.setColor
	});
	
	
		
	/*
	 * Public API
	 */
	$.dr.colorpicker = {
		colorNameMap: {
			"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff",
		    "beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887",
		    "cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff",
		    "darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f",
		    "darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1",
		    "darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff",
		    "firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff",
		    "gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f",
		    "honeydew":"#f0fff0","hotpink":"#ff69b4",
		    "indianred ":"#cd5c5c","indigo ":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c",
		    "lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2",
		    "lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de",
		    "lightyellow":"#ffffe0","lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6",
		    "magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee",
		    "mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5",
		    "navajowhite":"#ffdead","navy":"#000080",
		    "oldlace":"#fdf5e6","olive":"#808000","olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6",
		    "palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080",
		    "red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1",
		    "saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4",
		    "tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0",
		    "violet":"#ee82ee",
		    "wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5",
		    "yellow":"#ffff00","yellowgreen":"#9acd32"
		},

		colorNameToHex:	function (colorName){
		    var color = $.dr.colorpicker.colorNameMap[colorName.toLowerCase()];
		    if (typeof color !== 'undefined'){
		        return color.toUpperCase();
			}
		    return false;
		},
		
		isHex: function(str){
			if(!str){
				return false;
			}
			var len = str.length;
			if(len===4 || len===7){
				var val = str.trim();
				var upperCase = val.toUpperCase();
				var allowed = /^#(\d{3})|^#([A-F]|[0-9]){3}|^#(\d{6})|^#([A-F]{6})|^#([A-F]|[0-9]){6}/;
				return (allowed.test(upperCase)==1)
			}else{
				return false;
			}
		}

	};
	
	/*
	 * Beacon code
	 */
	
	function checkFieldValueChanged(el){
		var lastValue = $(el).data('lastValue');
		var currentValue = $(el).val();
		if(lastValue!=currentValue){
			$(el).trigger('change');
			$(el).data( 'lastValue', currentValue );
		}
	}
	 

	$.namespace('dr',{
		colorPicker: function() {
			return this.each(function(){
				if (this.type=='text'){
					if(!$(this).hasClass('colorPicker_inited')){
						$(this).addClass('colorPicker');
						initColorPickers($(this));
					}
				}
			});
		}
	});
		
	var initColorPickers = function($fields) {
		var $pickers = $fields.filter("input.colorPicker:not('.colorPicker_inited')");
		$pickers.each(function(){
			
			var field = this;
			
			$(field).ColorPicker({
				onHide: function(){
					checkFieldValueChanged(field);
				},
				onSubmit: function(hsb, hex, rgb, el) {
					$(el).val('#'+hex.toUpperCase());
					$(el).ColorPickerHide();
					checkFieldValueChanged(field);
					setTimeout(function(){$(document).unbind('mousedown', ColorPicker.hide);},0);
				},
				onBeforeShow: function () {
					$('body > div.colorpicker').hide();
					$(this).ColorPickerSetColor(this.value);
				},
				onChange: function(hsb, hex, rgb){
					$(field).val("#" + hex.toUpperCase());
					$(field).next().children(":first-child").css("backgroundColor","#"+hex);
				}
			});
			
			$(field).change(function(){
				var color = $(this).val();
				if(!$.dr.colorpicker.isHex(color) ){
					var hexColor = $.dr.colorpicker.colorNameToHex(color);
					if(hexColor!==false){
						color = hexColor;
						this.value = color;
					}else{
						color = '#FFFFFF';
					}
				}
				$(field).next().children(":first-child").css("backgroundColor",color);
			});
			
			// normalizes hex values
			var color = $(this).val().trim();
			
			// check if current value is missing a hash character
			if(color.length && color.indexOf('#')===-1){
				if($.dr.colorpicker.isHex('#'+color)){
					color = '#'+color;
					$(this).val(color.toUpperCase());
				}
			}

			if(!$.dr.colorpicker.isHex(color)){
				// check for named color, such as 'white' or 'red'
				var hexColor = $.dr.colorpicker.colorNameToHex(color);
				if(hexColor!==false){
					color = hexColor;
					$(this).val(hexColor.toUpperCase());
				}else{
					color = 'transparent';
				}
				
			}else{
				if(color.length==4){
					var c = color.split('');
					color = '#' + c[1] + c[1] + c[2] + c[2] + c[3] + c[3];
				}
				$(this).val(color.toUpperCase());
			}
			var currentValue = $(this).val();
			
			//prevent change checker from firing due to normalization.
			this.defaultValue = currentValue;
			
			// store the current value, used when color picker has been opened and then closed
			// to see if the hex value changed and that we need to update UI preview
			$(this).data( 'lastValue', currentValue );
			
			// add a color "handle" next to input
			$(this).after("<div class='colorPickerSample'><div style=background-color:" + color + "></div></div>");

			// bind click to handle
			$(this).next().bind("click",function(e){
				$(field).focus().trigger("click");
				//e.stopImmediatePropagation();
			}).after("<span class='hint'>#000000</span>");
			
			if ($.browser.webkit) {
				$(this).next().css("marginTop","2px");
			}
			
		
		}).addClass('colorPicker_inited');

	}
	
	$.dr.addPlugin('form', initColorPickers);
	
	
})(jQuery)


;(function($) {
	/******************************************************************************
	* Date Picker<br />
	* Usage: <code>$('#myInputId').dr.datePicker();</code>
	* @author scollings,dpease
	*****************************************************************************/
			
	// CLASS PROPERTIES *************************************************************/
	var WEEK_START_DAY = 0, // 0 = Sunday, 1 = Monday
		ANY_DATE_PICKERS_OPEN=false;
	
	// OVERRIDABLE PROPERTIES *************************************************************/
	var defaults = {
		cssClassDate: "date",
		cssClassTodaysDate: "todaysDate",
		cssClassDisplayDateClass: "displayDate",
		cssClassDisplayMonthDate: "displayMonthDate",
		cssClassOtherMonthDate: "otherMonthDate",
		yearSelectOffset: 4, // number of years before and after current to display in year dropdown
		defaultText: "\u65E5\u5386"
	}
	
	// LEGACY TOKEN MAPPINGS *************************************************************/
	var legacyMappings = {
		CSS_CLASS_DATE: 				"cssClassDate",
		CSS_CLASS_TODAYS_DATE: 			"cssClassTodaysDate",
		CSS_CLASS_DISPLAY_DATE_CLASS: 	"cssClassDisplayDateClass",
		CSS_CLASS_DISPLAY_MONTH_DATE: 	"cssClassDisplayMonthDate",
		CSS_CLASS_OTHER_MONTH_DATE: 	"cssClassOtherMonthDate",
		YEAR_SELECT_OFFSET: 			"yearSelectOffset",
		DEFAULT_TEXT: 					"defaultText"
	}
	
	// Localizeable Properties **********************************************************/
	/*
	var JANUARY = "January",
		FEBRUARY = "February",
		MARCH = "March",
		APRIL = "April",
		MAY = "May",
		JUNE = "June",
		JULY = "July",
		AUGUST = "August",
		SEPTEMBER = "September",
		OCTOBER = "October",
		NOVEMBER = "November",
		DECEMBER = "December",
		
		JANUARY_ABBRV = "Jan",
		FEBRUARY_ABBRV = "Feb",
		MARCH_ABBRV = "Mar",
		APRIL_ABBRV = "Apr",
		MAY_ABBRV = "May",
		JUNE_ABBRV = "Jun",
		JULY_ABBRV = "Jul",
		AUGUST_ABBRV = "Aug",
		SEPTEMBER_ABBRV = "Sep",
		OCTOBER_ABBRV = "Oct",
		NOVEMBER_ABBRV = "Nov",
		DECEMBER_ABBRV = "Dec",
		
		SUNDAY_ABBRV = "S",
		MONDAY_ABBRV = "M",
		TUESDAY_ABBRV = "T",
		WEDNESDAY_ABBRV = "W",
		THURSDAY_ABBRV = "T",
		FRIDAY_ABBRV = "F",
		SATURDAY_ABBRV = "S",
		TODAY = "Go to Today's Date";
	
	
	*/
	
	var JANUARY = "\u4E00\u6708",
		FEBRUARY = "\u4E8C\u6708",
		MARCH = "\u4E09\u6708",
		APRIL = "\u56DB\u6708",
		MAY = "\u4E94\u6708",
		JUNE = "\u516D\u6708",
		JULY = "\u4E03\u6708",
		AUGUST = "\u516B\u6708",
		SEPTEMBER = "\u4E5D\u6708",
		OCTOBER = "\u5341\u6708",
		NOVEMBER = "\u5341\u4E00\u6708",
		DECEMBER = "\u5341\u4E8C\u6708",
		JANUARY_ABBRV = "\u4E00\u6708",
		FEBRUARY_ABBRV = "\u4E8C\u6708",
		MARCH_ABBRV = "\u4E09\u6708",
		APRIL_ABBRV = "\u56DB\u6708",
		MAY_ABBRV = "\u4E94\u6708",
		JUNE_ABBRV = "\u516D\u6708",
		JULY_ABBRV = "\u4E03\u6708",
		AUGUST_ABBRV = "\u516B\u6708",
		SEPTEMBER_ABBRV = "\u4E5D\u6708",
		OCTOBER_ABBRV = "\u5341\u6708",
		NOVEMBER_ABBRV = "\u5341\u4E00\u6708",
		DECEMBER_ABBRV = "\u5341\u4E8C\u6708",
		SUNDAY_ABBRV = "\u661F\u671F\u65E5",
		MONDAY_ABBRV = "\u661F\u671F\u4E00",
		TUESDAY_ABBRV = "\u661F\u671F\u4E8C",
		WEDNESDAY_ABBRV = "\u661F\u671F\u4E09",
		THURSDAY_ABBRV = "\u661F\u671F\u56DB",
		FRIDAY_ABBRV = "\u661F\u671F\u4E94",
		SATURDAY_ABBRV = "\u661F\u671F\u516D",
		TODAY = "\u8DF3\u8F6C\u5230\u4ECA\u65E5\u65E5\u671F";

	var MONTH_NAMES = [JANUARY,FEBRUARY,MARCH,APRIL,MAY,JUNE,JULY,AUGUST,SEPTEMBER,OCTOBER,NOVEMBER,DECEMBER],
		MONTH_ABBREVIATIONS = [JANUARY_ABBRV,FEBRUARY_ABBRV,MARCH_ABBRV,APRIL_ABBRV,MAY_ABBRV,JUNE_ABBRV,JULY_ABBRV,AUGUST_ABBRV,SEPTEMBER_ABBRV,OCTOBER_ABBRV,NOVEMBER_ABBRV,DECEMBER_ABBRV],
		DAY_HEADERS = [SUNDAY_ABBRV,MONDAY_ABBRV,TUESDAY_ABBRV,WEDNESDAY_ABBRV,THURSDAY_ABBRV,FRIDAY_ABBRV,SATURDAY_ABBRV];
	
	// this code should be moved to LocalizedDate.js	
	$.dr.date.getMonthName = function(i){
		return MONTH_NAMES[i];
	}
	
	$.dr.date.getMonthAbbr = function(i){
		return MONTH_ABBREVIATIONS[i];
	}
	
	$.dr.date.getDayAbbr = function(i){
		return DAY_HEADERS[i];
	}
	
	// CLASS METHODS *************************************************************/

	var datePicker = function(pickerObjId, fObj, _label, dateFormat){

		/*
		 *  The globally accessible javascript object, as a string
		 */
		this.pickerObjId = pickerObjId;

		/*
		 *  Setup the events and display for the date picker
		 */
		this.init(fObj, _label, dateFormat);

	};


	// INSTANCE METHODS **********************************************************/
	datePicker.prototype = {
	
		/******************************************************************************
		* Initialize date picker.  Draw the picker offscreen so it can be shown later.
		* @private
		*****************************************************************************/
		init: function(fObj, _label, dateFormat ) {

			/*
			 * Detect if an ID was passed in or an HTMLInputObject
			 */
			if(typeof fObj == 'string'){
				this.inputId = fObj;
				this.inputObj = $('#'+fObj)[0];
			}else{
				if(fObj.getAttribute('datePickerId')){
					this.inputId =  fObj.getAttribute('datePickerId');
				}else{
					this.inputId = fObj.id;
				}
				this.inputObj = fObj;
			}
			
			if(this.inputObj===null){
				return;
			}
			
			// Optional argument to override the user's locale
			this.dateFormat = (dateFormat) ? dateFormat : $.dr.date.getDefaultFormat();

			/*
			 * This shows up as the title of the overlay
			 */
			this._label = (_label) ? _label.replace(":","") : defaults.defaultText;
			
			
			/*
			 * The picker icon that shows up next to the input
			 */
			this.pickerIcon = null;
			this.pickerIconId = this.inputId + "_icon";
			
			/*
			 * The ID of the picker object itself, used when toggling the visibility
			 */

			this.popupId = "picker_"+this.inputId;
			this.popupObj = null;
			
			/*
			 * Internal properties
			 */
			this.contentArea = null;
			this.calendarArea = null;
			this.menuArea = null;
			this.overlay = null;
			this.todaysDate = null;
			this.todaysMonth = null;
			this.todaysDay = null;
			this.todaysYear = null;
			this.displayMonth = null;
			this.displayDay = null;
			this.displayYear = null;
			this.displayDateOffset = null;
			this.inputFieldMonth = null;
			this.inputFieldDay = null;
			this.inputFieldYear = null;
			this.currentMonthHasTodaysDate = false;
			this.hasInputFieldValue = false;
			this.menuBuilt = false;
			this.menuMonthSelect = null;
			this.menuYearSelect = null;
			
			/*
			 * Array of total days in each month (starting with index[1])
			 */ 
			this.numDaysInMonth = [0,31,28,31,30,31,30,31,31,30,31,30,31];

			this.setTodaysDate();
			this.attachIcon();
		},
		
		/******************************************************************************
		* Adds the calendar 
		* @private
		******************************************************************************/
		attachIcon: function(){
			if(!$(this.inputObj).hasClass('Enabled')){
			
				/*
				 * Find the inputs parent element
				 */
				var parentObj = this.inputObj.parentNode;
				var parentFound = false;
				while(!parentFound){
					if ((parentObj.tagName == "BODY") || (parentObj.tagName == "HTML")){
						break;
					}
						
					if(parentObj.tagName=="DIV" || parentObj.tagName=="DD" || parentObj.tagName == 'TD'){
						parentFound=true;
					}else{
						parentObj = parentObj.parentNode;
					}
				}
				
				/*
				 * Check if there is a date picker icon - a DIV with class of handle or datePickerHandle
				 */
				var divs = parentObj.getElementsByTagName('div');
				var divFound = false;
				var pickerIcon = null;
				if(divs.length>0){
					if($(divs[0]).hasClass('Handle')){
						this.pickerIcon=divs[0];
					}
				}
				
				if(this.pickerIcon===null){
					var d = document.createElement('div');
					d.innerHTML = "&nbsp;";
					d.className = 'datePickerHandle';
					d.id = this.pickerIconId;
					var oSelf = this;
					var func = function(evt){
						oSelf.toggle(evt);
					}
					$(d).click(func);
					$(this.inputObj).click(func);
					//DR.Utils.addEvent(d,'click',func);
					//DR.Utils.addEvent(this.inputObj,'click',func);
	
					this.pickerIcon = $(d).insertAfter(this.inputObj);
				}
				
				/*
				 * Check if format example exists - a SPAN with class of hint
				 */
				var spans = parentObj.getElementsByTagName('span');
				var spanFound = false;
				if(spans.length>0){
					if($(spans[0]).hasClass('hint')){
						spanFound=true;
					}
				}
				
				if(!spanFound){
					var s = document.createElement('span');
					s.className = 'hint';
					var todayDate = new $.dr.date(new Date(),this.dateFormat);
					s.innerHTML = this.dateFormat + ' (' + todayDate.toFormattedString() + ')';
					s.title = s.innerHTML;
					$(s).insertAfter(this.pickerIcon);
				}
				
				$(this.inputObj).addClass('datePickerEnabled').attr('autocomplete','off');
			}
		},

		/******************************************************************************
		* Shows/hides the date picker
		* @param {Event} evt
		* @param {String} inputId
		* @param {String} xPosition
		* @param {String} xDrawingDirection
		* @param {String} yPosition
		* @param {String} yDrawingDirection
		* @param {String} xOffset
		* @param {String} yOffset
		*****************************************************************************/
		toggle: function(evt, inputId) {
			
			if(this.contentArea===null){
				var contentArea = document.getElementById(this.popupId);
				if(contentArea===null){
					/*
					 * Create div to place content into
					 */ 
					var bodyObj = document.getElementsByTagName("body")[0];
					var d = document.createElement("DIV");
						d.id =  this.popupId;
						d.className = "datePickerContent";
					this.contentArea = bodyObj.appendChild(d)
	
					/*
					 * Create div to place calendar menu into
					 */ 
					var d = document.createElement("DIV");
						d.id = "menuArea_"+this.popupId;
					this.menuArea = this.contentArea.appendChild(d)
					
					/*
					 * Create div to place calendar table into
					 */ 
					var d = document.createElement("DIV");
						d.id = "calendarArea_"+this.popupId;
						d.className = 'calendarArea';
					this.calendarArea = this.contentArea.appendChild(d)
				}else{
					/*
					 * The date picker already exists, so reference the existing objects.
					 */
					this.contentArea = contentArea;
					this.menuArea =  document.getElementById("menuArea_"+this.popupId);
					this.calendarArea =  document.getElementById("calendarArea_"+this.popupId);
				}
			}

			if(this.popupObj===null)
			{
				this.show(evt);
			}else{
				if(this.popupObj.display == "block") {
					this.hide();
				} else {
					this.show(evt);
				}
			}

		},		
		/******************************************************************************
		* Shows the date picker
		* @param {Event} evt
		* @param {String} inputId
		* @param {String} xPosition
		* @param {String} xDrawingDirection
		* @param {String} yPosition
		* @param {String} yDrawingDirection
		* @param {String} xOffset
		* @param {String} yOffset
		*****************************************************************************/
		show: function(evt) {
			ANY_DATE_PICKERS_OPEN = true;
			//DR.Utils.Toggle.setVisibility(this.popupObj, true);
			
			// Don't display the date picker if the input field is disabled
			if (this.inputObj.disabled) {
				return;
			}
			
			var oSelf=this;
			var func = function(evt){
				oSelf.shouldHide(evt);
			};
			this.shouldHideFunc = func;
			$(document).click(func);
			
			this.setInputFieldDate();
			
			this.refreshCalendar();

			this.showPopup();
			
			var shadowRight = this.overlay.shadowRight;
			var shadowBottom = this.overlay.shadowBottom;
			var _offsetX = -(shadowRight/2);
			var _offsetY = 0;
			if($.browser.msie && parseInt($.browser.version,10) < 7){
				/*
				 * IE6 currently only has a shadow on right and bottom, so we don't
				 * need to offset anything
				 */
				_offsetX = 0;
				_offsetY = 2;
			}
			

			var edgeX = 'Left';
			var edgeY = 'Bottom';
			var drawDirectionX = "Right";
			var drawDirectionY = "Down";
			DR.Utils.Position.snapTo(this.inputObj,this.popupObj, _offsetX, _offsetY, edgeX, edgeY, drawDirectionX, drawDirectionY);
		},
		
		shouldHide: function(evt) {
			var o = evt.target;

			// when the "Go to Today's date" is shown, the element gets replaced, so it ends up being null
			// in this script, we can assume that we should keep it open
			var found = (o.id == this.inputId+'_todayLink') ? true : false;

			while (o){
				
				var datePickerId = (o.getAttribute) ?  o.getAttribute('datePickerId') : null;
				if( this.inputId == datePickerId){
					found = true;
					break;
				}else if(o.id !== undefined){
					// test to see if object is inside the calendar, calendar icon, or input
					if(o.id == ('modal_'+this.popupId) || o.id == this.pickerIconId || o.id == this.inputId){
						// click event happened inside the date picker
						found = true;
						break;
					}
				}
				
				o = o.parentNode;
			}

			if(!found){
				// hide the picker
				this.hide();
				$(document).unbind('click', this.shouldHide);
			}	
		},
		
		hide: function() {
			if (this.overlay!==null)
		    {
				$(document).unbind('click', this.shouldHideFunc);
				this.overlay.close();
			}
			ANY_DATE_PICKERS_OPEN=false;
		},

		showPopup: function(){
			if(!ANY_DATE_PICKERS_OPEN){
				var oSelf = this;
				var func = function(){oSelf.showPopup()};
				window.setTimeout(func,50);
			}
			else if (this.popupObj === null) {
				/*
				 * Check to see if the overlay already exists
				 */
				var overlay = overlayStack.getById(this.popupId);

				if(overlay===null)
				{

					var w = this.contentArea.offsetWidth - 10 ;
					var h = this.contentArea.offsetHeight - 10 ;
					
					/*
					 * Create a inline modal overlay 
					 */
					
					//this.overlay = new DR.Widgets.InlineModelessOverlay(this.popupId);					
					$('#'+this.popupId).dr.overlay({
						type: 'modeless',
						width: w,
						height: h,
						anchorId: this.popupId
					});
					
					this.overlay =  $('#'+this.popupId).data('overlay');

					//this.overlay.inlineDialogPadding = paddingWidth;

				}else{
					// Use the existing overlay
					this.overlay = overlay;
				}
				
				this.overlay.setTitle(this._label);
				
				/*
				 * Get a handle to the actual DIV that has just been created
				 */
				this.popupObj = $('#modal_'+this.popupId).addClass('datePickerOverlay')[0];
				this.overlay.show();
				//$(this.popupObj).insertBefore(this.inputObj);
	  	    }else{
				this.overlay.show();
			}
		},
		
		/******************************************************************************
		* Inserts localized date string into text field
		*****************************************************************************/
		updateDateInput: function(evt, year, month, day) {
		
			// update input field with date from calendar
					
			this.inputObj.value = this.getDateString(year, month, day);
			
			// call the input's onchange event if applicable
			if (typeof this.inputObj.onchange == "function") {
				this.inputObj.onchange();
			}
			// trigger any jquery change bound events
			$(this.inputObj).triggerHandler('change');
			
			// hide picker
			this.hide();

		},

		/******************************************************************************
		* @return Localized date string to insert into text field
		* @private
		*****************************************************************************/
		getDateString: function(year, month, day) {
			//@TODO - this needs to return the date in the correct format
			var date = new Date();
			date.setFullYear(year, month-1, day);
			return new $.dr.date(date,this.dateFormat).toFormattedString();
		},
		
		/******************************************************************************
		* @private
		*****************************************************************************/
		refreshCalendar: function() {

			// arguments[0] = year
			// arguments[1] = month
			// arguments[2] = day
			
			if (arguments.length == 2) {
				// make sure that the month or year changed
				if(arguments[0]!=this.displayYear || arguments[1] != this.displayMonth){
					// year and month need to be passed in
					this.calculateDisplayDate(arguments[0], arguments[1]);
					this.calculateOffset();
					this.calendarArea.innerHTML = this.writeCalendar(arguments[0], arguments[1]);
				}
			} else if (arguments.length == 3) {
				// year, month, and day need to be passed in
				this.calculateDisplayDate(arguments[0], arguments[1], arguments[2]);
				this.calculateOffset();
				this.calendarArea.innerHTML = this.writeCalendar(arguments[0], arguments[1], arguments[2]);
			} else {
				this.calculateDisplayDate();
				this.calculateOffset();
				this.calendarArea.innerHTML = this.writeCalendar();
			}
		},
		
		/******************************************************************************
		* @private
		*****************************************************************************/
		setTodaysDate: function() {
			this.todaysDate = new $.dr.date(new Date(), this.dateFormat);
			this.todaysMonth = this.todaysDate.getMonth() + 1;
			this.todaysDay = this.todaysDate.getDate();
			this.todaysYear = this.todaysDate.getFullYear();
		},
		
		/******************************************************************************
		* @private
		*****************************************************************************/
		setInputFieldDate: function() {
			this.hasInputFieldValue = false;
			if (this.inputObj !== null) {
				if (this.inputObj.value !== "") {
					var date = new $.dr.date(this.inputObj.value,this.dateFormat);
					if(date.isValid()){
						this.inputFieldMonth = date.getMonth()+1;
						this.inputFieldDay = date.getDate();
						this.inputFieldYear = date.getFullYear();
						this.hasInputFieldValue = true;
					}
				}
			}
		},
		
		loadPreviousMonth: function () {
			var month = this.displayMonth - 1;
			var year  = this.displayYear;
			if (month < 1) {
				month = 12;
				year--;
			}
			this.refreshCalendar(year,month);
		},
		
		loadNextMonth: function () {
			var month = this.displayMonth + 1;
			var year  = this.displayYear;
			if (month > 12) {
				month = 1;
				year++;
			}
			this.refreshCalendar(year,month);
		},
		
		/******************************************************************************
		* Calculates and sets the display date based on whether the date is passed in as arguments, there is a date in the input field, or else it is set to todays date.
		* @private
		*****************************************************************************/
		calculateDisplayDate: function() {
			// arguments[0] = year
			// arguments[1] = month
			// arguments[2] = day
			
			if (arguments.length > 0) {
				var day = 1;
				// pass in a year, month, day
				if (arguments.length == 3) {
					day = arguments[2];
				}
				var	date = $.dr.date.getISODate(arguments[0], arguments[1], day);
				this.displayMonth = date.getMonth()+1;
				this.displayDay = date.getDate();
				this.displayYear = date.getFullYear();
			} else if (this.inputObj) {
				if (this.inputObj.value !== "" ) {
					// use date from field
					var date = new $.dr.date(this.inputObj.value,this.dateFormat);
					
					if(date.isValid()){
						var month = date.getMonth() + 1;
						this.displayMonth = date.getMonth() + 1;
						this.displayDay = date.getDate();
						this.displayYear = date.getFullYear();
					}
							
				} else {
					// use today's date
					this.displayMonth = this.todaysMonth;
					this.displayDay = this.todaysDay;
					this.displayYear = this.todaysYear;
				}
			} else {
				// use today's date
				this.displayMonth = this.todaysMonth;
				this.displayDay = this.todaysDay;
				this.displayYear = this.todaysYear;
			}
			
			// set leap year if applicable
			if ($.dr.date.isLeapYear(this.displayYear)) {
				this.numDaysInMonth[2] = 29;
			}
		},
		
		/******************************************************************************
		* Calculates and sets the number of days before the month starts
		* @private
		*****************************************************************************/
		calculateOffset: function() {
			// day of the week the month starts on (0 - 6)
			var date = $.dr.date.getISODate(this.displayYear, this.displayMonth, 1);
			var dayOfMonthStart = date.getDay();
			// set number of days BEFORE month starts
			this.displayDateOffset = (dayOfMonthStart >= WEEK_START_DAY) ? dayOfMonthStart-WEEK_START_DAY : 7-WEEK_START_DAY+dayOfMonthStart;
		},

		/******************************************************************************
		* @private
		*****************************************************************************/
		refreshMenu: function () {
			
			if(this.menuYearSelect!==null){
				if(this.menuYearSelect.options.length==0){
					this.menuBuilt=false;
				}else{
					var lowestYear = parseInt(this.menuYearSelect.options[0].value,10);
					var highestYear = parseInt(this.menuYearSelect.options[this.menuYearSelect.options.length-1].value,10);
					
					/*
					 * Check to see if the user has gone beyond the visible range of years.
					 */
					if((this.displayYear<=lowestYear) || (this.displayYear>=highestYear)){
						this.menuBuilt=false;
					}
				}

			}
			
			if(!this.menuBuilt){
				var result = "";
	
				var selected;
				
				result += '<div class="monthYearPicker"><table cellpadding="0" cellspacing="0" border="0" ><tr>\n';
				// previous month arrow
				result += '<td class="previousArrow"><a href="#" onclick="' + this.pickerObjId + '.loadPreviousMonth(); return false;"><span>&lt;&lt;</span></a></td>';
				
				var monthOnclick = this.pickerObjId + '.refreshCalendar('+this.pickerObjId + '.displayYear, this.options[this.selectedIndex].value-0)';
				var yearOnclick = this.pickerObjId + '.refreshCalendar(this.options[this.selectedIndex].value-0, '+this.pickerObjId + '.displayMonth)';
				
				result += '<td class="monthTD"><select name="cpMonth" id="'+this.inputId+'_monthControl" onkeyup="'+monthOnclick+'" onchange="'+monthOnclick+'" >';
				
				// loop through months for dropdown
				for( var monthCounter=1; monthCounter<=12; monthCounter++ ) {
					selected = (monthCounter==this.displayMonth) ? 'SELECTED' : '';
					result += '<option value="'+monthCounter+'" '+selected+'>'+MONTH_NAMES[monthCounter-1]+'</option>';
				}
				result += '</select></td>';
				result += '<td class="yearTD"><select name="cpYear" id="'+this.inputId+'_yearControl" onkeyup="'+yearOnclick+'" onchange="'+yearOnclick+'" >';
				
				// loop through years for dropdown
				for( var yearCounter=this.displayYear-defaults.yearSelectOffset; yearCounter<=this.displayYear+defaults.yearSelectOffset; yearCounter++ ) {
					selected = (yearCounter==this.displayYear) ? 'selected' : '';
					result += '<option value="'+yearCounter+'" '+selected+'>'+yearCounter+'</option>';
				}
				
				// next month arrow
				result += '</select></td><td class="nextArrow" ><a href="#" onclick="' + this.pickerObjId + '.loadNextMonth(); return false;"><span>&gt;&gt;</span></a></td></tr>\n';
				
				result += '</table></div>\n';
				this.menuArea.innerHTML = result;
				
				this.menuMonthSelect = $('#'+this.inputId+'_monthControl')[0];
				this.menuYearSelect = $('#'+this.inputId+'_yearControl')[0];
				this.menuBuilt=true;
			}else{
				DR.Utils.FormUtils.setValue(this.menuMonthSelect,{},this.displayMonth);
				DR.Utils.FormUtils.setValue(this.menuYearSelect,{},this.displayYear);
			}
			
		},
				
		/******************************************************************************
		* Write out the html for the calendar
		* @return html for the calendar
		* @private
		*****************************************************************************/
		writeCalendar: function() {
			
			this.refreshMenu();	
			
			var result = "";

			result += '<div class="datesArea"><table width="100%" cellpadding="0" cellspacing="0" border="0" class="calendar"><thead><tr>';
		
			var currentMonth = this.displayMonth;
			var currentDay = 1;
			var currentYear = this.displayYear;
			// if there is an offset 
			if (this.displayDateOffset > 0) {
				currentMonth--;
				if (currentMonth < 1) {
					currentMonth = 12;
					currentYear--;
				}
				currentDay = (this.numDaysInMonth[currentMonth] - this.displayDateOffset) + 1;
			}
		
			// write out days of week
			for (var j=0; j<7; j++) {
				result += '<th class="dayOfWeekName" width="14%">'+DAY_HEADERS[(WEEK_START_DAY+j)%7]+'</th>\n';
			}
			
			result += '</thead><tbody>';
		
			// write out 6 rows
			for (var row=1; row<=6; row++) {
				result += '<tr>\n';
				
				// write out dates for 7 columns
				for (var col=1; col<=7; col++) {
					var currentDate = $.dr.date.getISODate(currentYear, currentMonth, currentDay);
					var dateClassName = this.setDateClassName(currentDate);
					
					// break out of loop if 6th row is going to be full of dates for next month
					if (( row >4 ) && (col == 1) && (dateClassName == defaults.cssClassOtherMonthDate)) {
						result += '<td colspan="7">&nbsp;</td>';
						break;
					} else {
						result += '<td class="' + defaults.cssClassDate + " " + dateClassName + '"><a href="#" onclick="' + this.pickerObjId + '.updateDateInput(event, ' + currentYear + ', ' + currentMonth + ', ' + currentDay + '); return false;" class="' + dateClassName + '">' + currentDay + '</a></td>\n';
					}
		
					// increase date
					currentDay++;
					if (currentDay > this.numDaysInMonth[currentMonth]) {
						currentDay = 1;
						currentMonth++;
					}
					if (currentMonth > 12) {
						currentMonth = 1;
						currentYear++;
					}
				}
				result += '</tr>';
			}
			result += '</tbody></table></div>\n';
			
			// link to today's date
			if (!this.currentMonthHasTodaysDate) {
				result += '<div class="todayLink"><a href="#" id="'+this.inputId+'_todayLink" onclick="' + this.pickerObjId + '.refreshCalendar(' + this.todaysYear + ', ' + this.todaysMonth + ', ' + this.todaysDay + '); return false;">' + TODAY + '</a></div>';	
			}
			// reset to false
			this.currentMonthHasTodaysDate = false;
			
			return result;
		},
		
		/******************************************************************************
		* Sets a class name depending on whether a date is equal to today's date, the date in the input field, part of the display month, or in another month
		* @private
		****************************************************************************/
		setDateClassName: function(date) {
			var month = date.getMonth()+1;
			var year = date.getFullYear();
			var day = date.getDate();
			var className = "";
			// see if the date matches the input field
			if (this.hasInputFieldValue && month == this.inputFieldMonth && year == this.inputFieldYear && day== this.inputFieldDay) {
				// a date in the input field
				className = defaults.cssClassDisplayDateClass + " ";
			}
			
			if (month == this.todaysMonth && year == this.todaysYear && day == this.todaysDay) {
				// today's date
				this.currentMonthHasTodaysDate = true;
				className += defaults.cssClassTodaysDate;
			} else if (month == this.displayMonth && year == this.displayYear) {
				// a date inside of the display month
				className += defaults.cssClassDisplayMonthDate;
			} else {
				// a date outside of the display month
				className += defaults.cssClassOtherMonthDate;
			}
			return className;
		}
		
	};


	/******************************************************************************
	 * $(selector).dr.datePicker()
	 *
	 * @public
	 *
	 * Sets up an input to be a date picker
	 * 
	 * @return VOID
	 * 
	 *****************************************************************************/		
	$.namespace('dr',{
		datePicker: function() {
			return this.each(function(count){
				if( this.type=='text'){
					var $field = $(this);
					if(!$field.hasClass('datePicker_inited')){
						$field.addClass('datePicker');
						var format = $field.attr('data-format');

						var id = "datePicker_count_" + count + "_rndNbr_" + new Date().getTime();
						$field.addClass(id);
						var jRef = "\'input." + id + '\'';
						$field.attr('datePickerId',id);

						var pickerObjId =  "jQuery(" + jRef + ").data('datePicker')";
						var label = $.dr.utils.getLabel(this);
						if(label==this.name){
							label = null;
						}
						$field.data('datePicker', new datePicker(pickerObjId, this, label, format) );
						$field.addClass('datePicker_inited');
					}
				}
			});
		}
	});
	
	
	var initDatePickers = function($fields) {
		$fields.filter('input[type=text].datePicker').dr.datePicker();
		//DR_Utils_Profiler.log("initDatePickers");
	};
	
	$.dr.addPlugin('form',initDatePickers);
	
	//$(document).bind('afterFieldIndex',initDatePicker);
	
	/*
	 * Public API for static methods
	 */
	$.dr.datePicker = {
		/*
		 * Sets defaults, localized strings
		 */
		setDefaults: function(options){
			if(options) {
				// Example of options being passed:
				// $.dr.datePicker.setDefaults( {yearSelectOffset:8} );
				options = $.dr.utils.legacyMap(options, legacyMappings);
				$.extend(defaults, options);
			}
		}
	};


	
})(jQuery);
	

;(function($){
    $.dr.eventRecorder = function(opts) {
        this.type = opts.type;
        this.record = opts.recorder;
    };
})(jQuery);
;
(function($){
    var toggleRows = function(folder, collapse){
        var table = this;
        return $(this).each(function(){
            if (folder.className === undefined) {
                return false;
            }
            var level;
            var levelRe = /level(\d+)/;
            var levelMatch = levelRe.exec(folder.className);
            if (levelMatch && levelMatch.length) {
                level = parseInt(levelMatch[1], 10)
            } else {
                return false; // stop ... this isn't a faux-tree folder
            }
            var targetLevel = level + 1;
            
            var rows = $(folder).nextAll().each(function(count){
                var childLevel;
                var childLevelMatch = levelRe.exec(this.className);
                if (childLevelMatch && childLevelMatch.length) {
                    childLevel = parseInt(childLevelMatch[1], 10);
                } else {
                    return false; //stop
                }
                if ($(this).hasClass('folder')) {
                    if (childLevel < targetLevel) {
                        return false; // stop
                    }
                    else {
                        if (childLevel === targetLevel) {
                            var subCollapse = (collapse !== false) ? $(this).hasClass('open') : false;
                            toggleRows.call(table, this, subCollapse); //recursive call
                            $(this).toggle(collapse);
                            $(table).trigger("fauxTree-togglefolder", [table, this, childLevel, collapse]);
                        }
                    }
                }
                else {
                    // only deal with stuff on our level
                    if (childLevel === targetLevel) {
                        $(this).toggle(collapse);
                        $(table).trigger("fauxTree-toggleitem", [table, this, childLevel, collapse]);
                    }
                }
            });
        });
    };
    
    $.namespace('dr', {
        fauxtree: function(){
            return this.each(function(){
                $(this).click(function(evt){
                    var $target = $(evt.target);
                    var $parent = $target.closest('tr', this);
					var $fauxTree = $(this);
                    
                    // if the ancestor of the click is an a, make the ancestor the target.
                    var $a = $target.parents('a');
                    var href;

                    if ($a.length){
                        $target = $a;
                    }
                    
                    if ($target.is('a')){
                        href = $target.attr('href');
                    	if (href && (href.charAt(href.length - 1) === '#' || href === "")) {
                           // if the href is a # or the href ends in # or it is blank. Swallow the click
                            evt.preventDefault();
                        }                         
	                }
                    // targeting clicks on anything inside a td.iconColumn in a tr.folder
                    if ($parent.hasClass('folder') && $target.parents('.iconColumn').length) {
                        if ($target.is('a')) {
                            if (href && (href.charAt(href.length - 1) === '#' || href === "")) {
                                $parent.toggleClass("open");
                                toggleRows.call($fauxTree.get(0), $parent[0], $parent.hasClass('open'));
                                $fauxTree.trigger("fauxTree-togglerow", [$fauxTree.get(0), $parent.get(0), $parent.hasClass('open')]);
                            }                            
                        } else {
                            $parent.toggleClass("open");
                            toggleRows.call($fauxTree.get(0), $parent[0], $parent.hasClass('open'));
                            $fauxTree.trigger("fauxTree-togglerow", [$fauxTree.get(0), $parent.get(0), $parent.hasClass('open')]);
                        }
                    }
                    // Trigger an event for any click on a checkbox in an action column
                    if (($target.is(':checkbox') || $target.is(":radio")) && $target.parents('.actionCol').length) {
                        $fauxTree.trigger('fauxtree-checkboxselect', [$fauxTree.get(0), $parent.get(0), $target.get(0).checked]);
                    }
                 });
            });
        }
    });
    
    $.namespace('dr.fauxtree', {
        saveState: function(){
            return this.each(function(){
                var folderState = [];
				var pageName = $(this).attr('data-persist');
				
				//if data-persit type exists
				if (pageName != 'undefinded') {
					$('tr.open', this).each(function(){
						folderState.push($(this).attr('id'));
					});
					
					$.dr.userdata.save(pageName, 'openFolders', folderState, 'Array');
				}
            });
        },
        /**
         * Toggle the matched folder (row or rows). If collapse is boolean, it will override the toggle.
         * @param {Object} folder
         * @param {Object} collapse
         * @return {jQuery}
         */
        toggleRows: function(folder, collapse){
            var table = $(this).parents('table').get(0);
            return this.each(function(){
                toggleRows.call(table, this, collapse);
            });
        },
        /**
         * Return the immediate parent row of the matched row passed in.
         * @param {Object} row
         * @return {jQuery}
         */
        getParentRow: function(row) {
            if (row.jquery) {
                row = row.get(0);
            }
            var levelRe = /level(\d+)/;
            var level = parseInt(levelRe.exec(row.className)[1], 10);
            var targetLevel = level - 1;
            
            return $(row).prevAll('.level' + targetLevel).eq(0).length ? $(row).prevAll('.level' + targetLevel).eq(0) : null;
        },
        /**
         * return an array of rows, with the immediate parent as the first row
         * @param {Object} row a jquery or DOM object representing a row in the table.
         * @return {Array} the parent rows.
         */
        getParentRows : function(row) {
            var rows = [];
            var thisRow;

            while (thisRow = $(this).dr.fauxtree.getParentRow(row)) {
                rows.push(thisRow);
                row = thisRow;
            }
            return rows;
        },
        /**
         * Return a jQuery selector holding all of the immediate child rows of the matched row
         * @param {Object} row
         * @return {jQuery}
         */
        getChildRows : function(row) {
            if (row.jquery) {
                row = row.get(0);
            }
            var levelRe = /level(\d+)/;
            var level = parseInt(levelRe.exec(row.className)[1], 10);
            var childLevel = '.level' + (level + 1);
            return $(row).nextUntil('.level' + level).filter(childLevel);  
        }
    });
	 
    var initFauxtree = function(evt, context){
        $('table.fauxTree', context).dr.fauxtree();
    };
    
    $.dr.addUnobtrusiveEvent(initFauxtree, 'unobtrusiveEventEarly');
})(jQuery);

(function($){   
    var classes = {"success": "successMessage","error": "errorMessage","info": "infoMessage","warning": "warningMessage", "default":""};
    var defaults = {
        closeDelay: 3500,
        type: null, /* success | error | warning | info | custom */
        content: null,
        className: null,
        showAnimation: "slide", /* fade | slide | flash | strobe*/
        closeAnimation: "slide", /* fade | slide | flash | strobe*/
        stayOpen: true,
        fontSize: "14px",
        showCloseButton:true,
        position:"top-center"
    };
    var WINDOW_PADDING = 10;
    var fbKeyPress = 0;
    var feedbackStack = [];
    var positionFns = {
        setCenter: function($box) {
            var $window = $(window);
            var l = Math.min(($window.width()/2)-($box.outerWidth()/2), $window.width());
            $box.css({"left": Math.max(l, 0) + "px"});
        },
        setLeft: function($box) {
            $box.css({"left":WINDOW_PADDING+"px"});
        },
        setRight: function($box) {
            var $window = $(window);
            var l = parseInt($window.width() - $box.outerWidth() - WINDOW_PADDING, 10);
            $box.css({"left": Math.max(l, 0) + "px"});
        },
        setTop: function($box) {
            var lastNotif = findSimilarFeedback.call(this, $box) || null;            
            if (lastNotif != null && lastNotif.length >= 1) {
                $box.css("top", (lastNotif.offset().top + lastNotif.outerHeight() + WINDOW_PADDING - $(window).scrollTop())+"px").css("bottom","");
            } else {
                $box.css("top", WINDOW_PADDING+"px").css("bottom", "auto");
            }
        },
        setBottom: function($box) {
            var lastNotif = findSimilarFeedback.call(this, $box) || null;            
            if (lastNotif != null && lastNotif.length >= 1) {
                $box.css("bottom", (parseInt(lastNotif.css("bottom"),10) + lastNotif.outerHeight() + WINDOW_PADDING)+"px").css("top","auto");
            } else {
                $box.css("bottom", WINDOW_PADDING+"px").css("top", "auto");
            }
        }
    };
    function positionFeedback(position) {
        var positionParts = position.split("-") || ["top"];
        positionFns["set" + positionParts[0].capitalize()].call(this, this.messageBox);
        try {
            positionFns["set" + positionParts[1].capitalize()].call(this, this.messageBox);
        } catch(e) {
            this.options.position = "top-center";
            positionFns.setCenter.call(this, this.messageBox);
        }
        feedbackStack.push(this.messageBox);
        this.messageBox.css({"position":"fixed","display":"none","float":"none"});
    }
    function findSimilarFeedback($box) {
        //start from the back to find the last similar positioned popup added
        for (var i = feedbackStack.length - 1; i >= 0; i--) {
            if (feedbackStack[i][0] != $box[0] && this.options.position === feedbackStack[i].data("feedback").options.position) {
                return feedbackStack[i];
            }
        };
        return null;
    }
    function removeFromStack ($box, stack) {
        for (var i = stack.length - 1; i >= 0; i--) {
            if (stack[i][0] == $box[0]) {
                stack.splice(i, 1);
            }
        };
    }
    function closeButtonHandler() {
        var _this = this;
        this.messageBox.find(".closeNotification").bind("click",function(){
            //hold down shift to close all feedback popups
            if (fbKeyPress === 16) {
                $(".feedbackNotification").each(function(){
                    var fb = $(this).data("feedback");
                    if (fb.options.showCloseButton === true) {
                        fb.close(true);
                    }
                });
            } else {
                _this.close(true);
            }
        });
    }
    function closeCallback() {
        var _this = this;
        removeFromStack(this.messageBox, feedbackStack);
        setTimeout(function(){
            _this.messageBox.each(function(){ $(this).remove(); });
            $(document).trigger("afterCloseFeedback");
        },0);
    }
    //steps should be an even number
    function flashNotification($box, step, steps, visibility, closeCallback) {
        var _this = this;
        var type = {"in":"showAnimation", "out":"closeAnimation"}[visibility]
        var speed = {"strobe":500, "flash":100}[this.options[type]];
        var callback = function(){
            flashNotification.call(_this, $box, step+1, steps, visibility, closeCallback); 
        }
        if (step >= steps && visibility === "in"){
             $box.fadeIn("fast", closeCallback);
             return false;
        }
        if (step >= steps && visibility === "out"){
             $box.fadeOut("fast", closeCallback);
             return false;
        }
        if (step % 2 === 0) {
            $box.fadeIn(speed, callback);
        } else {
            $box.fadeOut(speed, callback);
        }
    }
    function evaluteContent(content) {
        if (content != null && (typeof content === "object" || typeof content === "string")) {
            return content;
        } else if ($.isFunction(content)) {
            return (content)() || "";
        }
        return ""; 
    }
    function makePopup() {
        if (this.messageBox == null) {
            this.messageBox = $("<div><div class='notificationText'></div></div>");
            if (this.options.showCloseButton === true) {
                var closeButtonClass = "closeButton"+(this.type).capitalize() || "";
                this.messageBox.append("<div class='closeNotification "+closeButtonClass+"'>x</div>")
            }
        }
        return this.messageBox
    }
    function moveFrom(position, $box) {
        var currentOffset = $box.offset();
        //$box.animate({"top":""});
    }
    function moveOffscreen($box) {
        $box.css({"display":"block", "left":"-2000px", "position":"static","float":"left"});
    }
    function setDimensions($box) {
        $box.width($box.find(".notificationText").outerWidth(true) + $box.find(".closeNotification").outerWidth(true));
        $box.height($box.find(".notificationText").outerHeight());
    }
    function Feedback(opts) {
        this.options = opts;
        this.timeout = null;
        this.type = opts.type == null ? "default" : opts.type;
    };
    Feedback.prototype = {
        setup: function() {
            var _this = this;
            this.setContent(this.options.content).addClass(classes[this.type]).addClass("feedbackNotification").addClass(this.options.className || "").hide().appendTo("body");
            this.messageBox.data("feedback", this);
            moveOffscreen(this.messageBox);
            setDimensions.call(this, this.messageBox);
            positionFeedback.call(this, this.options.position);
            closeButtonHandler.call(this);
            $(document).trigger("beforeAnimateFeedback");
            this.show();
            return this;
        },
        setContent: function(content) {
            this.options.content = content || this.options.content;
            var newContent = evaluteContent.call(this, content);
            return makePopup.call(this).find(".notificationText").css("fontSize", this.options.fontSize).html(newContent).end();
        },
        /* Show the message box with the given animation type */
        show: function() {
            this.messageBox.removeClass("hiding");
            var _this = this;
            var options = this.options;
            var callback = function() { 
                if (options.stayOpen !== true) { 
                    _this.close(); 
                } 
            };
            switch(options.showAnimation) {
                case "fade":
                    flashNotification.call(_this, this.messageBox, 0, 0, "in", callback);
                    break;
                case "slide":
                    this.messageBox.slideDown("fast", callback);
                    break;
                case "flash":
                    flashNotification.call(_this, this.messageBox, 1, 6, "in", callback);
                    break;
                case "strobe":
                    flashNotification.call(_this, this.messageBox, 1, 6, "in", callback);
                    break;
                default:
                    this.messageBox.slideDown("fast", callback);
                    break;
            }
        },
        close: function(instantClose) {
            var _this = this;
            var options = this.options;
            var delay = instantClose === true ? 0 : options.closeDelay;
            var animationCallback = function(){ closeCallback.call(_this); };
            if (this.messageBox.length === 0) {
                closeCallback.call(_this);
                return false;
            }
            if ($(document).triggerHandler("beforeCloseFeedback", [this.messageBox]) === false) {
                return false;
            }
            this.timeout = setTimeout(function(){
                switch(options.closeAnimation) {
                    case "fade":
                        _this.messageBox.fadeOut("fast", animationCallback);
                        break;
                    case "slide":
                        _this.messageBox.addClass("hiding");
                        _this.messageBox.slideUp("fast", animationCallback);
                        break;
                    case "flash":
                        flashNotification.call(_this, _this.messageBox, 1, 4, "out", animationCallback);
                        break;
                    case "strobe":
                        flashNotification.call(_this, _this.messageBox, 1, 4, "out", animationCallback);
                        break;
                    default:
                        _this.messageBox.addClass("hiding");
                        _this.messageBox.slideUp("fast", animationCallback);
                        break;
                }
            },delay);
        },
        updatePositioning: function() {
            removeFromStack(this.messageBox, feedbackStack);
            positionFeedback.call(this, this.options.position);
            //this.messageBox.show();
        }
    };

    function init(msg, opts, type) {
        opts = opts || {};
        opts.type = type
        var options = $.extend(true, {}, defaults, opts);
        options.content = msg; 
        if (options.animation != null && typeof options.animation === "string") {
            options.showAnimation = options.closeAnimation = options.animation;
        }
        var fbk = new Feedback(options);
        return fbk.setup(opts.type);
    }
    $.dr.feedback = {
        generic: function(msg, opts) {
            return init(msg, opts, "default");
        },
        success: function(msg, opts) {
            return init(msg, opts, "success");
        },
        error: function(msg, opts) {
            return init(msg, opts, "error");
        },
        info: function(msg, opts) {
            return init(msg, opts, "info");
        },
        warning: function(msg, opts) {
            return init(msg, opts, "warning");
        },
        getDefaults: function(msg, opts) {
            return defaults;
        },
        setDefaults: function(opts) {
            if (opts) {
                $.extend(true, defaults, opts);
            }
            //inform any listeners to the event
            $(document).trigger('afterSetDefaultsFeedback', [opts]);
        }
    };

    $(window).bind("resize",function(){
        $.dr.utils.waitForFinalEvent(function(){
            $(".feedbackNotification").each(function(){
                var f = $(this).data("feedback");
                if (f && f.options.position.search("center") > -1) {
                    positionFns.setCenter(f.messageBox);
                }
            });
        },200);
    });
    $(document).bind("keydown.fbKeyPress", function(e) {
        fbKeyPress = e.keyCode || e.which;
    }).bind("keyup.fbKeyPress",function(){
        fbKeyPress = null;
    });

})(jQuery);
/*
 * Form Behavior and Validation 
 */

;(function($) {
	
	/*
	 * Collection of forms that have been indexed, used in change checker code
	 */
	var INDEXED_FORMS = [];
	
	/*
	 * If there are multiple forms on the page, we only want to focus to the first one.
	 */
	var FOUND_FIRST_FOCUS = false;
		
	/*
	 * Overrideable defaults
	 */
	var defaults = {
		inputFocusClass: "inputFocus",
		fieldBlurDelay: 500
	};
	
	/*
	 * Legacy token mappings.
	 */
	var legacyMappings = {
		INPUT_FOCUS_CLASS: "inputFocusClass"
	}
	
	/*
	 * Localized Messages
	 */
	var messages = {
	  	WINDOW_ON_BEFORE_UNLOAD: "\u5BF9\u8868\u5355\u6240\u4F5C\u7684\u66F4\u6539\u5C1A\u672A\u4FDD\u5B58\u3002"
	};
	
	/*
	 * Only bind the beforeunload event once, regardless of the number of forms on the page
	 */
	var BEFOREUNLOAD_BOUND = false;
	var BEFOREUNLOAD_EXECUTED = false;
	
	/*
	 * Form Public API for static methods
	 */
	$.dr.form = {
		
		/*
		 * Gets localized strings
		 */
		getMessages: function(){
			return messages;
		},
		
		/*
		 * Gets defaults, localized strings
		 */
		getDefaults: function(){
			return defaults;
		},
		
		/*
		 * Sets defaults
		 * Example of options being passed:
		 * $.dr.form.setDefaults( {INLINE_ERROR_CLASS:'myCustomErrorClass'} );
		 */
		setDefaults: function(options){
			if(options){
				options = $.dr.utils.legacyMap(options, legacyMappings);
				$.extend(defaults, options);
			}
			//inform any listeners to the event
			$(document).trigger('dr-afterformsetdefaults',[options]);
		},
	
		/*
		 * Sets localized strings
		 * Example of options being passed:
		 * $.dr.form.setMessages( {GROUP_ERROR_BOX_ITEM_TITLE:"Click to jump to field"} );
		 */	
		setMessages: function(newMessages){
			if(newMessages) {
				$.extend(messages, newMessages);
			}
			//inform any listeners to the event
			$(document).trigger('dr-afterformsetmessages',[newMessages]);
		}
	};

	//Legacy Support
	window.customFormIndexerCallBack = function(){
		//EMPTY implementation
  		//Add customFormIndexerCallBack() method to your page to have functions run after the form indexing is done.
	};

	/*
	 * IE Form init function
	 */	
	var initFormsBindFormBehavior = function(context){
		$('form',context).dr.form();
			
		//Legacy Support - run the function
		customFormIndexerCallBack();
		//reset the function
		customFormIndexerCallBack = function(){};
	};
			
	/*
	 * IE Form init function
	 */	
	var initFormsieInit = function(context){
		var currentOverlay = (parent.overlayStack) ? parent.overlayStack.getCurrent() : null;
		var modalIsLoading = (typeof currentOverlay !== 'undefined' && typeof currentOverlay !== null && currentOverlay !== null) ? currentOverlay.loading : false;
		if(modalIsLoading){
			var func = function(){
				initFormsieInit(context);
			};
			window.setTimeout(func,50);
		}else{
			initFormsBindFormBehavior(context);	
		}
	};
	

	
	var initForms =  function(evt,context){
		// Any other plugins that are listening for these events will be triggered
		$.dr.form.setDefaults({});
		$.dr.form.setMessages({});
		
		$(document).trigger('dr-beforeinitforms');

		if($.browser.msie && $('body.modalPage').length>0){
			// IE has a problem where if the loading layer of a modal overlay is still visible, then it errors when trying to focus to forms.
			initFormsieInit(context);
		}else{
			initFormsBindFormBehavior(context);
		}
	};
	
	/*
	 * Add the initForms function to the pageinit event
	 */
 	$.dr.addUnobtrusiveEvent(initForms);

		
	/******************************************************************************
	 * Adds selected css class when user focuses or clicks on a form element.<br/>
	 * Example: $(':input').focus(focusEvent)
	 * @param {Object} evt
	 * @return Void
	 *****************************************************************************/	
	var focusEvent = function(evt){
		if (!this.getAttribute('readonly') && !this.disabled && this.type!='file'){
			if(!(this.type=='select-one' && $.browser.msie && parseInt($.browser.version.slice(0,1),10) > 6  )){
				// IE7 has a problem where changing the css class when clicking a select, will close
				// the select, which results in user have to click twice to open.
				$(this).addClass(defaults.inputFocusClass);
			}
		}
	};
	
	/******************************************************************************
	 * Validates a field after user blurs off of it.<br/>
	 * Also removes selected css class.<br/>
	 * Example: $(':input').blur(blurEvent)
	 * @param {Object} evt
	 * @return Void
	 *****************************************************************************/	
	var blurEvent = function(evt){
 		var oSelf = this;
		var func = function(){
			if (!oSelf.getAttribute('readonly') && !oSelf.disabled && oSelf.type!='file'){
				$(oSelf).removeClass(defaults.inputFocusClass);
			}
		};
		window.setTimeout(func,defaults.fieldBlurDelay);
	};
			
	/******************************************************************************
	 * Gets the normalized value for a select option<br />
	 * Example: $.dr.utils.getSelectOptionValue(o)
	 * @param {Object} option
	 * @return Boolean
	 *****************************************************************************/
	$.dr.utils.getSelectOptionValue = function(option){
		if(option){
			//Normalize value for IE && FF to match what will get posted. 
			//IE does not return the "text" if the value attribute is not specified.
			if (option.text !== "" && option.outerHTML && option.outerHTML.toLowerCase().indexOf("value=") == -1) {
				return option.text;
			} else {
				return option.value;
			}
		}
	};

	/******************************************************************************
	 * Compares the current value versus the default value<br />
	 * Example: $.dr.utils.hasFieldChanged(fieldObj)
	 * @param {Object} obj
	 * @return Boolean
	 *****************************************************************************/	
	$.dr.utils.hasFieldChanged = function(obj){
		var type = obj.type;
		if( type=='checkbox' || type=='radio' ){
			if(obj.defaultChecked != obj.checked){
				return true;
			}
		}else if (type == 'select-one'){
			if($(obj).dr.form.field.getDefaultValue() != $(obj).val()){
				return true;
			}
		}else if (type=='select-multiple'){
			var currentValue = $(obj).val();
			currentValue = (currentValue===null) ? "" :  currentValue.join(',');
			if( $(obj).dr.form.field.getDefaultValue()!=currentValue  ){
				return true;
			}			
		}else {
			//text,hidden,textarea would end up here
			if($(obj).dr.form.field.getDefaultValue() != $(obj).val()){
				return true;
			}
		}
		return false;
	};
	
	/******************************************************************************
	 * Gets the label text for a form element.<br/>
	 * Example: $.dr.utils.getLabel(fieldObj)
	 * @param {Object} obj
	 * @return String
	 *****************************************************************************/	
	$.dr.utils.getLabel = function(obj){
		// First check for the cached label on this field
		var label = $(obj).data('label');
		if (!label) {
			// Next check for the cached jQuery collection of labels on the form
			var $labels = $(obj.form).data('labels');
			if (!$labels) {
				// Only check the DOM once for all label elements, for better performance
				$labels = $('label', obj.form);
				$(obj.form).data('labels', $labels);
			}
			if (!$(obj).attr("data-label")) {
				// Find the label that has a for attribute equal to the field ID
				var $label = $labels.filter('label[for="'+obj.id+'"]');
				label = $label.text().replace(':', '');
				if (!label) {
					label = obj.name;
				}				
			} else {
				label = $(obj).attr("data-label");
			}
			$(obj).data('label', label);
		}
		return label;
	};


	/******************************************************************************
	 * addOnSubmitEvent()
	 *
	 * @private
	 *
	 * To prevent the user from seeing a prompt that there are unsaved changes, 
	 * when they are submitting the form, we suppress the prompt by wiring up
	 * the onsubmit function for the form to set the checkChanges flag
	 * to false
	 * 
	 * @return VOID
	 * 
	 *****************************************************************************/
	var addOnSubmitEvent = function(oForm){
		var originalOnsubmit = oForm.onsubmit;
		
		// Add an onsubmit to the form, or alter the existing one to include the validation
		oForm.onsubmit = function(){
			var formOkToSubmit = true;
			if ($.isFunction(originalOnsubmit)) {
				formOkToSubmit = (originalOnsubmit.call(this) !== false);
			}
			if (formOkToSubmit) {
				formOkToSubmit = $(oForm).dr.form.validate();
			}
			// If the form onsubmit returns true or undefined, and the form validates then disable the changeChecker
			if (formOkToSubmit) {
				var behavior = $(oForm).data('behavior');
				if (behavior && behavior.checkChanges) {	
					$(oForm).dr.form.enableCheckChanges(false);
				}
			}
			$(oForm).trigger('dr-aftervalidation', [formOkToSubmit]);
			return formOkToSubmit;
		};

		oForm._nativeFormSubmit = oForm.submit;
		
		// The following line wires up the validators when people write code like document.myform.submit();
		// Normally, the form would just submit, bypassing the onsubmit and validation.
		oForm.submit = function(){
			// test to see if the form is ok to submit
		    if (oForm.onsubmit.call(this)) {
				oForm._nativeFormSubmit();
		    }
		};
		
	};	
	
	/*
	 * The "form" holds all the state information for the form such as which
	 * behavior is enabled and which fields are to be validated
	 */
	var formBehavior = function(oForm, options){
		this.formObj = oForm;
		this.options = options;
		this.init();
	};

	formBehavior.prototype = {
		
		init: function(){
			this.firstField=null;
			this.normalizeName();
			this.bindBehavior();
		},
		
		normalizeName: function(){
			var oForm = this.formObj;
			var attributeId = 'name';
			var n = oForm.attributes[attributeId]; //makes jslint happy
			var f = 'form_' + new Date().getTime();
			if(n){
				if(!($.browser.msie && n.value==='')){
					f = n.value;
				}
			}
			oForm.setAttribute('name',f);
			oForm._formName = f;
			this.formIndex = INDEXED_FORMS.length;
			INDEXED_FORMS.push(oForm);
		},
		
		bindBehavior: function(){
			var oForm = this.formObj;
			var $form = $(this.formObj);
			var standardBehavior 	= ($form.attr('data-behavior')=='standard') 		? true  : false;
			var searchBehavior 		= ($form.attr('data-behavior')=='search') 			? true  : false;
			var enableFieldEvents	= ($form.attr('data-enable-field-events')=='false') ? false : true;
			var checkChanges 		= ($form.attr('data-check-changes')=='false') 		? false : true;
			var autoFocus 			= ($form.attr('data-auto-focus')=='false') 			? false : true;
			var forceCheckChanges 	= ($form.attr('data-force-check-changes')=='true') 	? true  : false;
			
			this.checkChanges = ( standardBehavior && (checkChanges || forceCheckChanges)) ? true : false;
			this.autoFocus = ( (standardBehavior || searchBehavior) && autoFocus ) ? true : false;
			this.enableFieldEvents = ( (standardBehavior || searchBehavior) && enableFieldEvents ) ? true : false;
			this.forceCheckChanges=forceCheckChanges;
			
			this.customFieldSelector= $form.attr('data-custom-field-selector');

			if (standardBehavior || searchBehavior){
				//DR_Utils_Profiler.clear();
				//DR_Utils_Profiler.start();
				
				// IE6 and IE7 will not return results when using $(myform.elements)
				// Firefox and Webkit browsers both work much faster using the form.elements as the starting point
				var myFields = ($.browser.msie) ?  $($.makeArray(this.formObj.elements)) : $(this.formObj.elements);
				//DR_Utils_Profiler.log("FORM - get all fields");
				
				this.initFields(myFields);
				// when the user leaves the page, do we check the current form for changes
				if(checkChanges || forceCheckChanges){
					this.addUnloadEvent();
				}
				// Should we try to focus to the first field
				if (this.autoFocus){
					this.focusFirstElement();
				}
				addOnSubmitEvent(oForm);
			}
		},
		
		initFields: function($fields, override){
			if(this.formObj.getAttribute('_inited')===null || override){

				var oSelf = this;
				
				if(typeof this.customFieldSelector!=='undefined'){
					$fields = $fields.filter(this.customFieldSelector);
				}
				var $new_fields;
				if(override) {
					$(this.formObj).removeData("labels");
					$new_fields = $fields.filter(function(i){
						var di = $(this).data("data-inited");
						return di !== "true"
					}); 				
				}

				// Bind custom events
				var formPlugins = $.dr.getPlugins('form');
				for(var i=0; i < formPlugins.length; i++ ){
					formPlugins[i].call(this, ($new_fields && $new_fields.length > 0) ? $new_fields : $fields);
					//DR_Utils_Profiler.log("FORM - Bind plugin");
				}

				// Bind blur and focus events, using event delegation on the form element
				var focusableSelector = 'input:text,input:password,select,textarea';
				var focusHandler = function(e){
					if ($.isFunction(e.data.handler)) {
						var formField = e.target;
						if ($(formField).is(oSelf.customFieldSelector || focusableSelector)) {
							e.data.handler.call(formField, e);
						}
					}
				};
				//only unbind when we want to bind again
				if (override) {
					$(this.formObj).unbind('focusin._form').unbind('focusout._form');
				}			
				$(this.formObj).bind('focusin._form', {handler: focusEvent}, focusHandler).bind('focusout._form', {handler: blurEvent}, focusHandler);
				
				//DR_Utils_Profiler.log("FORM - Bind blur and focus events");

				// Find the first field so we can focus to it later on
				if(this.autoFocus && this.firstField===null && !FOUND_FIRST_FOCUS && $(this.formObj).filter(':visible').length>0 ){
					// Instead of filtering the list, just start looping and check as we go
					$fields.each(function(){
						var $field = $(this);
						if ($field.is(focusableSelector) && $field.is(':visible')) {
							oSelf.firstField = this;
							FOUND_FIRST_FOCUS = true;
							return false;
						}
					});
					//DR_Utils_Profiler.log("FORM - Find First Focus Element");
				}
				//DR_Utils_Profiler.log("FORM - Finished indexing - " + $fields.length + " form elements");
				//DR_Utils_Profiler.view();	
			}
			this.formObj.setAttribute('_inited' , 'true');
			$fields.each(function(i,e){
				var isInited = typeof $(e).data("data-inited") === "undefined"
				if (isInited) {
					$(e).data("data-inited","true")
				}
			});
		},

		/******************************************************************************
		 * focusFirstElement()
		 *
		 * @private
		 *
		 * Focus to the first text box/textarea/select
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		 focusFirstElement: function(){
			var obj = this.firstField;
			if(obj!==null){
				try{
					obj.focus();
					if (obj.type == "text" || obj.type=="textarea"){
						obj.select();
					}
				}catch (e){
					// field is hidden or unselectable, so abort
				}
			}
		},
				
		/******************************************************************************
		 * obj.addUnloadEvent()
		 *
		 * @private
		 *
		 * Attaches an event to the window that fill compare the current value of all
		 * the fields in the form against the values as they were when the form was
		 * first indexed. If there is already a function on the onBeforeUnload event
		 * we append ours to it.
		 *
		 * The user will get a confirm dialog that are they sure they want to leave 
		 * the page, because there are unsaved changes.
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/	
		addUnloadEvent: function(){
			// Bind this event via jQuery.bind only once (ignore anything already defined in 'window.onbeforeunload')
			if (!BEFOREUNLOAD_BOUND) {
				BEFOREUNLOAD_BOUND = true; // Flag this, so it only gets bound once
				$(window).bind('beforeunload', function(){
					// Make sure this function only runs once
					if (!BEFOREUNLOAD_EXECUTED) {
						BEFOREUNLOAD_EXECUTED = true;
						var changes = false;
						for (var i = 0; i < INDEXED_FORMS.length; i++) {
							var oForm = INDEXED_FORMS[i];
							var _behavior = $(oForm).data('behavior');
							if (_behavior) {
								if (_behavior.checkChanges && !_behavior.forceCheckChanges) {
									if ($(oForm).dr.form.checkForChanges()) {
										//$(oForm).dr.form.displayChangedFields();
										changes = true;
										break;
									}
								}
							}
							
						}
						if (changes) {
							if ($.browser.msie) {
								// IE6 and IE7 have a problem with window.location = 'someurl', and throws an error if the 
								// user clicks the cancel button on the check changes prompt.
								window.onerror = function(err){
									window.event.returnValue = (err.toLowerCase().indexOf('unspecified error') >= 0) ? true : false;
								};
							}
							var m = messages.WINDOW_ON_BEFORE_UNLOAD;
							if (!$.browser.safari) {
								m = '\n' + m + '\n';
							}
							
							$(document).trigger("dr-showchangeswarning");
							
							return m;
						}
					}
				});
			}
		}	
	};
	
	/******************************************************************************
	 * $('#this.formObj').dr.form()
	 *
	 * @public
	 *
	 * Resets the field values and validation
	 * 
	 * @return VOID
	 * 
	 *****************************************************************************/
	$.namespace('dr',{
		form: function(options) {
						
			try{
				
				// search for fieldsets 
				if($.browser.msie){
					$('fieldset:not(.noBackground)',this).filter(function(){
						return ($('> legend',this).length==0);
					}).addClass('noBackground');
				}
				
				 // Return a jQuery collection to allow for chaining
				options = $.dr.utils.legacyMap(options, legacyMappings);
				options = (typeof options == 'object') ? $.extend(true, defaults, options) : defaults;
				var collection =  this.each(function(){
					var $form = $(this);
					var opts = $.extend(true,{},options);
					var dataOptions = $form.attr('data-options');
				    if (dataOptions) {
				        dataOptions = $.dr.utils.evalString(dataOptions);
						$.extend(true,opts,dataOptions);
				    }
					$form.data('dataOptions', opts);
					// only add behavior to forms with data-behavior attribute setup
					if ($form.attr('data-behavior')=='standard' || $form.attr('data-behavior')=='search') {
						if(this.tagName.toLowerCase()=='form'){
							$form.trigger("dr-beforeindexfields");
							$form.data('behavior', new formBehavior(this,opts));
							$form.trigger("dr-afterindexfields");
						}
					}
			  	});
				FOUND_FIRST_FOCUS=false;
				return collection;
		 	}catch(e){
				$.dr.utils.logError('Error when binding form behavior',e);
			}
		}
	});
	
	function getFormObj(collection){
		
		//if(collection.length>0){
		//	var f = $(collection[0]).data('dr_form');
		//	return (f) ? f : {};
		//}
		
		if(collection.length>0){
			var f = $(collection[0]).data('behavior');
			return (f) ? f : {};
		}
	}
	
	/*
	 * Public form API
	 */
	$.namespace('dr.form',{
		
		/******************************************************************************
		 * $(form).dr.form.get()
		 *
		 * @public
		 *
		 * Gets the form object
		 * 
		 * @return Array
		 * 
		 *****************************************************************************/
		get: function(){
			return getFormObj(this);
		},

		
		setOptions: function(options){
			if(options){
				$.extend(getFormObj(this).options, options);
			}
			
			//inform any listeners to the event
			$(document).trigger("dr-afterformsetoptions",[options]);
		},
				
		/******************************************************************************
		 * $(form).dr.form.getChangedFields()
		 *
		 * @public
		 *
		 * Loop the fields for the form, check the current value against the initial
		 * value, if they are not the same, we add to an array of changed fields
		 * 
		 * @return Array
		 * 
		 *****************************************************************************/
		getChangedFields: function(includeHiddenFields){
			var oForm = this[0];
			var toggleSwitchSelector = 'div.toggleswitch input:radio';
			var filterFn = function(){
                if($.dr.utils.hasFieldChanged(this)){
                    return true;
                }
                return false;
            };
			if (includeHiddenFields !== true) {
                return $(":input",oForm).not(':button').not(':hidden').add(toggleSwitchSelector, oForm).filter(filterFn);
			} else {
                return $(":input",oForm).not(':button').add(toggleSwitchSelector, oForm).filter(filterFn);
			}
		},
		
		/******************************************************************************
		 * $(form).dr.form.enableCheckChanges()
		 *
		 * @public
		 *
		 * Turns on/off the behavior to run the on before unload event
		 * 
		 * @param {Bool} flag  Boolean flag to enable/disable change checking
		 *  
		 * @return VOID
		 *****************************************************************************/
		enableCheckChanges: function(flag){
			getFormObj(this).checkChanges = flag;
		},
		
		/******************************************************************************
		 * $(form).dr.form.enableAutoFocus()
		 *
		 * @public
		 *
		 * Enable/Disable the behavior where the first input, select, or textarea
		 * is automatically focused when the page is loaded
		 * 
		 * @param {Bool} flag  Boolean flag to enable/disable automatic focus
		 * 
		 * @return VOID
		 *****************************************************************************/
		enableAutoFocus: function(flag){
			getFormObj(this).autoFocus = flag;
		},

		 /******************************************************************************
		 * $(form).dr.form.reIndex()
		 *
		 * @public
		 *
		 * Resets the field values and validation
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/	
		reIndex: function(){
			var oForm = getFormObj(this);
			if(typeof oForm.fieldsWithValidation !== 'undefined'){
				oForm.fieldsWithValidation = [];
			}
			if(typeof oForm.initFields !== 'undefined'){
				oForm.initFields(($.browser.msie) ?  $(":input",oForm.formObj) : $(oForm.formObj.elements),true);
			}
		},
		
		 /******************************************************************************
		 * $(form).dr.form.initFields($fields,override)
		 *
		 * @public
		 *
		 * Resets the field values and validation
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/	
		initFields: function(fields,override){
			var oForm = getFormObj(this);
			if (typeof fields === 'string') {
				fields = $(fields, oForm);
			}
			override = (override===false) ? false : true;
			oForm.initFields(fields,override);
		},


		/******************************************************************************
		 * $(form).dr.form.checkForChanges()
		 *
		 * @public
		 *
		 * When the tries to leave the page, by clicking on a url, or refreshes, etc,
		 * the onBeforeUnload event fires, and calls the checkForChanges function
		 * which iterates through each form in the collection to see if it has changes
		 * 
		 * @return BOOL
		 *****************************************************************************/	
		checkForChanges: function(){
			//DR_Utils_Profiler.clear();
			//DR_Utils_Profiler.start();
			var changedFields = $(this).dr.form.getChangedFields();
			//DR_Utils_Profiler.log("Finished checking for changes - " + changedFields.length + " form elements");
			//DR_Utils_Profiler.view();
			return (changedFields.length>0) ? true : false;
		},

		/******************************************************************************
		 * $(form).dr.form.displayChangedFields()
		 *
		 * @public
		 *
		 * If there are any changes, display the changes in an overlay
		 * 
		 * This is only used for debug purposes
		 * 
		 * @return void
		 * 
		 *****************************************************************************/
		displayChangedFields: function(){
			
			return this.each(function(){
				var changedFields = $(this).dr.form.getChangedFields();
				console.log('Changed Fields for ' + this._formName);
				if(changedFields.length>0){
					for(var i=0;i<changedFields.length;i++){
						var field = changedFields[i];
						console.log("ID: <b>" +field.id+"</b>");
						console.log("     VALUE:" + $(field).dr.form.field.getDefaultValue());
						console.log("     NEW_VALUE:" + $(field).val());
					}
				}else{
					console.log('None');
				}

			});
		},
			
		destroy: function(){
			return this.each(function(){
				if($(this).data('behavior')){
					//	disableWindowOnBeforeUnload
					//	INDEXED_FORMS.slice(this);
	
					$(this).data('behavior',null);
				}
			});
		}
		
	});

	
	$.namespace('dr.form.field',{

		/******************************************************************************
		 * Retrieves the default value for a form element. The default values is<br />
		 * original value of the field when the page loaded.<br/>
		 * Example: $('#myField').dr.form.field.getDefaultValue()
		 * @param {Object} obj
		 * @return String
		 *****************************************************************************/	
		getDefaultValue: function(){
			if(this.length){
				var elem = this[0];
				var type = elem.type;
				if (type=='checkbox' || type=='radio'){
					if(elem.defaultChecked){
						return true;
					}else{
						return false;
					}
				}else if ( $.nodeName( elem, "select" ) ) {
					var returnValue = [];
					var options = elem.options;
					for(var i=0;i<options.length;i++){
						if(options[i].defaultSelected){
							var val = $.dr.utils.getSelectOptionValue(options[i]);
							if(type=='select-one'){
								return val;
							}else{
								returnValue.push(val);
							}
						}
					}
					if(type=='select-one' && returnValue.length===0 ){
						return $.dr.utils.getSelectOptionValue(options[0]);
					}
					
					return (returnValue.length>0) ? returnValue.join(',') : "";
				}else{
					//text,hidden,textarea would end up here
					return elem.defaultValue.replace(/\r/g, "");
				}
			}
		}
	});
	



})(jQuery);



;
(function($){

    /*
     * Overrideable defaults
     */
    var defaults = {
        validateHiddenFields:           false,
        validationEnabled:              true,
        showInlineErrors:               true,
        showInlineErrorsOnBlur:         false,
        inlineErrorPosition:            "above",
        inlineErrorClass:               "error",
        inputErrorClass:                "inputError",
        groupBoxClass:                  "errorMessage",
        groupBoxPosition:               "above",
        groupBoxEnabled:                true,
        groupBoxPositionAboveForm:      false,
        focusFirstError:                true,
        numberLocale:                   $.dr.USER_LOCALE,
        currency:                       $.dr.CURRENCY,
        truncateOnPaste:                false,
        hideErrorDelay:                 500
    }
    
    /*
     * Legacy token mappings.
     */
    var legacyMappings = {
        VALIDATION_ENABLED:             "validationEnabled",
        VALIDATE_HIDDEN_FIELDS:         "validateHiddenFields",
        SHOW_INLINE_ERRORS:             "showInlineErrors",
        SHOW_INLINE_ERRORS_ONBLUR:      "showInlineErrorsOnBlur",
        INLINE_ERROR_POSITION:          "inlineErrorPosition",
        INLINE_ERROR_CLASS:             "inlineErrorClass",
        INPUT_ERROR_CLASS:              "inputErrorClass",
        GROUP_BOX_CLASS:                "groupBoxClass",
        GROUP_BOX_POSITION:             "groupBoxPosition",
        GROUP_BOX_ENABLED:              "groupBoxEnabled",
        GROUP_BOX_POSITION_ABOVE_FORM:  "groupBoxPositionAboveForm",
        FOCUS_FIRST_ERROR:              "focusFirstError",
        NUMBER_LOCALE:                  "numberLocale",
        CURRENCY:                       "currency",
        TRUNCATE_ONPASTE:               "truncateOnPaste"
    }
    
    /*
     * Default validation attributes
     * Attributes are added via addValidators()
     */
    var validationAttributes = ["data-required", "data-maxlength", "data-custom-validator", "data-type"];

    
    //additional CSS classes to validate against, regardless of whether they are hidden or not
    var selectorsToValidate = [":visible"];
    /*
     * Localized Messages
     */
    var messages = {
        EXPAND_BUTTON_TOOL_TIP: "\u5355\u51FB\u6B64\u5904\u6269\u5C55\u7F16\u8F91\u533A",
        COLLAPSE_BUTTON_TOOL_TIP: "\u5355\u51FB\u6B64\u5904\u5C06\u7F16\u8F91\u533A\u6062\u590D\u5230\u666E\u901A\u5927\u5C0F",
        GROUP_ERROR_BOX_TITLE: "\u53D1\u751F\u4E0B\u5217\u9519\u8BEF\uFF1A",
        GROUP_ERROR_BOX_ITEM_TITLE: "\u5355\u51FB\u8DF3\u8F6C\u5230\u57DF",
        REQUIRED: "\u9700\u8981{LABEL}\u3002",
        X_CHARACTERS_REMAINING: "{0}\u4FDD\u7559\u5B57\u7B26",
        X_OF_Y_CHARACTERS_REMAINING: "{0}{1}\u4FDD\u7559\u5B57\u7B26",
        X_OVER_THE_LIMIT: "{0}\u5B57\u7B26\u8D85\u51FA\u6700\u5927\u9650\u5236{1}\u3002",
        MAX_CHARS: "\u8FBE\u5230\u8BE5\u57DF\u7684\u57DF\u957F\u9650\u5236({LIMIT})\u3002\u6570\u636E\u5DF2\u7F29\u77ED\u81F3\u7B26\u5408\u9650\u5236\u8981\u6C42\u3002",
        CHAR_LENGTH: "{LABEL}\u5DF2\u8D85\u51FA{MAX_CHARS}\u6700\u5927\u5B57\u7B26\u9650\u5236\u3002",
        RANGE: "{LABEL}\u8D85\u51FA\u8303\u56F4\u3002\u6709\u6548\u8303\u56F4\u4E3A{MIN}\u81F3{MAX}\u3002",
        RANGE_MIN: "{LABEL}\u5C0F\u4E8E{MIN}\u7684\u6700\u5C0F\u503C\u3002",
        RANGE_MAX: "{LABEL}\u5927\u4E8E{MAX}\u7684\u6700\u5927\u503C\u3002",
        EMAIL: "{LABEL}\u4E3A\u65E0\u6548\u7535\u5B50\u90AE\u4EF6\u5730\u5740\u3002",
        URL: "{LABEL}\u4E3A\u65E0\u6548url\u3002\u6709\u6548\u683C\u5F0F\u4E3A{EXAMPLE}\u3002",
        PHONE_NUMBER: "{LABEL}\u4E3A\u65E0\u6548\u7535\u8BDD\u53F7\u7801\u3002\u6709\u6548\u683C\u5F0F\u4E3A{EXAMPLE}\u3002",
        ALPHA: "{LABEL}\u672A\u6309\u5B57\u6BCD\u987A\u5E8F\u6392\u5217\u3002",
        ALPHA_NUMERIC: "{LABEL}\u4E0D\u662F\u5B57\u6BCD\u6570\u5B57\u3002",
        DECIMAL: "{LABEL}\u4E3A\u65E0\u6548\u5341\u8FDB\u5236\u6570\u3002\u6709\u6548\u683C\u5F0F\u4E3A({EXAMPLE})\u3002",
        INTEGER: "{LABEL}\u4E3A\u65E0\u6548\u6574\u578B\u6570\u3002",
        NUMERIC: "{LABEL}\u4E3A\u65E0\u6548\u6570\u3002",
        CURRENCY: "{LABEL}\u4E3A\u65E0\u6548\u91D1\u989D\u3002\u6709\u6548\u683C\u5F0F\u4E3A({EXAMPLE})",
        FRACTION_MIN: "#gen.jsMsg.Form.FRACTION_MIN#",
        FRACTION_MAX: "#gen.jsMsg.Form.FRACTION_MAX#"
    }
    var getNumberFormat = function(obj) {
        return $.dr.utils.getNumberLocale($(obj).attr('data-number-locale'));
    }
    
    /******************************************************************************
     * Takes in a message string, and replaces any system variables, like LABEL
     * or VALUE, etc, with the actual label or value from the interface<br />
     * Example: <code>buildErrorMessage()</code><br />
     *
     * PRIVATE
     *
     * @return {String}
     *****************************************************************************/
    var buildErrorMessage = function(val, label, msg, format, exampleText){
        format = (format) ? format : "";
        val = val || "";
        exampleText = (exampleText) ? exampleText : "";
        return msg.replace(/\{LABEL\}/g, label).replace(/\{VALUE\}/g, val).replace(/\{FORMAT\}/g, format).replace(/\{EXAMPLE\}/g, exampleText);
    };
    
    var getValidationSelectorString = function() {
        return  $.dr.form.getValidationSelectors().join(", ");
    }
    
    var DATA_TYPES = {
    
        /******************************************************************************
         * Validates if the string is a valid email address<br />
         * Example: <code>$.dr.form.isDataValidForType('email',val)</code><br />
         * @return {Boolean} True or false depending on whether the string is a valid e-mail address
         *****************************************************************************/
        email: [messages.EMAIL, "", function(val){
            return /^[a-zA-Z0-9\-_.]+[a-zA-Z0-9\-_]@[a-zA-Z0-9][a-zA-Z0-9\-.]*[a-zA-Z0-9]\.[a-zA-Z][a-zA-Z\.]*[a-zA-Z]$/.test(val);
        }
]        ,
        
        /******************************************************************************
         * Validates if the string is a valid internet address<br />
         * Example: <code>$.dr.form.isDataValidForType('url',val)</code><br />
         * @return {Boolean} True or false depending on whether the string is a valid url
         *****************************************************************************/
        url: [messages.URL, "http://website.com", function(val, format){
        
            if (format == "website") {
                return /^(http:|https:)(\/){2}?[^\/]\S+\.\S+/.test(val);
            }
            else {
                return /^[a-zA-Z0-9\-.+]*:(\/){2}[\S]?/.test(val);
            }
        }
]        ,
        
        /******************************************************************************
         * Validates if the string is a valid phone number<br />
         * Example: <code>$.dr.form.isDataValidForType('phonenumber',val)</code><br />
         * @return {Boolean} True or false depending on whether the string is a valid phone number
         *****************************************************************************/
        phonenumber: [messages.PHONE_NUMBER, "###-###-####", function(val, format){
            if (!format) {
                return /^(\+)?(\d{1,3})?(([0-9]{1})?([- .(]|[ (]{1,2})?([0-9a-zA-Z]{3})([- .)]|[ )]{1,2})?[0-9a-zA-Z]{3}([- .]{1})[0-9a-zA-Z]{4})?(( )?([#][0-9a-zA-Z]{1,10}))?$/.test(val);
            }
            else 
                if (format == 'strict') {
                    return /^[1-9]\d{2}-\d{3}-\d{4}$/.test(val);
                }
                else 
                    if (format == 'integer') {
                        return /^\d{10}$/.test(val);
                    }
        }
]        ,
        
        /******************************************************************************
         * Validates if the string has only alphabetic chars.<br />
         * This validator should only be used on Western/EU sites
         * Example: <code>$.dr.form.isDataValidForType('alpha',val)</code><br />
         * @return {Boolean} True or false depending on whether the string contains alpha characters
         *****************************************************************************/
        alpha: [messages.ALPHA, "", function(val){
            return /^[a-zA-Z]+$/.test(val);
        }
]        ,
        
        /******************************************************************************
         * Validates if the string has alphabetic or numeric chars<br />
         * Example: <code>$.dr.form.isDataValidForType('alphanumeric',val)</code><br />
         * @return {Boolean} True or false depending on whether the string contains alpha or numeric characters
         *****************************************************************************/
        alphanumeric: [messages.ALPHA_NUMERIC, "", function(val){
            return /^[0-9A-Za-z-_ @#]+$/.test(val);
        }
]        ,
        
        /******************************************************************************
         * Validates if the string is a valid currency<br />
         * Example: <code>$.dr.form.isDataValidForType('currency',val)</code><br />
         * @return {Boolean} True or false depending on whether the string is a valid currency
         *****************************************************************************/
        currency: [messages.CURRENCY, "#,###.##", function(val, format, obj){
            if (val === null || val === undefined) {
                return false;
            }
            if (!format) {
                format = defaults.currency;
            }
            var num = val.replace(format, "");
            if (format == ' CAD') {
                num = num.replace("C$", "");
                num = num.replace("$", "");
            }
            num = $.dr.utils.normalizeNumber(num, getNumberFormat(obj));
            return /^\d*(\.)?(\d){1,2}?$/.test(num);
        }
]        ,
        
        /******************************************************************************
         * Validates if the string is a valid decimal number<br />
         * Example: <code>$.dr.form.isDataValidForType('decimal',val)</code><br />
         * @return {Boolean} True or false depending on whether the string is a valid decimal number
         *****************************************************************************/
        decimal: [messages.DECIMAL, "###,###.##", function(val, format, obj){
            if (val === null || val === undefined) {
                return false;
            }
            var num = $.dr.utils.normalizeNumber(val, getNumberFormat(obj));
            return /^\d*[0-9](\.\d*[0-9])?$/.test(num)
        }
]        ,
        
        /******************************************************************************
         * Validates if the string is a valid integer<br />
         * Example: <code>$.dr.form.isDataValidForType('integer',val)</code><br />
         * @return {Boolean} True or false depending on whether the string is a valid integer
         *****************************************************************************/
        integer: [messages.INTEGER, "", function(val){
            return /^[+-]?[0-9]+$/.test(val);
        }
]        ,
        
        /******************************************************************************
         * Validates if the string is a valid number<br />
         * Example: <code>$.dr.form.isDataValidForType('numeric',val)</code><br />
         * @return {Boolean} True or false depending on whether the string is a valid number
         *****************************************************************************/
        numeric: [messages.NUMERIC, "", function(val, format, obj){
            if (val === null || val === undefined) {
                return false;
            }
            return !isNaN(Number($.dr.utils.normalizeNumber(val, getNumberFormat(obj))));
        }
]
    
    
    }
    
    /*
     * Collection of validators. When a field is validated, every function in this collection
     * is run to see if the field validates.
     */
    var validators = {
    
        dataType: function(obj, val, inline, fieldValidationEnabled){
            var isValid = true;
            var drDataType = obj.getAttribute('data-type');
            var drExample = obj.getAttribute('data-example');
            var format = obj.getAttribute('data-format');
            var msg = "";
            var jObj = $(obj);
            if (drDataType !== null) {
                drDataType = drDataType.toLowerCase();
                
                var dataType = DATA_TYPES[drDataType];
                if (dataType === undefined) {
                    if (window.console) {
                        // alert the developer to the problem if they are running firebug
                        console.log('The validator for data-type="' + drDataType + '" for field with name "' + obj.name + '" does not exist.')
                    }
                    return true;
                }
                
                if (val.isBlank()) {
                    $(obj.form).dr.form.removeError(obj, drDataType);
                }
                else {
                    // defaults for range and dateRange
                    var errorMessage = dataType[0];
                    var exampleText = (drExample !== null) ? drExample : dataType[1];
                    
                    if (!$.dr.form.isDataValidForType(drDataType, val, format, obj)) {
                        msg = errorMessage;
                    }
                    else {
                    
                        // Check for range options                      
                        var min = obj.getAttribute('data-min');
                        var max = obj.getAttribute('data-max');
                        var minValid = $.dr.form.isDataValidForType(drDataType, min, format, obj);
                        var maxValid = $.dr.form.isDataValidForType(drDataType, max, format, obj);
                        if (min !== null || max !== null) {
                            if ((min !== null && !minValid) || (max !== null && !maxValid)) {
                                isValid = false;
                                msg = "The value is correct for {LABEL}, but the specified range options are not of the correct data type.";
                                
                            }
                            else {
                                var lowerBound, upperBound, value;
                                if (drDataType == 'date' && typeof $.dr.date == 'function') {
                                    value = new $.dr.date(val, format).getTime();
                                    lowerBound = (min !== null) ? new $.dr.date(min, format).getTime() : null;
                                    upperBound = (max !== null) ? new $.dr.date(max, format).getTime() : null;
                                }
                                else 
                                    if (drDataType == 'time12hr' || drDataType == 'time24hr') {
                                        value = $.dr.date.getDateFromTime(val).getTime();
                                        lowerBound = (min !== null) ? $.dr.date.getDateFromTime(min).getTime() : null;
                                        upperBound = (max !== null) ? $.dr.date.getDateFromTime(max).getTime() : null;
                                    }
                                    else {
                                        var numberLocale = getNumberFormat(obj);
                                        value = $.dr.utils.convertCurrencyToNumber(obj, val, format, numberLocale);
                                        lowerBound = $.dr.utils.convertCurrencyToNumber(obj, min, format, numberLocale);
                                        upperBound = $.dr.utils.convertCurrencyToNumber(obj, max, format, numberLocale);
                                    }
                                if (!isNaN(value)) {
                                    if (min !== null && max !== null) {
                                        if (!isNaN(lowerBound) && !isNaN(upperBound)) {
                                            if (!(value >= lowerBound && value <= upperBound)) {
                                                msg = messages.RANGE.replace(/\{MAX\}/g, max).replace(/\{MIN\}/g, min);
                                            }
                                        }
                                    }
                                    else 
                                        if (max !== null && !isNaN(upperBound)) {
                                            if (value > upperBound) {
                                                msg = messages.RANGE_MAX.replace(/\{MAX\}/g, max);
                                            }
                                        }
                                        else 
                                            if (min !== null && !isNaN(lowerBound)) {
                                                if (value < lowerBound) {
                                                    msg = messages.RANGE_MIN.replace(/\{MIN\}/g, min);
                                                }
                                            }
                                }
                            }
                        }
                        
                        // Check for Fraction Digits options                        
                        var minFractionDigit = obj.getAttribute('data-min-fraction-digits');
                        var maxFractionDigit = obj.getAttribute('data-max-fraction-digits');
                        if (minFractionDigit !== null){
                            var minValid = true;
                            if(/^\d+$/.test(minFractionDigit)){
                                var num = $.dr.utils.normalizeNumber(val, getNumberFormat(obj));
                                var regStr = "^\\d*[0-9]\\.\\d{" + minFractionDigit + ",}?$";
                                var minfractionRegex = new RegExp(regStr);
                                if (!(minfractionRegex.test(num))) {
                                    msg = messages.FRACTION_MIN.replace(/\{MIN\}/g, minFractionDigit);
                                }
                            }
                            else{
                                $.dr.logError("minimum fraction digits are not valid numbers.");
                            }
                        }
                        if (maxFractionDigit !== null){
                            var maxValid = true;
                            if(/^\d+$/.test(maxFractionDigit)){
                                var num = $.dr.utils.normalizeNumber(val, getNumberFormat(obj));
                                var regStr = "^\\d*[0-9](\\.\\d{0," + maxFractionDigit + "})?$";
                                var maxfractionRegex = new RegExp(regStr);
                                if (!(maxfractionRegex.test(num))) {
                                    msg = messages.FRACTION_MAX.replace(/\{MAX\}/g, maxFractionDigit);
                                }
                            }
                            else{
                                $.dr.logError("maximum fraction digits are not valid numbers.");
                            }
                        }
                    }
                    
                    if (msg !== "" && fieldValidationEnabled) {
                        isValid = false;
                        var errMsg = buildErrorMessage(val, jObj.data('label'), msg, format, exampleText);
                        $(obj.form).dr.form.throwError(obj, drDataType, errMsg, inline);
                    }
                    else {
                        $(obj.form).dr.form.removeError(obj, drDataType);
                    }
                }
                
            }
            return isValid;
        },
        
        required: function(obj, val, inline, fieldValidationEnabled){
            var isValid = true;
            var required = (obj.getAttribute('data-required') == 'true') ? true : false;
            if (required) {
                switch (obj.type) {
                    case 'select-one':
                    case 'text':
                    case 'password':
                    case 'textarea':
                        isValid = (val !== null) ? !(val + "").isBlank() : false;
                        break;
                    case 'checkbox':
                    case 'radio':
                        var radios = $(obj.form[obj.name]);
                        isValid = (radios.filter(':checked').length > 0) ? true : false;
                        // we want the error to show above the first radio, so reassign the obj to the first radio
                        obj = radios[0];
                        if (!isValid) {
                            // find the label in the DT above this DD
                            var label = $(obj).parents('dl:first').find('dt:first label').text();
                            $(obj).data('label', (label.length > 0) ? label.replace(':', '') : 'A selection');
                        }
                        break;
                    case 'select-multiple':
                        isValid = (val !== null) ? !(val + "").isBlank() : false;
                        break;
                }
                if (!isValid && fieldValidationEnabled) {
                    var errMsg = buildErrorMessage(val, $(obj).data('label'), messages.REQUIRED);
                    $(obj.form).dr.form.throwError(obj, 'required', errMsg, inline);
                }
                else {
                    $(obj.form).dr.form.removeError(obj, 'required');
                }
            }
            return isValid;
        },
        
        customValidator: function(obj, val, inline, fieldValidationEnabled){
            var isValid = true;
            var customValidatorSrc = obj.getAttribute('data-custom-validator');
            if (customValidatorSrc) {
                if (fieldValidationEnabled) {
                    // Perform eval() in the context of the DOM element, to handle possible use of keyword 'this'
                    var checkCustom = (function(){
                        return eval(customValidatorSrc);
                    }).call(obj);
                    // Only flag this as invalid if Boolean false was returned
                    if (checkCustom === false) {
                        isValid = false;
                        var customValidatorMsg = obj.getAttribute('data-custom-validator-message');
                        if (customValidatorMsg) {
                            $(obj.form).dr.form.throwError(obj, 'custom', customValidatorMsg, inline);
                        }
                    }
                }
                if (isValid) {
                    $(obj.form).dr.form.removeError(obj, 'custom');
                }
            }
            return isValid;
        },
        
        maxLength: function(obj, val, inline, fieldValidationEnabled){
            var isValid = true;
            var jObj = $(obj);
            var maxLength = jObj.attr('data-maxlength');
            if (maxLength !== undefined) {
                if (!isNaN(maxLength) && fieldValidationEnabled) {
                    if (obj.type == "textarea") {
                        var truncate = (jObj.attr('data-force-truncate') == "true") ? true : false;
                        isValid = $.dr.utils.validateTextAreaLength(obj, maxLength, truncate);
                    }
                    else {
                        var byteCount = DR.Utils.FormUtils.getUTF8Bytes(val).byteCount;
                        isValid = (byteCount <= maxLength) ? true : false;
                    }
                }
                if (!isValid) {
                    var errMsg = messages.CHAR_LENGTH.replace(/\{LABEL\}/g, $(obj).data('label')).replace(/\{MAX_CHARS\}/g, maxLength);
                    $(obj.form).dr.form.throwError(obj, 'maxlength', errMsg, inline);
                }
                else {
                    $(obj.form).dr.form.removeError(obj, 'maxlength');
                }
            }
            return isValid;
        }
        
    }
    
    /******************************************************************************
     * Validates if a value is valid for a given dataType
     * Example: <code>dr.isDataValidForType(dataType,val,format)</code><br />
     * @return {Boolean} True or false depending on whether the string is a valid time
     *****************************************************************************/
    $.dr.form.isDataValidForType = function(dataType, val, format, obj){
        var method = DATA_TYPES[dataType.toLowerCase()];
        if (dataType === undefined) {
            return undefined;
        }
        else {
            return method[2].call(this, val, format, obj);
        }
    }
    
    
    
    
    /******************************************************************************
     * $.dr.form.addValidators()
     *
     * @public
     *
     * Add a new validator, if the name is the same as an existing validator, it
     * will overwrite it. The validator will be available across all forms on
     * the page.
     *
     * Multiple validators can be passed in at one time.
     *
     * Example:
     *
     * $.dr.form.addValidators(
     *      myCustomDataType: [
     *          "The value {VALUE} for {LABEL} is in the wrong format {FORMAT}. An example would be {EXAMPLE}",
     *          "SomeCustomValue",
     *          function(val,format){
     *              if(obj.value!='SomeCustomValue'){
     *                  return false;
     *              }else{
     *                  return true}
     *              }
     *          }
     *      ],
     *      next validator...
     *  )
     *
     * The validator itself is an object with a name. To active the validator on the page you would add
     * inline attributes to a field.
     *
     * Example to call the previous validator:
     *
     * <input type="text" name="somename" id="somename" my-custom-validator="true" />
     *
     * @return VOID
     *
     *****************************************************************************/
    $.dr.form.addValidators = function(customValidators, dataAattribute){
        if (typeof customValidators == 'object') {
            validationAttributes.push(dataAattribute);
            $.extend(validators, customValidators);
        }
    }
    
    $.dr.form.addValidationSelector = function(c) {
        selectorsToValidate.push(c);
    };

    $.dr.form.getValidationSelectors = function() {
        return selectorsToValidate;
    };
    
    /******************************************************************************
     * $.dr.form.addDataTypeValidator()
     *
     * @public
     *
     * Add a new dataType validator, if the name is the same as an existing validator, it
     * will overwrite it. The validator will be available across all forms on
     * the page.
     *
     * Multiple dataType validators can be passed in at one time.  Each validator consists of an array with three parts.
     *  [0] = The message that will be display when the condition is not met
     *      {VALUE} will be replaced with the current value of the field
     *      {LABEL} will be replaced with the label for the field
     *      {FORMAT} will be replaced with the data-format="" attribute value, if present
     *  [1] = If "{EXAMPLE}" is present in the error message string, it wil be replaced with this value
     *  [2] = Function that will be run for the validtor
     *
     * Example:
     *
     * $.dr.form.addDataTypeValidator(
     *      {
     *          myCustomDataType: [
     *              "The value {VALUE} for {LABEL} is in the wrong format {FORMAT}. An example would be {EXAMPLE}",
     *              "SomeCustomValue",
     *              function(val,format){
     *                  if(obj.value!='SomeCustomValue'){
     *                      return false;
     *                  }else{
     *                      return true}
     *                  }
     *              }
     *          ],
     *          anotherCustomDataType: [
     *              "The value {VALUE} for {LABEL} is in the wrong format {FORMAT}. An example would be {EXAMPLE}",
     *              "###.##",
     *              function(val,format){
     *                  if(obj.value!='SomeOtherCustomValue'){
     *                      return false;
     *                  }else{
     *                      return true}
     *                  }
     *              }
     *          ]
     *      }
     *  )
     *
     * The validator itself is an object with a name. To active the validator on the page you would add
     * inline attributes to a field.
     *
     * Example to call the previous validator:
     *
     * <input type="text" name="somename" id="somename" data-type="myCustomDataType" value="" />
     *
     * @return VOID
     *
     *****************************************************************************/
    $.dr.form.addDataTypeValidator = function(customDataTypes){
        if (typeof customDataTypes == 'object') {
            $.extend(DATA_TYPES, customDataTypes);
        }
    }
    
    
    /*
     var getValidatableFields = function(formObj){
     var fields = $("textarea,select,:text,:radio,:checkbox,:file",formObj);
     return 'not implemented';
     }
     */
    /******************************************************************************
     * $.dr.form.validateField
     *
     * @public
     *
     * Validates the field against any rules setup
     *
     * @return BOOL
     *
     *****************************************************************************/
    $.dr.form.validateField = function(obj, inline){
        try {
            var jObj = $(obj);
            
            // check to see if form validation is enabled. If it enabled, check to 
            // see if field validation is enabled. 
            var fieldValidationEnabled = ($(obj.form).dr.form.isValidationEnabled()) &&
            (jObj.data('validationEnabled') !== false);
            
            var val = jObj.val();
            var label = jObj.data('label');
            if (!label) {
                label = $.dr.utils.getLabel(obj);
                jObj.data('label', label);
            }
            
            var isValid = true;
            var conditionalOK = true;
            var conditionalValidation = jObj.attr('data-conditional-validation');
            if (conditionalValidation) {
                // Perform eval() in the context of the DOM element, to handle possible use of keyword 'this'
                var conditionalResult = (function(){
                    return eval(conditionalValidation);
                }).call(obj);
                // Only flag this as invalid if Boolean false was returned
                if (conditionalResult === false) {
                    conditionalOK = false;
                    $(obj.form).dr.form.removeErrors(obj);
                }
            }
            
            if (conditionalOK) {
                // Iterate through all validators 
                for (var validator in validators) {
                    var result = validators[validator].call(this, obj, val, inline, fieldValidationEnabled);
                    if (!result) {
                        isValid = false;
                    }
                }
            }
            $(document).trigger("dr-afterValidateField");
            return isValid;
        } 
        catch (e) {
            $.dr.utils.logError('Javascript exception when validating field (id=' + obj.id + ')', e);
        }
    };
    
    var pasteEventName = ($.browser.msie) ? 'paste' : 'input';
    var buttonRE = /button/i;
    var hasValidationAttribute = function(formElement){
        for (var i in validationAttributes) {
            if (formElement.getAttribute(validationAttributes[i])) {
                return true;
            }
        }
        return false;
    };
    var isBlurOrChangeEvent = function(eventType){
        return (eventType === 'focusout') || (eventType === 'change');
    };
    var initValidation = function($fields){
    
        // "$fields" is a reference to a jquery collection of all the fields in the form
        
        if ($fields.length > 0) {
        
            var formValidator = $(this.formObj).data('formValidator');
            if (formValidator) {
            
                // Apply field-level validation using event delegation on the form element
                $(this.formObj).bind('click focusout change keyup ' + pasteEventName, function(e){
                    var eligible = false;
                    var eventType = e.type;
                    var formElement = e.target;
                    var $field = $(formElement);
                    // First make sure this is a "validateable" field
                    if ($field.is(':input:not(:button)') && hasValidationAttribute(formElement)) {
                        if (eventType === 'click') {
                            // for radio buttons and checkboxes, we need to validate when they click on an element
                            if ($field.is('input:radio,input:checkbox')) {
                                eligible = true;
                            }
                        }
                        else 
                            if ($.browser.mozilla && $field.is('input:file') && isBlurOrChangeEvent(eventType)) {
                                // file inputs - firefox only
                                eligible = true;
                            }
                            else 
                                if ($field.is('input:text,input:password,select,textarea') && (isBlurOrChangeEvent(eventType) || formElement.getAttribute('data-maxlength'))) {
                                    // validation for blur and change events, or keyup and paste events if it has a data-maxlength attribute
                                    eligible = true;
                                }
                    }
                    if (eligible) {
                        $.dr.form.validateField(formElement, true);
                    }
                });
                //DR_Utils_Profiler.log("VALIDATION -  Bind blur, keyup, click events");
                
                // Fast filter, only loops once
                var _timeStamp = (new Date()).getTime();
                var $fieldsWithValidation = $fields.filter(function(count){
                    if (buttonRE.test(this.type) || buttonRE.test(this.nodeName) || !hasValidationAttribute(this)) {
                        return false;
                    }
                    else {
                        // if the field doesn't have an ID attribute, set one 
                        if (!this.getAttribute('id')) {
                            this.setAttribute('id', 'rndID_' + _timeStamp + "_" + count);
                        }
                        return true;
                    }
                });
                //DR_Utils_Profiler.log("VALIDATION -  finished filtering "+$fieldsWithValidation.length+" fields with validation");
                
                if ($fieldsWithValidation.length > 0) {
                    formValidator.fieldsWithValidation = $fieldsWithValidation;
                }
            }
        }
        
    };
    
    $.dr.addPlugin('form', initValidation);
    
    var formValidator = function(formObj, options){
        options = $.dr.utils.legacyMap(options, legacyMappings);
        this.formObj = formObj;
        this.options = options;
        this.init();
    }
    
    formValidator.prototype = {
    
        init: function(){
            this.validationErrors = [];
            this.fieldsWithValidation = null;
            this.errorGroupBoxOpen = false;
            this.validationErrors = [];
        },
        
        /******************************************************************************
         * validate()
         *
         * @private
         *
         * Loops through the fields in the form that have been assigned validation.
         * If there are any errors detected, it returns false, otherwise true
         *
         * @return BOOL
         *
         *****************************************************************************/
        validate: function(){
            try {
                var $fields = this.fieldsWithValidation;
                
                if ($fields === null) {
                    return true;
                }
                var oSelf = this;
                if (!this.options.validationEnabled && this.validationErrors.length > 0) {
                    $fields.each(function(){
                        oSelf.removeErrors(this);
                    });
                    return true;
                }
                
                if (!this.options.validateHiddenFields) {
                    if (this.validationErrors.length > 0) {
                        // find any fields that are not visible
                        $fields.filter(':hidden').each(function(){
                            // remove all the errors for the field
                            oSelf.removeErrors(this);
                        });
                    }
                }

                $fields.each(function() {
                    var conditionalValidation = $(this).data().conditionalValidation;
                    if ($.isFunction(conditionalValidation)) {
                        if(conditionalValidation(this) === false) {
                            $fields = $fields.not(this);
                        }
                    }
                });

                $fields = $fields.filter(getValidationSelectorString());

                $fields.each(function(){
                    $.dr.form.validateField(this, false);
                });
                if (this.validationErrors.length > 0) {
                    this.showValidationErrors(true);
                    return false;
                }
                else {
                    this.hideErrorGroupBox();
                    return true;
                }
                
            } 
            catch (e) {
                $.dr.utils.logError('Error when validating form.', e)
            }
        },
        
        /******************************************************************************
         * obj._showErrorGroupBox()
         *
         * @private
         *
         * Show errors in box above or below the form
         *
         * @return VOID
         *
         *****************************************************************************/
        showErrorGroupBox: function(h){
            var errorDiv;
            if (this.options.groupBoxPositionAboveForm) {
                errorDiv = document.getElementById(this.formObj._formName + "_groupErrorBox");
            }
            else {
                errorDiv = document.getElementById("contentArea_groupErrorBox");
            }
            if (!errorDiv) {
                this.options.groupBoxPositionAboveForm = true;
                var parentNode = this.formObj.parentNode;
                var d = document.createElement('div');
                d.className = this.options.groupBoxClass;
                d.id = this.formObj._formName + "_groupErrorBox";
                if (this.options.groupBoxPosition == 'above') {
                    // IE breaks if we try to do it the proper way: parentNode.insertBefore(d, this);
                    // This seems to have something to do with the way the object is referenced
                    var f = this.formObj;
                    $(d).insertBefore(f);
                }
                else {
                    d.style.marginTop = "15px";
                    parentNode.appendChild(d, this);
                }
                errorDiv = d;
            }
            var s = "<div style=\"margin-bottom:10px;\"><strong>" + messages.GROUP_ERROR_BOX_TITLE + "</strong></div><ul>";
            s += h;
            s += "</ul>";
            errorDiv.innerHTML = s;
            errorDiv.style.display = 'block';
            this.errorGroupBoxOpen = true;
        },
        
        
        /******************************************************************************
         * this.hideErrorGroupBox()
         *
         * @private
         *
         * If there are no errors for the form, the error group box is hidden
         *
         * @return VOID
         *
         *****************************************************************************/
        hideErrorGroupBox: function(){
            var groupErrorBox = document.getElementById("contentArea_groupErrorBox");
            if (!groupErrorBox || this.options.groupBoxPositionAboveForm) {
                groupErrorBox = document.getElementById(this.formObj._formName + "_groupErrorBox");
            }
            if (groupErrorBox) {
                groupErrorBox.style.display = 'none';
                this.errorGroupBoxOpen = false;
            }
        },
        
        /******************************************************************************
         * hideError()
         *
         * @private
         *
         * If a field has been validated and has no errors, then we remove the error
         * css class and any inline error message
         *
         * @return VOID
         *
         *****************************************************************************/
        hideError: function(fObj, errType){
            var oSelf = this;
            var error = document.getElementById(fObj.id + "_" + errType + "_error");
            var group_error = document.getElementById(fObj.id + "_" + errType + "_group_error");
            var parentNode;
            
            if (error) {
                parentNode = error.parentNode;
                parentNode.removeChild(error);
                error = null;
                parentNode = null;
            }
            
            if (group_error) {
                parentNode = group_error.parentNode;
                parentNode.removeChild(group_error);
                group_error = null;
                parentNode = null;
            }
            
            if (oSelf.validationErrors.length === 0) {
                oSelf.hideErrorGroupBox();
            }
            else {
                if (oSelf.errorGroupBoxOpen) {
                    oSelf.showValidationErrors(false);
                }
            }
            
            if (oSelf.checkErrorExists(fObj) == -1) {
                var $fObj = $(fObj);
                $fObj.removeClass(oSelf.options.inputErrorClass);                        
            }
        },
        
        /******************************************************************************
         * obj._displayInlineError()
         *
         * @private
         *
         * If a field has an error we display the error message above or below it
         * depending on the defaults
         *
         * @return VOID
         *
         *****************************************************************************/
        displayInlineError: function(fObj, errType, errMsg, inline){
            if ((inline && this.options.showInlineErrorsOnBlur) || (!inline)) {
                var error = document.getElementById(fObj.id + "_" + errType + "_error");
                if (!error) {
                    var parentNode = fObj.parentNode;
                    
                    var a = parentNode.childNodes;
                    
                    var serverError = false;
                    for (var i = 0; i < a.length; i++) {
                        if (a[i].className == 'error') {
                            serverError = true;
                            a[i].style.display = 'none';
                        }
                    }
                    
                    var e = document.createElement('div');
                    e.className = this.options.inlineErrorClass;
                    e.innerHTML = errMsg;
                    e.id = fObj.id + "_" + errType + "_error";
                    if (this.options.inlineErrorPosition == 'above') {
                        // IE breaks if we try to do it the proper way: parentNode.insertBefore(errorDiv,fObj);
                        // This seems to have something to do with the way the object is referenced
                        var o = document.getElementById(fObj.id);
                        $(e).insertBefore(o);
                    }
                    else {
                        parentNode.appendChild(e, fObj);
                    }
                }
            }
            // safari/chrome do not show a border around file pickers, so we do not need to outline in red
            if (!($.browser.safari && fObj.type == 'file') && fObj.type != 'radio' && fObj.type != 'checkbox') {
                var $fObj = $(fObj);
                $fObj.addClass(this.options.inputErrorClass);
            }
        },
        
        /******************************************************************************
         * obj.this.showValidationErrors()
         *
         * @private
         *
         * Displays errors to the user, and focuses the error to the first error found
         * if inline errors have been enabled it displays an error next to the field.
         * If the error group box is enabled, a list of all the errors will be
         * displayed to the user above the form.
         *
         * @return VOID
         *
         *****************************************************************************/
        showValidationErrors: function(focus){
            var h = "";
            var a = this.validationErrors;
            var focusFound = false;
            for (var i = 0; i < a.length; i++) {
                var errorCanFocus = false;
                var errMsg = a[i].errMsg;
                var fObj = a[i].obj;
                var type = fObj.type;
                var errType = a[i].errType;
                
                if (this.options.showInlineErrors) {
                    this.displayInlineError(fObj, errType, errMsg, false);
                }
                
                if (this.options.focusFirstError) {
                    if (DR.Utils.FormUtils.checkAllowFocus(fObj)) {
                        if (!focusFound && focus) {
                            var e = document.getElementById(fObj.id + "_" + errType + "_error");
                            if (e) {
                                e.scrollIntoView();
                            }
                            fObj.focus();
                            focusFound = true;
                        }
                        errorCanFocus = true;
                    }
                }
                
                var linkedText = errMsg;
                if (errorCanFocus) {
                    linkedText = "<a href=\"#\" title=\"" + messages.GROUP_ERROR_BOX_ITEM_TITLE + "\" onclick=\"document.getElementById('" + fObj.id + "_" + errType + "_error').scrollIntoView();document.getElementById('" + fObj.id + "').focus();return false;\" >" + errMsg + "</a>";
                }
                
                if (this.options.groupBoxEnabled) {
                    h += "<li id=\"" + fObj.id + "_" + errType + "_group_error\" >" + linkedText + "</li>";
                }
                fObj = null;
            }
            
            if (this.options.groupBoxEnabled) {
                this.showErrorGroupBox(h);
            }
        },
        
        /******************************************************************************
         * checkErrorExists()
         *
         * @private
         *
         * Test to see if the field already has an error
         *
         * @return boolean
         *
         *****************************************************************************/
        checkErrorExists: function(fObj, errType){
            var errorIndex = -1;
            var a = this.validationErrors;
            for (var i = 0; i < a.length; i++) {
                if (a[i].obj.id == fObj.id && (a[i].errType == errType || errType === undefined)) {
                    errorIndex = i;
                    break;
                }
            }
            return errorIndex;
        },
        
        /******************************************************************************
         * throwError()
         *
         * @private
         *
         * A validation error has occurred, so we display the error if it doesn't exist
         * already on the page.
         *
         * @return BOOL
         *
         *****************************************************************************/
        throwError: function(fObj, errType, errMsg, inline){
            var errorExists = this.checkErrorExists(fObj, errType);
            
            if (errorExists == -1) {
                var e = {};
                e.errMsg = errMsg;
                e.errType = errType;
                e.obj = fObj;
                
                this.validationErrors.push(e);
                
                if (inline) {
                    this.displayInlineError(fObj, errType, errMsg, inline);
                }
                
                e = null;
                $(fObj).trigger("dr-field-throwError",[errType,errMsg]);
            }
            return errorExists;
        },
        
        /******************************************************************************
         * removeError(obj,inline)
         *
         * @private
         *
         * The field has validated true, so we test to see if an error exits in the
         * collection. If so we remove from the collection and hide the error.
         *
         * @return VOID
         *
         *****************************************************************************/
        removeError: function(fObj, errType){
            var oSelf = this;
            var errorExists = oSelf.checkErrorExists(fObj, errType);
            if (errorExists != -1) {
                oSelf.validationErrors.splice(errorExists, 1);
                setTimeout(function() {
                    oSelf.hideError(fObj, errType);
                    $(fObj).trigger("dr-field-removeError",[errType]);
                },defaults.hideErrorDelay);
            }
        },
        
        /******************************************************************************
         * removeErrors()
         *
         * @private
         *
         * Removes all errors for a given field
         *
         * @return VOID
         *
         *****************************************************************************/
        removeErrors: function(fObj){
            var oSelf = this;
            var a = this.validationErrors;
            for (var i = 0; i < a.length; i++) {
                if (a[i].obj.id == fObj.id) {
                    var errType = a[i].errType;
                    oSelf.validationErrors.splice(i, 1);
                    setTimeout(function() {
                        oSelf.hideError(fObj, errType);
                        $(fObj).trigger("dr-field-removeError",[errType]);
                    }, defaults.hideErrorDelay);
                }
            }
        }
    }
    
    var bindValidation = function(evt){
        var opts = $.extend(true, {}, defaults);
        var dataOptions = $(this).data('dataOptions');
        if (dataOptions) {
            $.extend(true, opts, dataOptions);
        }
        $(this).data('formValidator', new formValidator(this, opts));
    };
    
    // bind to all forms, or future forms created with ajax, etc
    //$('form').live('dr-beforeindexfields', bindValidation);
    //
    $(document).delegate('form', 'dr-beforeindexfields', bindValidation);   
    function getValidatorObj(collection){
        if (collection.length > 0) {
            return $(collection[0]).data('formValidator');
        }
    }
    
    /*
     * Public form API
     */
    $.namespace('dr.form', {
    
        /******************************************************************************
         * $(form).dr.form.validate()
         *
         * @public
         *
         * Validates the form, returns true or false.
         *
         * @return Bool
         *****************************************************************************/
        validate: function(){
            return getValidatorObj(this).validate();
        },
        
        /******************************************************************************
         * $(form).dr.form.enableValidation()
         *
         * @public
         *
         * Enable/Disable error validation
         *
         * @param {Bool} flag  Boolean flag to enable/disable validation
         *
         * @return VOID
         *****************************************************************************/
        enableValidation: function(flag){
            var v = getValidatorObj(this);
            v.options.validationEnabled = flag;
            v.validate();
        },
        
        /******************************************************************************
         * $(form).dr.form.isValidationEnabled()
         *
         * @public
         *
         * Enable/Disable the behavior where the first input, select, or textarea
         * is automatically focused when the page is loaded
         *
         * @param {Bool} flag  Boolean flag to enable/disable automatic focus
         *
         * @return VOID
         *
         *****************************************************************************/
        isValidationEnabled: function(){
            return getValidatorObj(this).options.validationEnabled;
        },
        
        throwError: function(obj, drDataType, errMsg, inline){
            getValidatorObj(this).throwError(obj, drDataType, errMsg, inline);
        },
        
        removeError: function(obj, errType){
            getValidatorObj(this).removeError(obj, errType);
        },
        
        removeErrors: function(obj){
            getValidatorObj(this).removeErrors(obj);
        }
        
    });
    
    /*
     * Add methods to public form.field API
     */
    $.namespace('dr.form.field', {
        /******************************************************************************
         * $(fields).dr.form.field.enableValidation()
         *
         * @public
         *
         * Enable error validation
         *
         * @return jQuery collection
         *
         *****************************************************************************/
        enableValidation: function(flag){
            // only sets flag to false if boolean false was passed in.
            flag = flag !== false;
            return this.each(function(){
                $(this).data('validationEnabled', flag);
                $.dr.form.validateField(this, flag);
            });
        }
    });
    
    
    
    
    /******************************************************************************
     *
     * @private
     *
     * Toggles the height of a textarea using css classes
     * The expanded state can be persisted by adding data-persist-state="true" to
     * the textarea.
     *
     * @return VOID
     *
     *****************************************************************************/
    var toggleTextBoxSize = function($textarea, $link, toggle){
    
        var currentHeight = ($textarea.hasClass('largeHeight')) ? 'large' : ($textarea.hasClass('mediumHeight')) ? 'medium' : 'small';
        var newHeight = currentHeight;
        
        var originalHeight = $textarea.data('originalHeight');
        if (!originalHeight) {
            var defaultHeight = $textarea.attr('data-default-height');
            if (defaultHeight !== undefined) {
                originalHeight = defaultHeight.replace('Height', '');
            }
            else {
                originalHeight = currentHeight;
            }
            $textarea.data('originalHeight', originalHeight);
        }
        
        if (toggle) {
            newHeight = (currentHeight == 'large') ? (originalHeight === 'large') ? 'small' : originalHeight : 'large';
            $textarea.addClass(newHeight + "Height").removeClass(currentHeight + "Height");
        }
        
        var title = messages.COLLAPSE_BUTTON_TOOL_TIP, text = $.dr.strings.COLLAPSE, linkClass = "collapse";
        
        if (newHeight != 'large') {
            title = messages.EXPAND_BUTTON_TOOL_TIP;
            text = $.dr.strings.EXPAND;
            linkClass = "expand";
        }
        $link.text(text).attr({
            'title': title,
            'class': linkClass
        });
        
        if ($textarea.attr('data-persist-state') == 'true' && $.dr.userdata !== null) {
            var persistPageName = $textarea.attr('data-persist-page-name');
            if (persistPageName === undefined && pageInfo) {
                persistPageName = pageInfo.pageName;
            }
            $.dr.userdata.save(persistPageName, $textarea.id + "Height", newHeight, 'String');
        }
        
    };
    
    /******************************************************************************
     * $.dr.utils.validateTextAreaLength(obj,maxLength,truncateOverride)
     *
     * @public
     *
     * Displays remaining chars for a textarea in a counter
     *
     * @return VOID
     *
     *****************************************************************************/
    $.dr.utils.validateTextAreaLength = function(obj, maxLength, truncateOverride){
        if (obj) {
            var truncate = (truncateOverride === true) ? true : defaults.truncateOnPaste;
            var alertOpen = (obj.getAttribute('alertOpen') == 'true') ? true : false;
            
            var c = document.getElementById(obj.id + "_counter");
            if (!c) {
                return;
            }
            
            var v = obj.value;
            var originalLength = v.length;
            
            if (truncate) {
                if (v.length > maxLength) {
                    v = v.substr(0, maxLength);
                }
            }
            
            var byteCount = DR.Utils.FormUtils.getUTF8Bytes(v).byteCount;
            var remaingTextLabel;
            
            if (byteCount === 0) {
                remaingTextLabel = messages.X_CHARACTERS_REMAINING.replace("{0}", maxLength);
            }
            else {
                var remaining = maxLength - byteCount;
                if (truncate) {
                    remaining = Math.max(remaining, 0);
                }
                if (byteCount > maxLength && !truncate) {
                    remaining = remaining * (-1);
                    remaingTextLabel = messages.X_OVER_THE_LIMIT.replace("{0}", remaining);
                    remaingTextLabel = remaingTextLabel.replace("{1}", maxLength);
                }
                else {
                    remaingTextLabel = messages.X_OF_Y_CHARACTERS_REMAINING.replace("{0}", remaining);
                    remaingTextLabel = remaingTextLabel.replace("{1}", maxLength);
                }
            }
            
            c.innerHTML = remaingTextLabel;
            
            var valid = true;
            if (byteCount > maxLength) {
                valid = false;
            }
            
            if (byteCount >= maxLength) {
                if (truncate) {
                    valid = true;
                    
                    var newChars = v.makeUT8CharsFitLength(byteCount, maxLength);
                    if (obj.value != newChars) {
                        obj.value = newChars;
                    }
                    
                    if ((originalLength > maxLength || byteCount > maxLength) && !alertOpen) {
                        obj.setAttribute('alertOpen', 'true');
                        var maxLengthMessage = messages.MAX_CHARS.replace(/\{LIMIT\}/g, maxLength);
                        alert(maxLengthMessage);
                    }
                    else {
                        obj.setAttribute('alertOpen', 'false');
                    }
                }
                $(obj).addClass(defaults.inputErrorClass);
                $(c.parentNode).addClass("limit");
                
            }
            else {
                $(obj).removeClass(defaults.inputErrorClass);
                $(c.parentNode).removeClass("limit");
                obj.setAttribute('alertOpen', 'false');
            }
            return valid;
        }
    };
    
    /*
     * Add enhanced behavior to a textarea
     */
    var initTextareas = function($fields){
    
        $fields.filter('textarea:not(.wysiwyg, .basic_wysiwyg)').each(function(){
            var obj = this;
            var $this = $(this);
            if ($this.data('textarea_inited')) {
                return;
            }
            var isEnhancedTextArea = false;
            var maxLength = $this.attr('data-maxlength');
            var expandCollapse = ($this.attr('data-expand-collapse') == "false") ? false : true;
            
            if ($.browser.safari) {
                //safari and chrome have their own resize handle, so we don't need to show ours
                expandCollapse = false;
                //set the max width to be equal to the current width, this prevents the user from dragging the textarea beyond the size specified in the gridSpan
                var width = parseInt(document.defaultView.getComputedStyle(obj, '').getPropertyValue('width'), 10);
                if (width > 0) {
                    obj.style.maxWidth = width + "px";
                }
            }
            if ((maxLength !== 'undefined' && parseInt(maxLength, 10) > 0) || expandCollapse) {
                isEnhancedTextArea = true;
            }
            
            if (isEnhancedTextArea) {
            
                // get the gridSpan amount to use in div class
                var objClass = obj.className;
                var gs = objClass.match(/(gridSpan[\d]+(\s|$))/);
                var gridSpan = (gs) ? gs[0] : 'gridSpan11';
                var counter = document.createElement("div");
                if (gs) {
                    counter.className = gridSpan;
                } else {
                    //else get width from textarea and assign
                    //if anyone can figure out how to detect if the textarea is set to 100% (or any %) feel free to refactor
                    //gridSpan classes for expand bar have a width of 6 pixels wider than the textarea
                    $(counter).css("width",parseInt($(obj).css("width"),10)+6 + "px");
                    $(window).bind("resize",function(){
                        $(counter).css("width",parseInt($(obj).css("width"),10)+6 + "px");
                    });
                }
                
                var inner = document.createElement("div");
                inner.className = "textareaInfo";
                
                var textareaHtml = '<table cellpadding="0" cellspacing="0" border="0" style="width:100%;" ><tr>';
                
                if (maxLength !== undefined) {
                    // Insert character counter input
                    textareaHtml += '<td class="remaining"><span id="' + obj.id + '_counter" >&nbsp;</span></td>';
                }
                if (expandCollapse) {
                    if ($.browser.safari) {
                        //safari and chrome have their own resize handle, so we don't need to show ours
                        obj.style.maxWidth = $this.width() + "px";
                    }
                    else {
                        textareaHtml += '<td class="expandCollapseButton"><a></a></td>';
                    }
                }
                
                textareaHtml += '</tr></table>';
                
                inner.innerHTML = textareaHtml;
                
                $('a', inner).click(function(){
                    toggleTextBoxSize($this, $(this), true);
                }).each(function(){
                    toggleTextBoxSize($this, $(this), false);
                });
                
                counter.appendChild(inner);
                var parent = obj.parentNode;
                $(counter).insertAfter(obj);
                if (maxLength !== undefined) {
                    var truncate = ($this.attr('data-force-truncate') == "true") ? true : false;
                    $.dr.utils.validateTextAreaLength(obj, maxLength, truncate);
                }
                $this.data('textarea_inited', 'true');
            }
        });
    };
    
    $.dr.addPlugin('form', initTextareas);
    
    var getFormMessages = function(){
        $.extend(messages, $.dr.form.getMessages());
    }
    var getFormDefaults = function(){
        $.extend(defaults, $.dr.form.getDefaults());
    }
    
    //listen for any changes to the form messages
    $(document).bind("dr-afterformsetmessages", getFormMessages);
    
    //listen for any changes to the form defaults
    $(document).bind("dr-afterformsetdefaults", getFormDefaults);
    
    //bind to the dom ready event to load the messages
    $.dr.addDomReadyEvent(getFormMessages, 'early');
    $.dr.addDomReadyEvent(getFormDefaults, 'early');
    
})(jQuery);

// Handle the tab click for the global header, a.k.a. Digital River Suite
$.dr.addDomReadyEvent(function(){

	$('#globalSuiteTab').click(function(){
		var $panel = $('#globalSuitePanel');
		var beforeClass = $panel.attr('class');
		var suiteHeight = 0;
		var speed = 750;
		var afterClass = 'globalSuiteClosed';
		if (beforeClass === 'globalSuiteClosed') {
			suiteHeight = 175;
			speed = 1000;
			afterClass = 'globalSuiteOpen';
		}
		// The animation sucks in IE6 & IE7
		if ($.browser.msie && ($.browser.version <= 7)) {
			speed = 0;
		}
		$('#globalSuiteMenu').animate({height: suiteHeight+'px'}, speed);
		$panel.removeClass(beforeClass).addClass(afterClass);
		// Make this sticky
		DR.USER_DATA.save('global', 'suitePanelState', afterClass, 'String');
	});

	window.pageIsDirty = false;
	window.markPageDirty = function(){
		pageIsDirty = true;
	};

	$('#globalSuiteMenu').find('a.globalSuiteAddLink').click(function(){
		var linkRef = this;
		var $link = $(linkRef);
		var m = ModalOverlay.open($link.attr('href'), 520, 180, $link.attr('data-modal-title'));
		m.setCancelFunction(function(){
			if (pageIsDirty) {
				location = location.href;
			}
		});
		return false;
	}).end().find('a.globalSuiteManageLink').click(function(){
			var $link = $(this);
			ModalOverlay.open($link.attr('href'), 520, 300, $link.attr('data-modal-title'));
			return false;
		});

});
;(function ($) {
    var HOVER_CLASS = ".drHover",
        HOVER_POPUP_CLASS = ".drHoverPopup",
        HOVER_POPUP_WRAPPER_CLASS = ".drHoverPopupWrapper",
        IS_IE = $.browser.msie && parseInt($.browser.version,10) <= 8,
        LOADING_CONTENT = '<span style="padding:5px;display:inline-block;">' + $.dr.strings.LOADING + '</span>',
        CLOSE_BUTTON = $("<div class='drHoverCloseButtonWrapper'><div class='drHoverCloseButton'>x</div></div>"),
        THEME_CLASSES = {
            "grey"      : {popup: "themeGrey"},
            "blue"      : {popup: "themeBlue"},
            "green"     : {popup: "themeGreen"},
            "lightBlue" : {popup: "themeLightBlue"},
            "red"       : {popup: "themeRed"},
            "orange"    : {popup: "themeOrange"}
        },
        IEversion = (($.browser.msie) ? parseInt($.browser.version,10) : null),
        //due to the arrow and popup being differenst elements, higher values can result in ugly looking fadeins and fadeouts especially due to the shadow
        POPUP_FADE_SPEED = 0,
        excanvasLoading = false,
        currentHoverIDCount = 0,
        callbackQueue = [],
        excanvasLoadCallback = function(){
        for (var i = 0; i < callbackQueue.length; i++) {
                callbackQueue[i]();
            }
        },
        //collection of all current active hover instances indexed by a unique hover id
        Hovers = [],
        //default options
        defaults = {
            customClass :                   "",
            popupMouseOutDelay :            200,
            targetMouseOutDelay :           100,
            targetMouseInDelay :            100,
            showArrow :                     false,
            position :                      "l-r",
            customContent :                 null,
            url:                            null,
            ajaxOptions:                    null,
            offsets :                       {x: 0, y: 0},
            preferredAltPositions :         [],
            proxyTarget :                   null,
            proxyAnchor :                   null,
            useClickEvent :                 false,
            cache :                         false,
            arrowLength :                   8,
            arrowBaseLength :               15,
            minimumEdgeOffset :             8,
            arrowCruxOffset :               {x: 0, y: 0},
            theme :                         "lightBlue",
            excludeBorder:                  false,
            minimumRelcalculationDimension: 10,
            maxWidth:                       600,
            maxHeight:                      null,
            zIndex:                         8,
            inline:                         false,
            shared:                         true,
            showCloseButton:                false,
            sticky:                         false /* Sticky turns Hover into a popup which can only be closed by clicking the close button OR hiding it via the public API... */
        },
        addThemeClass = function (newThemeClass) {
            THEME_CLASSES = $.extend({}, THEME_CLASSES, newThemeClass);
        },
        isDefined = function(aVar) {
            return (typeof(aVar)!=="undefined" && aVar!==null);
        },
        /**
         *Search the global Hovers collection
         */
        getHoverFromID = function (hid) {
            for(var i = 0; i < Hovers.length;i++) {
                for (var dataIndex in Hovers[i].hoverData) {
                    if (Hovers[i].hoverData.hasOwnProperty(dataIndex)) {
                        if (Hovers[i].hoverData[dataIndex].HoverID === hid) {
                            return Hovers[i];
                        }
                    }
                }
            }
            return null;
        },
        getHoverDataFromTarget = function(target) {
            var $target = $(target);
            for(var i = 0; i < Hovers.length;i++) {
                for (var dataIndex in Hovers[i].hoverData) {
                    if (Hovers[i].hoverData.hasOwnProperty(dataIndex)) {
                        if (Hovers[i].hoverData[dataIndex].Target === $target[0]) {
                            return Hovers[i].hoverData[dataIndex];
                        }
                    }
                }
            }
            return null;
        },
        setPopupMouseOutDelay = function(hid, timeout) {
            this.hoverData[hid]["popupMouseOutDelay"] = timeout;
        },
        cancelPopupMouseOutDelay = function(hid) {
            clearTimeout(this.hoverData[hid]["popupMouseOutDelay"]);
            this.hoverData[hid]["popupMouseOutDelay"] = null;
        },

        setTargetMouseOutDelay = function(hid, timeout) {
            this.hoverData[hid]["targetMouseOutDelay"] = timeout;
        },
        cancelTargetMouseOutDelay = function(hid) {
            clearTimeout(this.hoverData[hid]["targetMouseOutDelay"]);
            this.hoverData[hid]["targetMouseOutDelay"] = null;
        },

        setTargetMouseInDelay = function(hid, timeout) {
            this.hoverData[hid]["targetMouseInDelay"] = timeout;
        },
        cancelTargetMouseInDelay = function(hid) {
            clearTimeout(this.hoverData[hid]["targetMouseInDelay"]);
            this.hoverData[hid]["targetMouseInDelay"] = null;
        },
        setRequest = function(request, hid) {
            this.hoverData[hid]["request"] = request;
        },
        abortRequest = function(hid) {
            var data = this.hoverData[hid];
            if (data.request != null) {
                data.request.abort();
                data.request = null;
            }
        },
        /**
         *Returns the Hover ID associated with this target. Target must be passed as a DOM element
         */
        getHoverIDFromTarget = function(target) {
            return $.data($(target)[0],"HoverID");
        },
        getHoverData = function (hid) {
            return this.hoverData[hid];
        },
        getHoverElemFromHID = function (hid) {
            if (isNaN(hid)) {
                return null;
            }
            return getHoverData.call(this, hid).HoverPopup;
        },
        setHoverPopup = function (newPopup,hid) {
            this.hoverData[hid]["HoverPopup"] = newPopup;

        },
        setNewHoverPopupOwner = function(popup, newHid) {
            $.data(popup[0], "HoverID", newHid);
            if (this.options.shared === true) {
                for (var dataIndex in this.hoverData) {
                    if (this.hoverData.hasOwnProperty(dataIndex) && dataIndex != newHid) {
                        var data = this.hoverData[dataIndex];
                        data.hidden = true;
                        data.hasPopup = false;
                    }
                }
            }
            getHoverData.call(this, newHid).hidden = false;
            getHoverData.call(this, newHid).hasPopup = true;
        },
        setHoverTarget = function (newTarget, hid) {
            this.hoverData[hid]["Target"] = newTarget
        },
        getHoverTarget = function (hid) {
            return this.hoverData[hid]["Target"];
        },
        /**
         *Return the popup for the given target. target can either be the actual DOM element or the hover ID itself
         */
        getHoverPopup = function (target) {
            var hid = isNaN(target) === true ? getHoverIDFromTarget.call(this,target) : target;
            return this.hoverData[hid].HoverPopup
        },
        getElementFromEvent = function(e,type) {
            switch (e.type) {
                case "mouseenter":
                case "mouseover":
                    var toElement = e.target;
                    var fromElement = e.relatedTarget;
                    break;
                case "mouseleave":
                case "mouseout":
                    var toElement = e.relatedTarget;
                    var fromElement = e.target;
                    break;
            }
            return (type === "toElement") ? toElement : fromElement;
        },
        getToElement = function(e) {
            return getElementFromEvent(e,"toElement");
        },
        getFromElement = function(e) {
            return getElementFromEvent(e,"fromElement");
        },
        fadeInPopup = function(popup, data) {
            popup[0].style.display = "block";
            if (popup.length === 2) {
                popup[1].style.display = "block";
            }
            if (IEversion != null && IEversion < 9) {
                if ($.browser.msie && parseInt($.browser.version,10) < 9) {
                    if ($.data(popup[0], "shadowFilter")) {
                        popup[0].style.filter = $.data(popup[0], "shadowFilter")+"";
                    }
                }
            }
        },
        /*
            Given an element determine if we can extract the hover id either its parents or itself and return it
        */
        extractHoverIDFromCollection = function(element) {
            var $element = $(element);
            var hid = getHoverIDFromTarget(element);
            if (isDefined(hid)) {
                return hid;
            }
            return getHoverIDFromTarget($element.parents(".drHoverPopup:first,.drHover:first"));
        },
        /*
         * Move the popup next to the target if inline and sharedpopup is true
         *
         */
        moveInlinePopup = function(target) {
            var popup = getHoverPopup.call(this, target);
            $(target).after(popup.detach());
            if (this.options.showArrow === true) {
                var a = this.getArrow(target);
                $(target).after($(a).detach());
            }

        },
        /**
         * Handles/routes the mouse events for hovering over the anchor
         * @param {Object} e
         * @param {Object} currentHover
         */
        manageChangeEvents = function (type, relatedTarget, target, currentHover) {
            var oThis = currentHover;
            var hoverTargetClass = (oThis.getOption("proxyTarget") !== null) ? oThis.getOption("proxyTarget").slice(1) : HOVER_CLASS.slice(1);
            var hid = $.data(this,"HoverID");
            var thisHover = getHoverFromID(hid);
            if (isDefined(thisHover) && (thisHover.getOption("useClickEvent") || thisHover.options.sticky === true)) {
                //Canceling Hover change event;
                return false;
            }
            var dThis = this;
            cancelPopupMouseOutDelay.call(thisHover, hid);

            if ((type === "mouseenter" || type === "mouseover") && !$(relatedTarget).is("." + hoverTargetClass + ",#" + hoverTargetClass)) {
                var targetParent = $(relatedTarget).parents("." + hoverTargetClass + ",#" + hoverTargetClass).last();
                if (targetParent.length >= 1) {
                    relatedTarget = targetParent[0];
                } else {
                    return false;
                }
            }
            var ca = oThis.getArrow(hid);
            if (type === "mouseleave" || type === "mouseout") {
                 //Don't start timeout if we moused INTO the the popup or the arrow
                 //if mousing over another popup (shared==false), we should still hide it
                if (( ($(relatedTarget).is(".drHoverPopup")===false && oThis.options.shared===true) || oThis.options.shared === false) && (!isDefined(ca) || isDefined(ca) && relatedTarget != ca[0])) {
                    cancelTargetMouseInDelay.call(thisHover, hid);
                    setTargetMouseOutDelay.call(oThis, hid,
                        setTimeout(function () {
                            oThis.deactivateHover(type, relatedTarget, target, hid);
                        }, oThis.getOption("targetMouseOutDelay")));
                }
            }
            if (type === "mouseenter" || type === "mouseover") {
                cancelTargetMouseOutDelay.call(thisHover, hid);
                //Don't start timeout if we moused out from the popup or the arrow
                if ($(relatedTarget).is(".drHoverPopup")===false && (!isDefined(ca) || isDefined(ca) && relatedTarget != ca[0])) {
                    var newTimeout = setTimeout(function () {
                        oThis.changeHoverElement(relatedTarget);
                    }, oThis.getOption("targetMouseInDelay"));
                    setTargetMouseInDelay.call(oThis, hid, newTimeout);
                }
            }
        },
        /*
         * Sharing is caring
         */
        setSharedPopup = function (p) {
            this.sharedPopup = p;
        },
        /*
         * The popup that is shared by all the Hover elements
         */
        getSharedPopup = function () {
            return this.sharedPopup;
        },
      /**
         * Add the given target to the hover data collection for this hover instance. There will be multiple hovers in Hoverdata per element
         * @param{Object} target The anchor element
         */
        addTargetToHoverData = function (target) {
            var hid = currentHoverIDCount++;
            hid = "_"+hid;
            var $target = $(target);
            var inlineOpts = $.dr.utils.evalString($target.attr("data-options-hover"));
            inlineOpts = inlineOpts || {};
            var opts = $.extend(true,{}, this.options, inlineOpts);
            opts.proxyElement = isDefined(opts.proxyTarget) ? $(opts.proxyTarget) : null;
            opts.bindingElement = opts.proxyElement || $target;
            this.hoverData[hid] = {
                "Target": target,
                "request": null,
                "HoverID": hid,
                "options": opts,
                //"disabled": opts.useClickEvent,
                "hidden": true,
                "proxyAnchor": getProxyAnchor.call(this, opts.proxyAnchor, $target)
            };

            $.data(opts.bindingElement[0], "HoverID", hid);
            return hid;
        },
        /**
         * Add the hover instance to the global Hovers collection
         * @param{Object} hid The ID for the hover for use as the index
         * @param{Object} hoverInstance The hover instance to add
         */
        addHoverToHovers = function(hoverInstance) {
            for (var i = 0; i < Hovers.length;i++) {
                if (Hovers[i] === hoverInstance) {
                    return false;
                }
            }
            Hovers.push(hoverInstance);
        },
        /**
         * Returns the popup for the given target DOM element
         */
        getPopupFromTarget = function (target) {
            var oThis = this;
            for (var i in oThis.hoverData) {
                if (oThis.hoverData.hasOwnProperty(i)) {
                    if (oThis.hoverData[i] && oThis.hoverData[i].Target === target) {
                        return oThis.hoverData[i].HoverPopup;
                    }
                }
            }
            return null;
        },
        /**
         * Logic for clicking the anchor element to show the hover
         * @param{Object} ht The target to bind to if there is not a proxy target
         */
        bindClickEvent = function (bindingElement) {
            var oThis = this;
            $(bindingElement).bind("click", function (e) {
                var data = getHoverDataFromTarget.call(oThis, this);
                if (oThis.getClicked(data.HoverID) === false) {
                    oThis.activateHover((data.proxyAnchor || data.Target), false);
                } else {
                    oThis.hide(data.HoverPopup);
                    if ($(e.target).is(".drHover") && e.target != data.Target) {
                        $(e.target).trigger("click");
                    }
                }
            });
             //Commenting this out for now. There are many cases where you don't want this functionality and I think it is cleaner to have those cases specify when they want to close the hover
            // $(document).bind("click.hoverClick", function(event){
            //     var $etarget = $(event.target), $eparents = $etarget.parents();
            //     //if elem is not attached to dom, return here
            //     if ($eparents.last().is("html") === false) {
            //         return false;
            //     }
            //     if(!($eparents.andSelf().is('.drHoverPopup,.drHover'))) {
            //        oThis.hideClickEnabledHovers();
            //     }
            // });
        },
        //Binding events for mouseout/mouseenter
        bindToObj = function(bindingElement) {
            var oThis = this;
            $(bindingElement).each(function() {
                $(this).bind("mouseenter.drHover mouseleave.drHover", function (e) {
                    var toElement = getToElement(e);
                    var fromElement = getFromElement(e);
                    manageChangeEvents.call(this, e.type, toElement, fromElement, oThis);
                });
            });
        },
        /**
         *
         */
        bindClickAnchorEvent = function(bindingElement, data) {
            var oThis = this;
            oThis.setClicked(false, data.HoverID)
            if (this.options.useClickEvent === true) {
                this.options.targetMouseInDelay = (this.options.useClickEvent === true) ? 1 : this.options.targetMouseInDelay;
                //oThis.disable(data.HoverID);
                bindClickEvent.call(this, bindingElement);
            }
        },
        /*
         * Bind the mouse in/out events to trigger the popup. because you can have a proxy element, bindelement and targetelement can be different. if there is
         * a proxy element, then that proxy element will be the bindingelement.
         */
        bindAnchorEvent = function(bindingElement) {
            var oThis = this;
            bindToObj.call(this, bindingElement);
            //TODO redo the delegateOn functionality
        },
        /*
         * Hide all hover popups on the screen
         */
        hideAllPopups = function() {
            var popups = $(".drHoverPopup");
            for(var i = 0; i < Hovers.length; i++) {
                Hovers[i].hideAll();
            }
        },
        setHoverDimensionsWithContent = function(popup, content, callback, target, skipCallback) {
            var opts = this.options;
            var $dynamicWidthContainer = $("#getDynamicWidth");
            $dynamicWidthContainer = ($dynamicWidthContainer.length===0) ? $(document.createElement("div")).attr("id","getDynamicWidth") : $dynamicWidthContainer;
            var wrappedContent = $(document.createElement("div")).addClass("hoverContent").append(content);
            if (opts.theme !== null) {
                popup.addClass(THEME_CLASSES[opts.theme].popup);
            }
            if (this.options.customClass !== "") {
                popup.addClass(this.options.customClass);
            }
            if (opts.maxHeight != null) {
                $dynamicWidthContainer.css("max-height", opts.maxHeight+"px");
            }
            if (opts.maxWidth != null) {
                $dynamicWidthContainer.css("max-width", opts.maxWidth+"px");
            }
            if ($dynamicWidthContainer.parent().length===0) {
                $dynamicWidthContainer.prependTo("body");
            } else {
                $dynamicWidthContainer.removeClass();
                $dynamicWidthContainer[0].style.height = "";
                $dynamicWidthContainer[0].style.width = "";
            }
            $dynamicWidthContainer.addClass(popup[0].className).html(wrappedContent);
            var box = $dynamicWidthContainer[0].getBoundingClientRect();
            var bWidth = parseInt($dynamicWidthContainer.css("borderWidth"),10)*2;
            var dynamicWidth = ((box.width || (box.right - box.left))-bWidth || $dynamicWidthContainer.width()) + (IEversion===9 ? 1 : 0); //IE9s calc is a bit off
            var dynamicHeight = (box.height  || (box.bottom - box.top))-bWidth || $dynamicWidthContainer.height();
            popup.css("width", 1+dynamicWidth+"px");
            popup.css("height", dynamicHeight+"px");
            popup.html(wrappedContent);
            if (opts.maxHeight != null && dynamicHeight > opts.maxHeight ) {
                popup.css("height", opts.maxHeight+"px");
            }
            if (opts.maxWidth != null && dynamicWidth > opts.maxWidth) {
                popup.css("width", opts.maxWidth+"px");
            }
            this.drawPopup(popup, target);
            popup.trigger("dimensionsChanged");
            if (this.options.showCloseButton === true) {
                this.drawCloseButton(popup,target);
            }
            //skip draw callback, because after ajaxload it has already been positioned
            if ( typeof(callback) === "function" && skipCallback !== true) {
                callback.call(this, target);
            }
            $(target).trigger("dr-afterRender", [this, content]);
       },
       //t is for target
       getProxyAnchor = function(t, target) {
            if (typeof t === "object") {
                return t;
            }
            t = t.trim();
            if (t.charAt(0) === ">") {
                return target.find(t.substring(1).trim());
            } else {
                return $(t)
            }
            return null;
       },
       cacheDimensions = function($elem) {
            var bWidth = parseInt($elem.css("borderWidth"),10);
            var cd = $elem.data("cachedDimensions");
            $elem.data("cachedDimensions", cd.extend({},cd,{borderWidth:bWidth}));
       },
       filterCollectionForFixed = function(jqArray) {
        var isFixed = false;
        for (var i = 0; i < jqArray.length; i++) {
            if($(jqArray[i]).css("position") === "fixed") {
                isFixed = true;
                break;
            }
        };
        return isFixed;
    }
    var Hover = function (elem, opts) {
        this.cachedContent = null;
        this.options = {};
        $.extend(this.options, defaults, opts);
        sharedPopup = null;
        //Collection of the individual target hovers
        this.hoverData = {};
        this.usingPosition = null;
        this.init($(elem), this.options);
    };

    Hover.prototype = {
        /**
         * Initilize the Hover
         * @param {Object} $target
         * @param {Object} opts
         */
        init : function ($target, opts) {
            var oThis = this;
            this.fixedContainer = filterCollectionForFixed($target.parents());
            if (this.fixedContainer === true) {
                this.options.inline = true;
            }
            this.HoverArrow = $.dr.hover.setupHoverArrow(this);
            $target.each(function () {
                //Store the target's title attribute to data, otherwise it can interfere visually
                var t = $(this).attr("title"), $this = $(this);
                if (t) {
                    $this.data("title",t);
                    $this.removeAttr("title");
                }
                var data = oThis.hoverData[addTargetToHoverData.call(oThis, this)];
                bindAnchorEvent.call(oThis, data.options.proxyElement || data.options.bindingElement);
                bindClickAnchorEvent.call(oThis, data.options.proxyElement || data.options.bindingElement, data);
            }).addClass(HOVER_CLASS.slice(1));
            addHoverToHovers(oThis);
        },
        addNewHover : function(target, opts) {
            var existingData = getHoverData.call(this, getHoverIDFromTarget.call(this, target));
            var newHoverData = $.extend(true, {}, existingData, opts);
            var additionalHoversList = existingData.additionalHovers;
            if (isDefined(additionalHoversList)) {
                existingData["additionalHovers"] = [newHoverData];
            } else {
                additionalHoversList.push(newHoverData);
            }
            //need to bind mouse event for the proxy element
        },
        drawCloseButton : function(popup,target) {
            var oThis = this;
            var $existingButton = popup.find(".drHoverCloseButtonWrapper");
            if ($existingButton.length === 1) {
                $existingButton.remove();
            }
            var $clonedButton = CLOSE_BUTTON.clone();
            var b = parseInt(popup.css("border-left-width"), 10);
            if (isDefined(b) && b > 0) {
                $clonedButton.css("top", b+"px");
            }
            popup.find(".hoverContent").before($clonedButton.unbind("click.hoverCloseClick").bind("click.hoverCloseClick", function(){
                var doClose = $(target).trigger("dr-closeHoverButton.hover", [oThis,popup]);
                if (doClose === false) {
                    return true;
                }
                oThis.setClicked(false, getHoverIDFromTarget.call(oThis, popup));
                oThis.hide(popup, true);
            }));
        },
        /**
         * Run snapTo with the given options and offsets, with target as the anchor
         * @param {Object} elem
         * @param {Object} hover_coords
         * @param {Object} anchor_coords
         */
        position: function(target, popup, offs, options) {
            var _this = this;
            var data = getHoverData.call(this, getHoverIDFromTarget(popup));
            data.offsets = offs.hasOwnProperty("x") ? $.extend({}, offs) : data.offsets;
            $(data.HoverPopup).dr.snapTo(target, {
                position : data.options.position,
                offset : {
                    x : offs.x,
                    y : offs.y
                },
                inline: data.options.inline || this.options.inline,
                customClass: HOVER_POPUP_WRAPPER_CLASS.slice(1),
                minimumRelcalculationDimension : options.minimumRelcalculationDimension,
                excludeBorder: false,
                preferredAltPositions : options.preferredAltPositions
            });
        },
        /*
         * Draw hover arrow and attach to the hover in a logical position
         * @param{Object} target The anchor element and positioning the hover to
         * @param{Object} rePositioned Whether we have repositioned the hover again
         */
        drawArrow : function (target, hid, rePositioned,callback) {
            this.HoverArrow.draw(getHoverData.call(this, hid), $(target)[0], hid, rePositioned, callback)
        },
        getArrow : function (hid) {
            if (isDefined(hid)) {
                var data = getHoverData.call(this, hid);
                if (data == null) {
                    return null;
                }
                return data.HoverArrow || null;
            }
            return null;
        },
        /*
         * Set the current arrow element
         * @param{Object} newArrow The new arrow element
         */
        setArrow : function(newArrow, hid) {
            var data = getHoverData.call(this, hid);
            data["HoverArrow"] = newArrow;
        },
        /**
         * Logic for when the mouse enters or leaves the hover arrow
         * @param{Object} The arrow element to bind to
         */
        bindArrow : function(arrow) {
            var oThis = this;
            $(arrow).bind("mouseleave.drHover mouseenter.drHover", function (e) {
                var obj = this;
                var hid = $.data(obj,"HoverID");
                var cHover = oThis;
                if (e.type === "mouseleave" || e.type === "mouseout") {
                    var relatedTarget = e.relatedTarget;
                    cancelPopupMouseOutDelay.call(cHover, hid);
                    setPopupMouseOutDelay.call(cHover, hid,
                        setTimeout(function () {
                            if (relatedTarget != $(this)[0]) {
                                var toElement = getToElement(e);
                                var fromElement = getFromElement(e);
                                manageChangeEvents.call(obj, e.type, toElement, fromElement, oThis);
                            }
                        }, cHover.getOption("popupMouseOutDelay"))
                    );
                } else if (e.type === "mouseenter" || e.type === "mouseover") {
                    cancelPopupMouseOutDelay.call(cHover, hid);
                    cancelTargetMouseOutDelay.call(cHover, hid);
                    cancelTargetMouseInDelay.call(cHover, hid);
                }
            });
        },
        /**
         * Logic for when the mouse enters or leaves the hover popup
         * @param{Object} elem The hover popup element to bind to
         */
        bindPopup : function (elem) {
            //When mousing out of the arrow element
            var oThis = this;
            $(elem).bind("mouseleave.drHover mouseenter.drHover", function (e) {
                var obj = this;
                var hid = $.data(obj,"HoverID");
                var cHover = oThis;
                if (cHover.getOption("useClickEvent")) {
                    return false;
                }
                //Do not disable if the element being entered is the hover ARROW or the current hoverTargetClass
                if (e.type === "mouseleave" || e.type === "mouseout") {
                    var relatedTarget = e.relatedTarget;
                    cancelPopupMouseOutDelay.call(cHover, hid);
                    setPopupMouseOutDelay.call(cHover, hid,
                        setTimeout(function () {
                            var toElement = getToElement(e);
                            var fromElement = getFromElement(e);
                            if (relatedTarget != obj) {
                                manageChangeEvents.call(obj, e.type, toElement, fromElement, oThis);
                            }
                        }, cHover.getOption("popupMouseOutDelay"))
                    );
                } else if (e.type === "mouseenter" || e.type === "mouseover") {
                    cancelPopupMouseOutDelay.call(cHover, hid);
                    cancelTargetMouseOutDelay.call(cHover, hid);
                    cancelTargetMouseInDelay.call(cHover, hid);
                }
            });
        },
        //Create the popup elemnent for the hover
        createPopup: function(target) {
            var $target = $(target);
            var hp = $(document.createElement("div")).addClass(this.getOption("customClass")).addClass(HOVER_POPUP_CLASS.slice(1)).hide().css("visibility", "visible");
            var hid = $.data($target[0],"HoverID");
            $target.trigger("dr-drawPopup.hover");
            //Set for determining if we need to create a new hoverPopup when we activate a hover
            $.data(hp[0],"HoverID", hid);
            this.hoverData[hid]["HoverPopup"] = hp;
            return hp;
        },
        /**
         * Append the hover popup element to it's proper position in the DOM
         * @param {Object} target
         */
        drawPopup : function (popup, target) {
            var $target = $(target);
            if (this.options.inline === true) {
                $target.after(popup);
            } else {
                $("body").prepend(popup);
            }
            return popup;
        },
        /**
         * Set the renderContent callback and render the content into the hover
         * @param {Object} target
         * @param {Object} fn
         */
        draw : function (target, hid, callback) {
            var data = getHoverData.call(this, hid);
            var popup = data.HoverPopup;
            var oThis = this;
            this._renderContent(target, popup, function (target) {
                $(popup[0]).one("dr-afterPosition", function () {
                    popup[0].style.filter = "";
                    if ($.isFunction(callback)) {
                        callback();
                    }
                });
                //The arrow can't be seen if the offset is too small, if an offset that is large enough is NOT set we will set one here
                var offs = $.extend({}, oThis.options.offsets);
                if (oThis.getOption("showArrow")) {
                    if (isDefined(data.offsets)) {
                        offs = $.extend({}, data.offsets);
                    } else {
                        offs = {x: 0, y: 0};
                    }
                }
                oThis.position(target, popup, offs, oThis.options);
            });
        },
        /**
         * Insert content into the hover popup and call a callback, which for now is only calling draw
         * @param {Object} target
         * @param {Object} callback
         */
        _renderContent : function (target, hoverPopup, callback, contentOverride) {
            var content = null;
            var $target = $(target);
            var oThis = this, opts = this.options, popup = hoverPopup;
            if (popup == null || popup.length === 0) {
                return false;
            }
            var hid = getHoverIDFromTarget(hoverPopup);
            var data = getHoverData.call(this,hid);
            if (this.options.cache === true) {
                //TODO use the actual popup instead of just the content
                content = oThis.hoverData[$.data(target,"HoverID")]["cachedContent"] || null;
            }
            if (content === null || contentOverride != null) {
                //cancellable
                customContent = $(target).triggerHandler("dr-beforeRender", [target, popup]);
                if (customContent === false) {
                    return false;
                }
                var url = data.options.url || this.options.url;
                customContent = contentOverride || (isDefined(customContent) ? customContent : data.options.customContent || this.getOption("customContent"));
                if (url !== null || this.options.ajaxOptions !== null) {
                    var ajaxOpts = $.extend(true, {}, this.options.ajaxOptions);
                    if (url !== null && this.options.ajaxOptions === null){
                        ajaxOpts = {url:url};
                    }
                    $.extend(ajaxOpts, {
                        success : function (response, status, xhr) {
                                response = $(target).triggerHandler("dr-loadSuccess", [response, xhr]) || response.trim();
                                setHoverDimensionsWithContent.call(oThis, popup, response, callback, target, false);
                        },
                        error : function (xhr, status, errorThrown) {
                                $(target).triggerHandler("dr-loadError", [errorThrown, xhr]);
                        }});
                    setRequest.call(this, $.ajax(ajaxOpts), hid);
                    content = LOADING_CONTENT;
                    //html
                } else if (customContent!=null && typeof(customContent) === "object") {
                    content = customContent;
                    //function callback
                } else if ($.isFunction (customContent)) {
                    content = customContent.call(this, target);
                    //string content
                } else if (typeof(customContent) === "string") {
                    content = customContent;
                } else {
                    content = $target.data("title") || $(data.Target).data("title") || "";
                    this.setOption("customContent", content, hid);
                    data.options.customContent = content;
                }
            }
           setHoverDimensionsWithContent.call(oThis, popup, content, callback, target, false);
        },
        /**
         * Activate the hover for the given target and set the current target
         * @param {Object} e Mouse event
         * @param {Object} relatedTarget Normalized relatedTarget for the mouse event
         */
        changeHoverElement : function (relatedTarget) {
            if ($.data(relatedTarget,"hoverElement")) {
                relatedTarget = $.data(relatedTarget,"hoverTarget");
                var newThis = $.data(relatedTarget,"Hover");
                //this is key
                this.activateHover.call(newThis, relatedTarget);
            } else {
                this.activateHover.call(this, relatedTarget);
            }
        },
        /**
         * Deactivate other hovers for the general hover target selector or element dependingon the type
         * @param {Object} relatedTarget
         */
        deactivateHover : function (type, toElement, fromElement, hid) {
            var oThis = this;
            var thisData = getHoverData.call(oThis, hid);
            // if (thisData && thisData.clicked === true) {
            //     return false;
            // }
            //even though we will not be sharing a single popup, the behavior will be similar to sharing. unless we are mous
            if (oThis.options.shared === false) {
                var hid = null;
                switch(type) {
                    case "mouseenter":
                    case "mouseover":
                        hid = extractHoverIDFromCollection(toElement);
                        break;
                    case "mouseleave":
                    case "mouseout":
                        hid = extractHoverIDFromCollection(fromElement);
                        break;
                }
                var targetData = getHoverData.call(this,hid);
                abortRequest.call(this, hid);
                cancelPopupMouseOutDelay.call(this, hid);
                cancelTargetMouseInDelay.call(this, hid);
                this.hide(targetData.HoverPopup, $(toElement).hasClass("sticky"));
                return true;
            }
            //sharing a popup
            var hoverInUse = null;
            for (var dataIndex in this.hoverData) {
                if (this.hoverData.hasOwnProperty(dataIndex) && this.hoverData[dataIndex].hasPopup === true) {
                    hoverInUse = this.hoverData[dataIndex];
                    break;
                }
            }
            for (var dataIndex in this.hoverData) {
                if (this.hoverData.hasOwnProperty(dataIndex)) {
                    var data = this.hoverData[dataIndex];
                    //don't cancel actions if this hover is currently in use
                    if (hoverInUse == null || hoverInUse.HoverID != data.HoverID) {
                        data.activated = null;
                        abortRequest.call(this, data.HoverID);
                        cancelPopupMouseOutDelay.call(this, data.HoverID);
                        cancelTargetMouseInDelay.call(this, data.HoverID);
                        cancelTargetMouseOutDelay.call(this, data.HoverID);
                    }
                    //don't hide if the popup is currently in use by another hover id
                    //must be handled separately because hovers are sharing the popup. sharing is caring.
                    if (hoverInUse === null || hoverInUse.HoverID == hid) {
                        this.hide(data.HoverPopup);
                    }
                }
            };
        },
        /**
         * Show the hover for the given target
         * @param {Object} target
         */
        activateHover : function (target, sticky) {
            var hid = getHoverIDFromTarget.call(this, target);
            var data = getHoverData.call(this, hid);
            if (this.isDisabled(hid) === false && data.hidden === true) {
                var changedTargets = this.target != target;
                this.target = target;
                cancelPopupMouseOutDelay.call(this, hid);
                cancelTargetMouseInDelay.call(this, hid);
                //does target have a hover
                var popup = getSharedPopup.call(this) || getPopupFromTarget.call(this, target), firstRun = false;
                if (popup instanceof jQuery === false) {
                    firstRun = true;
                    popup = this.createPopup(target);
                    this.bindPopup(popup);
                    if (this.options.shared === true) {
                        setSharedPopup.call(this, popup);
                    }
                }
                setHoverPopup.call(this, popup, hid);
                //mark that this new popup / data combo is the new owner of the popup (if shared) and set the new hid in the popup
                setNewHoverPopupOwner.call(this, popup, hid);
                if (this.options.shared === true) {
                    if (this.options.inline === true) {
                        moveInlinePopup.call(this, target);
                    }
                }
                //pass real hovertarget here?
                var popupTarget = this.options.proxyAnchor ? data.proxyAnchor : data.Target;
                var oThis = this;
                this.draw(popupTarget, hid, function(){
                    popup.add(data.HoverArrow).hide();
                    oThis.show(popup, popupTarget, sticky);
                });
            }
        },
        /**
         * Retrieve option for this hover
         * @param {Object} key
         */
        getOption : function (key) {
            return this.options[key];
        },
        /**
         * Set an option for this hover
         * @param {Object} key
         * @param {Object} value
         */
        setOption : function (key, value) {
            this.options[key] = value;
        },
        /**
         *Hide all popups in this Hover instance
         */
        hideAll: function() {
            for (var dataIndex in this.hoverData) {
                if (this.hoverData.hasOwnProperty(dataIndex)) {
                    var p = this.hoverData[dataIndex].HoverPopup;
                    if (isDefined(p) === true) {
                        this.hide(p);
                    }
                }
            };
        },
        hideClickEnabledHovers : function() {
            var oThis = this;
            for(var h = 0; h < Hovers.length;h++) {
                for(var hd in Hovers[h].hoverData) {
                    if (Hovers[h].hoverData.hasOwnProperty(hd) && Hovers[h].hoverData[hd].options.useClickEvent === true && oThis.getClicked(Hovers[h].hoverData[hd].HoverID) === true) {
                        Hovers[h].setClicked(false, Hovers[h].hoverData[hd].HoverID);
                        //Hovers[h].disable(Hovers[h].hoverData[hd].HoverID);
                        Hovers[h].hide(Hovers[h].hoverData[hd].HoverPopup);
                    }
                }
            }
        },
        /**
         * hide the hover popup for the triggered target
         */
        hide : function (popup, override) {
            if (isDefined(popup) === false) {
                return;
            }
            if (this.options.sticky === true && override !== true) {
                return false;
            }
            var oThis = this, options = oThis.options;
            var hid = $.data($(popup)[0],"HoverID");
            var data = getHoverData.call(oThis,hid);
            var target = data.Target;
            if ($(target).triggerHandler("dr-beforeHidePopup.hover") === false) {
                return true;
            }
            if (data.options.useClickEvent === true) {
                oThis.setClicked(false, hid);
            }
            if (oThis.options.cache === true) {
                var cHover = getHoverData.call(oThis, hid);
                //we can't just show the current contente of the hover since shared===true is default and content can change
                var hoverContent = popup.find(".hoverContent").contents();
                //if cHover is null, search for global Hovers
                if ( typeof (cHover) === "object" && hoverContent !== "" && hoverContent.length > 0) {
                    oThis.hoverData[hid]["cachedContent"] = hoverContent;
                }
            }
            if (oThis.options.showArrow === true) {
                var ca = oThis.getArrow(hid);
                if (isDefined(ca)) {
                    ca[0].style.display = "none";
                    popup[0].style.display = "none";
                    //popup.add(ca).fadeOut(POPUP_FADE_SPEED);
                }
            } else {
                popup[0].style.display = "none";
//                popup.fadeOut(POPUP_FADE_SPEED);
            }
            data.hidden = true;
            $(target).trigger("dr-hidePopup.hover");
        },
        /**
         * Show a hover popup for the triggered target
         * @param {Object} popup
         */
        show : function (popup, target, override) {
            //Trigger a mouseover if no user action has occurred yet
            var oThis = this, $target = $(target);
            if (override !== true && this.options.sticky === true) {
                return false;
            }
            if (isDefined(popup) === false || (popup.length === 0 && popup.hasClass("snapTo_initialized") === false)) {
                oThis.changeHoverElement(target);
                return false;
            } else {
                var hid = getHoverIDFromTarget.call(oThis, popup);
                var data = getHoverData.call(this,hid);
                if (data.options.useClickEvent === true) {
                    oThis.setClicked(true, hid);
                }
                if (oThis.options.showArrow === true) {
                    var ca = oThis.getArrow(hid), targetOffsets = $target.offset(),prevOffsets = $.data($target[0],"offset");
                    if (data.options.shared || ca == null || (isDefined(prevOffsets) && (targetOffsets.left != prevOffsets.left || targetOffsets.top != prevOffsets.top))) {
                        var arrowCallback = function() {
                            ca = oThis.getArrow(hid);
                            popup.hide();
                            ca.hide();
                            if (!isNaN(oThis.options.zIndex)) {
                                    ca.css("z-index", oThis.options.zIndex+1);
                            }
                            fadeInPopup(popup.add(ca), getHoverData.call(oThis,hid));
                        }
                        if (typeof(G_vmlCanvasManager) === "undefined" && excanvasLoading === true && $.browser.msie) {
                           callbackQueue.push(function(){
                                popup.show();
                                oThis.drawArrow(target, hid, false, arrowCallback);
                            });
                        } else {
                            popup.show();
                           oThis.drawArrow(target, hid, false, arrowCallback);
                        }
                    } else {
                        fadeInPopup(popup.add(ca), getHoverData.call(oThis,hid));
                    }
                } else {
                    fadeInPopup(popup, getHoverData.call(oThis,hid));
                }
                if (!isNaN(oThis.options.zIndex)) {
                    popup.css("z-index", this.options.zIndex);
                }
                $(target).trigger("dr-showPopup.hover");
            }
            setTimeout(function(){
                $target.data("offset",$target.offset());
            },0);
            data.hidden = false;
            return true;
        },
        /*
         * Set whether this particular has been clicked
         */
        setClicked : function(clicked, hid) {
            var data = getHoverData.call(this, hid);
            if (isDefined(data)) {
                data.clicked = clicked;
            }
        },
        getClicked : function(hid) {
            var data = getHoverData.call(this, hid);
            if (isDefined(data)) {
                return data.clicked
            }
            return null;
        },
        /**
         *
         */
        disable : function (hid) {
            var data = getHoverData.call(this,hid);
            if (isDefined(data)) {
                data.disabled = true;
            }
            return null;
        },
        /**
         *
         */
        enable : function (hid) {
            var data = getHoverData.call(this,hid);
            if (isDefined(data)) {
                data.disabled = false;
            }
            return null;
        },
        /**
         *
         */
        isDisabled : function (hid) {
            var data = getHoverData.call(this,hid);
            if (isDefined(data)) {
                return data.disabled === true;
            } 
            return null;
        },
        cancelTargetMouseIn : function(elem) {
            var hid = getHoverIDFromTarget(elem);
            cancelTargetMouseInDelay.call(this, hid);
        }
    };

    $.namespace('dr', {
        hover : function (opts) {
            if ($(this).hasClass(HOVER_CLASS)) {
                return this;
            }
            var _inlineOpts = $(this).attr("data-options-hover");
            var inlineOpts = $.dr.utils.evalString(_inlineOpts);
            inlineOpts = inlineOpts || {};
            opts = opts || {};
            opts = $.extend({}, opts, inlineOpts);
            var customContentSrc = $(this).attr("data-custom-content");
            opts.element = this;
            opts.customContent = customContentSrc || opts.customContent || null;
            if (IS_IE === true && typeof window.CanvasRenderingContext2D == "undefined" && typeof G_vmlCanvasManager == "undefined" && excanvasLoading === false) {
                excanvasLoading = true;
                var path = ($.dr.FRAMEWORK_PATH.charAt($.dr.FRAMEWORK_PATH.length-1) === "/") ? $.dr.FRAMEWORK_PATH : $.dr.FRAMEWORK_PATH+"/";
                $.dr.getScript((path + "external/js-plugins/excanvas.compiled.js"), function(script, textStatus){
                    if (typeof G_vmlCanvasManager !== "undefined") {
                        G_vmlCanvasManager.init_(document);
                    }
                    excanvasLoadCallback();
                },true);
            }
            var h = new Hover(this, opts);
            return this;
        }
    });

    function getHover(obj) {
        var id = $.data($(obj)[0],"HoverID");
        //e.g. testing "_1"
        if (id && !isNaN(parseInt(id.slice(1),10))) {
            return getHoverFromID(id);
        } else {
            return null;
        }
    }
    $.dr.hover = {
        hideAllPopups:function() {
            hideAllPopups();
        },
        addTheme : function (thmClass) {
            addThemeClass(thmClass);
        }
    };
    /* Public Interface */
    $.namespace('dr.hover', {
        addNewHover : function(opts) {
            this.each(function(){
                if (this.hasClass("drHover")) {
                    $h.addNewHover(this, opts);
                }
            });
            return this;
        },
        hide : function () {
            this.each(function(i,e){
                var $h = getHover(this);
                if ($h) {
                    var popup = getHoverPopup.call($h, this);
                    $h.deactivateHover("mouseout", e, e, $.data(e,"HoverID"));
                }
            });
            return this;
        },
        show : function () {
            this.each(function(i,e){
                var $h = getHover(e);
                if ($h) {
                    setHoverTarget.call($h, e, $.data(e,"HoverID"));
                    $h.activateHover(this, $(this).hasClass("sticky"));
                }
            });
            return this;
        },
        enable : function () {
            this.each(function(i,e){
                var $h = getHover(e);
                if ($h) {
                    $h.enable($.data(e,"HoverID"));
                }
            });
            return this;
        },
        disable : function () {
            this.each(function(i,e){
                var $h = getHover(e);
                if ($h) {
                    $h.disable($.data(e,"HoverID"));
                }
            });
            return this;
        },
        getHoverContent : function () {
            var $h = getHover(this);
            if ($h) {
                //get current popup
                var popup = getHoverPopup.call($h, this);
                var currentContent = "";
                if (popup && popup.find(".hoverContent").length > 0) {
                    currentContent = popup.find(".hoverContent")[0].innerHTML;
                }
                return $h.options.customContent || ( $h.options.url!=null ? currentContent : "" );
            }
        },
        setOption : function (key, val, target) {
            var $h = getHover(this);
            if ($h) {
                var t = isDefined(target) ? target : this;
                var d = getHoverData.call($h, getHoverIDFromTarget(t));
                if (d) {
                    d.options[key] = val;
                }
            }
            return this;
        },
        refresh : function() {
            var $h = getHover(this);
            if ($h) {
                var data = getHoverData.call($h,getHoverIDFromTarget(this));
                if (data.options.url != null ||  $h.options.url != null || ($h.customContent != null && $h.options.customContent != "")) {
                    var popup = getHoverPopup.call($h,this);
                    $h._renderContent(this, popup);
                }
            }
            return this;
        },
        setCustomContent : function (newContent, target) {
            var $h = getHover(this);
            if ($h && isDefined(newContent)) {
                var popup = getHoverPopup.call($h, this);
                $h._renderContent(target || this, popup, null, newContent);
            }
            return this;
        },
        cancelTargetMouseIn : function () {
            var $h = getHover(this);
            if ($h) {
                $h.cancelTargetMouseIn(this);
            }
            return this;
        }
    });
})(jQuery);
;(function ($) {
//Use to test if the anchor point is inside the hover popup
    function isPointInsideRectangle(point, hover_coords) {
        if (point.left > hover_coords.l.left && point.left < hover_coords.r.left && point.top > hover_coords.t.top && point.top < hover_coords.b.top) {
            return true;
        }
        return false;
    }
/**
 * Adjust the line thickness the canvas arrow stroke. stroke can be blurry if the points are odd
 * @param {Object} linePoint
 */
    function adjustLineWidthForCrispsness(linePoint) {
        //might have to adjust this depending on the position of the hover?
        var newLine = linePoint;
        linePoint.x = linePoint.x || linePoint.left;
        linePoint.y = linePoint.y || linePoint.top;
        newLine.x = (linePoint.x % 2 === 1) ? newLine.x + 1 : newLine.x;
        newLine.y = (linePoint.y % 2 === 1) ? newLine.y - 1 : newLine.y;
        return newLine;
    }
    /**
     * Set the canvas properties which form the actual arrow
     * @param {Object} context The canvas context
     * @param {Object} popup The popup element for the hover
     * @param {Number} borderWidth The border width of the hover
     * @param {Object} finalPoint1 The first point which makes up the base of the arrow
     * @param {Object} finalPoint2 The second point which makes up the base of the arrow
     * @param {Object} finalPoint3 The crux, or endpoint, of the arrow
     */
    function setCanvasProperties(context,popup, borderWidth,finalPoint1,finalPoint2,finalPoint3) {
        context.beginPath();
        context.lineWidth = ((borderWidth % 2 === 1) ? borderWidth + 1 : borderWidth) || 1;
        context.fillStyle = popup.css("background-color");
        context.strokeStyle = context.fillStyle;
        context.lineCap = "butt";
        context.moveTo(finalPoint1.left, finalPoint1.top);
        context.lineTo(finalPoint2.left, finalPoint2.top);
        context.stroke();
        context.closePath();
        context.beginPath();
        context.lineCap = "square";
        context.lineWidth = borderWidth || 1;
        context.strokeStyle = popup.css("border-left-color");
        context.moveTo(finalPoint2.left, finalPoint2.top);
        context.lineTo(finalPoint3.left, finalPoint3.top);
        context.lineTo(finalPoint1.left, finalPoint1.top);
        context.fill();
        context.stroke();
    }
    function isEqualTo() {
        return $.inArray(this.toString(), arguments)>-1;
    }
    /**
     * Set the canvas properties for the arrow
     * @param {Object} context
     * @param {Object} origin
     * @param {Object} firstPoint
     * @param {Object} secondPoint
     * @param {Object} crux
     * @param {Object} borderWidth
     */
    function setupArrowProperties(arrow, origin, firstPoint, secondPoint, crux, borderWidth, popup) {
        if ($.browser.msie && parseInt($.browser.version,10) < 9 && isExCanvasLoaded() === true) {
            G_vmlCanvasManager.initElement(arrow[0]);
        }
        if (typeof(arrow[0].getContext) === "undefined") {
            return false;
        }
        var context = arrow[0].getContext("2d");
        //final points recalculated with origin set to be the top-left of arrow's position
        var finalPoint1 = adjustLineWidthForCrispsness({
                left : firstPoint.left - origin.left,
                top : firstPoint.top - origin.top
            });
        var finalPoint2 = adjustLineWidthForCrispsness({
                left : secondPoint.left - origin.left,
                top : secondPoint.top - origin.top
            });
        var finalPoint3 = adjustLineWidthForCrispsness({
                left : crux.left - origin.left,
                top : crux.top - origin.top
            });
            setCanvasProperties(context,popup, borderWidth,finalPoint1,finalPoint2,finalPoint3);
    }
    /* 
    * Returns whether either side of the popup is between the width of the target.
    */
    function isPopupWidthBetweenAnchor(hoverCoords, anchorCoords, positionOnAnchor, positionOnHover) {
        var mainPosHover = positionOnHover.charAt(0);
        var mainPosAnchor = positionOnAnchor.charAt(0);
        if ( (isEqualTo.call(mainPosAnchor, "t","b") && isEqualTo.call(mainPosHover, "t","b")) 
                && ( (hoverCoords.l.left >= anchorCoords.l.left-1 && hoverCoords.l.left < anchorCoords.r.left) 
                || (hoverCoords.r.left <= anchorCoords.r.left && hoverCoords.r.left > anchorCoords.l.left) )) {
            return true;
        }
        return false;
    }
    /**
     * Return a point on the anchor closest to the two base points on the hover. The crux refers to the endpoint on the arrow
     * @param {Object} hover_coords
     * @param {Object} anchorCoords
     * @param {Object} posOfHover
     */
    function getCrux(positionOnAnchor, positionOnHover, anchorCoords, finalAnchorCoords, posOfHover, anchorBorderWidth, arrowLengthAxis, hoverCoords, borderWidth, basePoints) {
        var cruxOffsets = $.extend({},this.options.arrowCruxOffset);
        //TODO compare hoverCoords to just calculated crux values (instead of anchorCoords)
        var awayFromAnchor = function (ax) {
            return (hoverCoords.c[ax] - anchorCoords.c[ax] > 0) ? -1 : 1;
        };
        //center the CRUX if left or right edge of hover is between left or right edge of anchor
        if (isPopupWidthBetweenAnchor(hoverCoords, anchorCoords, positionOnAnchor, positionOnHover)) {
            //center the point between first and second points
            finalAnchorCoords.left = (basePoints.firstPoint.left + basePoints.secondPoint.left) / 2;
        }
        finalAnchorCoords.left = finalAnchorCoords.left + (cruxOffsets.x * awayFromAnchor("left"));
        finalAnchorCoords.top = finalAnchorCoords.top + (cruxOffsets.y * awayFromAnchor("top"));
        //Adjust the crux to account for the increase from the border on the popup. we round here because the border (using canvas) is applied as a stroke thus the border begins from the center outward
        finalAnchorCoords[arrowLengthAxis] += Math.round(borderWidth/2)*(awayFromAnchor(arrowLengthAxis)*-1);
        return finalAnchorCoords;
    }
/**
 * Returns the bounding rectangle attributes for the canvas arrow
 * Here we also need to extend the bounding rectangle to the original crux point
 * @param{Object} p1
 * @param{Object} p2
 * @param{Object} p3
 */
    function getBoundingRectangle(p1, p2, p3, arrowLengthAxis, axis,borderWidth) {
        var arrowDir = p3[arrowLengthAxis] > p1[arrowLengthAxis] ? 1 : -1; //expand : contract
        var leftMostPos = Math.min(p1.left, p2.left, p3.left);
        var rightMostPos = Math.max(p1.left, p2.left, p3.left);
        var topMostPos = Math.min(p1.top, p2.top, p3.top);
        var bottomMostPos = Math.max(p1.top, p2.top, p3.top);
        //Adjust bounding rect to only include width of border
        leftMostPos -= (p1.left == leftMostPos) ? (($.browser.msie && arrowLengthAxis=="top") ? Math.round(borderWidth/2) : 0) : Math.round(borderWidth/2);
        rightMostPos += (p1.left == rightMostPos) ? 0 : Math.round(borderWidth/2);
        topMostPos -= (p1.top == topMostPos && axis=="top") ? Math.round(borderWidth/2) : 0;
        //if crux is topmost
        if (topMostPos === p3.top) {
            topMostPos -= Math.round(borderWidth/2) || 0;
        }
        bottomMostPos += (p1.top == bottomMostPos) ?  0 : Math.round(borderWidth/2);
        var w = Math.round(rightMostPos - leftMostPos), h = Math.round(bottomMostPos - topMostPos);
        return {top: topMostPos, left: leftMostPos, w: w, h: h};
    }
    /**
     *Move the firstPoint and secondPoint toward the center if they are within a certain distance from the edge of the hover. This distance is determined by the option minimumEdgeOffset.
     * @param{Object} firstPoint  
     * @param{Object} hoverCoords  
     * @param{Object} target  
     * @param{String} axis  
     * @param{Number} baseLength  
     * @param{Number} dir  
     * @param{String} closestSide
     * @param{String} position
     */
    function movePointsIfNearEdge(firstPoint,hoverCoords,axis,baseLength,dir,closestSide,position) {
        var offsetFromEdge = Math.max(this.options.minimumEdgeOffset, 1);
        var sidesOnHover = getAllPointsOnElement(hoverCoords);
        var compareFirstPoint = "";
        if (position.length===1) {
            //get the closest
            var closestPointsToFirstPoint = getClosestPoint(firstPoint,position,sidesOnHover);
            compareFirstPoint = closestPointsToFirstPoint[0].point;
        } else {
            compareFirstPoint = hoverCoords[position];
        }
        //if the first point is within offsetFromEdge pixels from the edge
        var diff = Math.abs(firstPoint[axis]-compareFirstPoint[axis]);
        if (diff < offsetFromEdge) {
            firstPoint[axis] = firstPoint[axis] + ((offsetFromEdge-diff)*dir);
        }
        //initially, set the secondPoint to the firstPoint's position
        var secondPoint = $.extend({},firstPoint);
        secondPoint[axis] = secondPoint[axis] + (baseLength*(dir));
        var compareSecondPoint = {};
        if (position.length===1) {
            compareSecondPoint = closestPointsToFirstPoint[1].point;
        } else {
            compareSecondPoint = (function(sidesOnHover,closestSide){
                for(var i in sidesOnHover[closestSide]) {
                    if (i != position && i != closestSide) {
                        return sidesOnHover[closestSide][i];
                    }
                }
            })(sidesOnHover,closestSide);
        }
        diff = Math.abs(secondPoint[axis]-(compareSecondPoint[axis]));
        if (diff < offsetFromEdge) {
            secondPoint[axis] = compareSecondPoint[axis]+(offsetFromEdge*dir*-1)
        }
        return {firstPoint:firstPoint,secondPoint:secondPoint};
    }
    /**
     * Calculate the two points on the arrow's base (the points on the popup)
     * @param {Object} firstPoint The point on the hover closest to the anchor point
     * @param {String} axis "left" or "top" describing the axis along which the firstPoint lies
     * @param {Object} hoverCoords coordinates of the Hover popup
     */
    function calculateArrowBase(firstPoint, axis, hoverCoords, anchorCoords,borderWidth,anchorBorderWidth,closestSide) {
        var position = firstPoint.position, point = $.extend({},firstPoint.point);
        var arrowLengthAxis = (axis === "left") ? "top" : "left";
        var baseLength = this.options.arrowBaseLength || 20;
        //which direction to move toward center
        var dir = (hoverCoords.c[axis] < point[axis]) ? -1 : 1;
        //move fp toward center with offsetFromEdge, plus half of base length
        var greaterOrLessThanZero = function () {
            return (hoverCoords.c[arrowLengthAxis] - anchorCoords.c[arrowLengthAxis] > 0) ? 1 : -1;
        };
        point[arrowLengthAxis] += borderWidth * (greaterOrLessThanZero());
        //move point by half if we're in center, otherwise don't move at all
        point[axis] = (position.length===1) ? hoverCoords.c[axis]+(baseLength/2)*dir*-1 : point[axis];
        //changes point and secondPoint by reference
        //If either point is within a certain no of pixels from the edge, move the points difference from the edge
        return movePointsIfNearEdge.call(this, point,hoverCoords,axis,baseLength,dir,closestSide,position);
    }
      /**
     * Returns the distance between two points
     * @param{Object} point1 First point to compare
     * @param{Object} point2 Second point to compare
     */
    function getDistance(point1, point2) {
        return Math.sqrt(Math.pow(point2.left - point1.left, 2) + Math.pow(point2.top - point1.top, 2));
    }
    /**
     * Comparator for comparing object keys of value
     * @param{Object} point1 First object to compare
     * @param{Object} point2 Second object to compare
     */
    function compareObjects(a, b) {
        if (a.value < b.value) { return -1; }
        if (a.value > b.value) { return 1; }
        return 0;
    }
    function getClosestPointToAnchor(hoverPositions, anchorPositions, anchorPoint) {
        var distances = [];
        for (var i in hoverPositions) {
            distances.push({"point":hoverPositions[i],"position":i,"value":getDistance(hoverPositions[i], anchorPositions[anchorPoint])});
        }
        return distances.sort(compareObjects)[0];
    }
    /**
     *Return an array of points, ordered by distance, on a side of the hover that are closest to a given point. 
     * @param{Object} point
     * @param{String} pointSide
     * @param{Object} allSides
     */
    function getClosestPoint(point,pointSide,allSides) {
        var pointOnSides = [];
        for(var i in allSides) {
            if (i == pointSide) {
                for(var pp in allSides[i]) {
                    if (pp != pointSide) {
                        pointOnSides.push({"value":getDistance(allSides[i][pp], point),"position":pp,"point":allSides[i][pp]});
                    }
                }
            }
        }
        return pointOnSides.sort(compareObjects);
    }
    /**
     *Calculate which side of the Hover to attach the base of the arrow. This is based on final options.position 
     */
    function calculateArrowBaseSide(anchorPositions,hoverPositions,hoverPoint,anchorPoint,position) {
        if (hoverPoint.length > 1) {
            var yAxisSide = position.charAt(0);
            var xAxisSide= position.charAt(1);
            var yAxisWidth = Math.abs(hoverPositions[hoverPoint].top - anchorPositions[anchorPoint].top);
            var xAxisWidth = Math.abs(hoverPositions[hoverPoint].left - anchorPositions[anchorPoint].left);
            if (xAxisWidth >= yAxisWidth) {
                return xAxisSide;
            } else {
                return yAxisSide;
            }
        } else {
            return hoverPoint;
        }
    }
    /*
     * Return all the points on the give element organized by side
     * @param{Object} elem 
     * @param{Object} positions
     */
    function getAllPointsOnElement(positions) {
        return {
            t : { "tl": positions.tl, "t": positions.t, "tr": positions.tr },
            b : { "bl": positions.bl, "b": positions.b, "br": positions.br },
            r : { "tr": positions.tr, "r": positions.r, "br": positions.br },
            l : { "tl": positions.tl, "l": positions.l, "bl": positions.bl }
        }
    }
    /*
     * Reposition the Hover with an offset given to accommodate the arrow. If already repositioned, apply only the offsets
     * @param{Object} target The anchor target we  are positioned the hover to
     * @param{Object} arrowLengthAxis The size of the arrow lengthwise
     * @param{Object} rePositioned Whether we have repositioned
     * @param{Object} anchorCoordinates 
     * @param{Object} elemCoordinates
     */
    function repositionHoverForArrow(target, popup, arrowLengthAxis, rePositioned, anchorCoordinates, elemCoordinates,finalAnchorCoords) {
        var offs = { left : 0, top : 0 }, dir =1, arrowLength = this.options.arrowLength, currentPosition = getHoverSnapToPosition.call(this,popup);
        offs[arrowLengthAxis] += (arrowLength)*dir;
        if (rePositioned!==true) {
            var opts = $.extend(true,{},this.options);
            opts.position = currentPosition;
            this.position(target, popup,{
                x : offs.left,
                y : offs.top
            }, opts);
        }
        return offs;
    }
    /**
     * Returns a collection of sides with their total distances (calculated from each on the side) 
     * @param{Object} pointsOnSide All the points on the hover organized by side
     * @param{Object} finalAnchorCoords The anchor point coordinates
     */
    function getDistancesFromSide(pointsOnSide,finalAnchorCoords) {
        var distancesFromSide = [];
        for (var i in pointsOnSide) {
            if (pointsOnSide.hasOwnProperty(i)) {
                distancesFromSide.push({
                    point : pointsOnSide[i],
                    "position" : i,
                    "value" : getDistance(pointsOnSide[i], finalAnchorCoords)
                })
            }
        }
        return distancesFromSide;
    }
    /*
     * Create/set/get the arrow element
     * @param {Object} target
     */
    function createArrow(hid) {
        var $newArrow;
        var ca = this.getArrow(hid);
        if (ca != null && ca.length > 0) {
            return ca;
        }
        if (!ca || ca == null || ca.length <= 0) {
            var a = document.createElement("canvas");
            a.width = "0";
            a.height = "0";
            $newArrow = $(a).css("display", "none").addClass("drHoverArrow").addClass("drHover");
            this.setArrow($newArrow, hid);
            //set arrow for all the targets
            if (this.options.shared === true) {
                for (var dataIndex in this.hoverData) {
                    if (this.hoverData.hasOwnProperty(dataIndex)) {
                        this.setArrow($newArrow, dataIndex);
                    }
                }
            }
        } else {
            return ca;
        }
        return $newArrow;
    }
    function getHoverSnapToPosition(popup) {
        return $.data(popup[0],"currentPosition");
    }
    function isExCanvasLoaded() {
        return window.CanvasRenderingContext2D !== "undefined" && typeof G_vmlCanvasManager !== "undefined";
    }
    /**
     * Returns coordinates, 3 points per side and center, for an element.
     * @param {Object} posOfHover
     * @param {Object} el
     */
    function getCoordinatesForElement(el) {
        var $el = $(el);
        var w = $el.data("cachedDimensions").outerWidth;
        var h = $el.data("cachedDimensions").outerHeight;
        var el_offsets = this.fixedContainer === true ? $el.position() : $el.offset();
        var leftEdge_leftPos = el_offsets.left,
            topEdge_topPos = el_offsets.top,
            bottomEdge_topPos = el_offsets.top + h,
            rightEdge_leftPos = el_offsets.left + w,
            center_topPos = el_offsets.top + Math.round(h * 0.5),
            center_leftPos = el_offsets.left + Math.round(w * 0.5);
        return {
            "r": {  top: center_topPos,         left: rightEdge_leftPos },
            "tr": { top: topEdge_topPos,        left: rightEdge_leftPos },
            "t": {  top: topEdge_topPos,        left: center_leftPos },
            "tl": { top: topEdge_topPos,        left: leftEdge_leftPos },
            "br": { top: bottomEdge_topPos,     left: rightEdge_leftPos },
            "b": {  top: bottomEdge_topPos,     left: center_leftPos },
            "bl": { top: bottomEdge_topPos,     left: leftEdge_leftPos },
            "l": {  top: center_topPos,         left: leftEdge_leftPos },
            "c": {  top: center_topPos,         left: center_leftPos }
        };
    }
    function clearCachedDimensions($elem) {        
        $($elem).removeData("cachedDimensions");
    }
    function cacheDimensions($elem) {
        var $elem = $($elem);
        var box = $elem[0].getBoundingClientRect();
        $elem.data("cachedDimensions", {outerWidth:box.width || (box.right-box.left) || $elem.outerWidth(), outerHeight: box.height || (box.bottom-box.top) || $elem.outerHeight()});
    }
    $.dr.hover.setupHoverArrow = function(h) {
        return new function() {
            if (typeof h === "undefined") {
                $.dr.utils.logError("Hover widget was not supplied.");
                return false;
            }
            var _hover = h;
            var _this = this;
            this.draw = function(data, target, hid, rePositioned, callback) {
                var opts = _hover.options;
                var popup = data.HoverPopup;
                popup.show();
                popup[0].style.filter = "";
                var borderWidth = parseInt(popup.css("border-left-width"), 10) || 0;
                var anchorBorderWidth = parseInt($(target).css("border-left-width"), 10) || 0;
                var currentPosition = getHoverSnapToPosition(popup);
                cacheDimensions(popup);
                cacheDimensions(target);
                var hoverCoords = getCoordinatesForElement.call(_hover, popup);
                var allHoverPoints = getAllPointsOnElement(hoverCoords);
                var anchorCoords = getCoordinatesForElement.call(_hover, target,true);
                var allAnchorPoints = getAllPointsOnElement(anchorCoords);
                var hoverPoint = currentPosition.split("-")[0];
                var anchorPoint = currentPosition.split("-")[1];
                var finalAnchorCoords = $.data(target,"snapToData").anchorCoordinates;
                var arrow = createArrow.call(_hover, hid);
                _hover.usingPosition = currentPosition;
                if (arrow && arrow[0].parentNode == null) {
                    $.data(arrow[0], "HoverID", $.data(popup[0], "HoverID"));
                    _hover.bindArrow(arrow);
                    if (_hover.options.inline === true) {
                        popup.after(arrow.detach());
                    } else {
                        $("body").prepend(arrow.hide());
                    }
                }
                //if anchor point is inside hover, return here because anchor point will not be visible
                var closestPoint = getClosestPointToAnchor(hoverCoords, anchorCoords, anchorPoint),
                    closestSide = closestPoint.position.charAt(0),
                    axis = (closestSide === "t" || closestSide === "b") ? "left" : "top",
                    arrowLengthAxis =  (axis === "left") ? "top" : "left",
                    firstPoint = {"point":closestPoint.point, "position":closestPoint.position},
                    offsetsFromTarget = repositionHoverForArrow.call(_hover, target, popup, arrowLengthAxis,rePositioned,anchorCoords,hoverCoords,finalAnchorCoords,borderWidth);
                //If we repositioned, then we need to call drawArrow again so the coordinates reflect the new position
                if (getHoverSnapToPosition(popup) !== _hover.usingPosition) {
                    _this.draw(data, target, hid, true,null);
                    return;
                }
                hoverCoords = getCoordinatesForElement.call(_hover, popup);
                anchorCoords = getCoordinatesForElement.call(_hover, target);
                hoverPoint = currentPosition.split("-")[0];
                anchorPoint = currentPosition.split("-")[1];
                closestSide = calculateArrowBaseSide(anchorCoords, hoverCoords, hoverPoint, anchorPoint, getHoverSnapToPosition(popup));
                axis = (closestSide === "t" || closestSide === "b") ? "left" : "top";
                arrowLengthAxis =  (axis === "left") ? "top" : "left";
                firstPoint.point = hoverCoords[firstPoint.position];
                //Recalculate anchor coordinates after reposition
                var basePoints = calculateArrowBase.call(_hover, firstPoint, axis, hoverCoords, anchorCoords, borderWidth,anchorBorderWidth, closestSide);
                var secondPoint = basePoints.secondPoint;
                firstPoint = basePoints.firstPoint;
                var crux = getCrux.call(_hover,anchorPoint, hoverPoint, anchorCoords,finalAnchorCoords, anchorPoint.charAt(0),anchorBorderWidth,arrowLengthAxis,hoverCoords,borderWidth, basePoints);
                if (isPointInsideRectangle(crux, hoverCoords) === true) {
                    arrow.hide();
                    return false;
                }
                var rect = getBoundingRectangle.call(_hover, firstPoint, secondPoint, crux, arrowLengthAxis, axis, borderWidth);
                arrow.css({"display":"block", "top":rect.top + "px", "left":rect.left + "px", "position":"absolute"}).attr({"width": rect.w, "height": rect.h});
                //origin is the topleft corner of the canvas layer. this is used for converting document coordinates into canvas coordinates.
                var origin = {left : rect.left, top : rect.top};
                setupArrowProperties.call(_hover, arrow, origin, firstPoint, secondPoint, crux, borderWidth, popup);
                clearCachedDimensions(popup);
                clearCachedDimensions(target);
                if ($.isFunction(callback)) {
                    callback();
                }
            };
        };
    };
})(jQuery);
;(function($){
	var initIconWell = function(){

		/*
		 * Add shadows to all the popup divs
		 */
		$('.iconWell .popup > div', this).dr.shadows();
		
		var isBound = false;
		var removeClass = function(){
			$('.iconWell > li.hover').removeClass('hover');
		};
		
		/*
		 * This function is needed due to the following bug:
		 * 
		 * 1 - user mouses over quick search
		 * 2 - the user double clicks on the search input
		 * 3 - the user sees the built in browser autocomplete that shows all the previous search values
		 * 4 - when the user mouses into the autocomplete, the quick search overlay closes
		 */
		var watchMenuClose = function(evt){
			if (evt) {
				if ($(evt.target).parents('ul.iconWell').length == 0) {
					removeClass();
					$('body').unbind('mouseover', watchMenuClose);
					isBound = false;
				}
			}
		};

		$('.iconWell > li').mouseenter(function(){
			removeClass();
			$(this).addClass('hover');
			if (!isBound) {
				$('body').bind('mouseover', watchMenuClose);
				isBound = true;
			}
		});
	};
	$.dr.addDomReadyEvent(initIconWell, 'domReadyEarly');
})(jQuery);

	/*
	InlineHelp can be called two ways
	--a single input with a single message
	1) $("#myInput").dr.inlineHelp(options);
		
	--multiple inputs with different messages
	2) $.dr.inlineHelp.setup(JSON);

	*/
	/*
	InlineHelp can be called two ways
	--a single input with a single message
	1) $("#myInput").dr.inlineHelp(options);
		
	--multiple inputs with different messages
	2) $.dr.inlineHelp.setup(JSON);

	*/
;(function($){
	var defaults = {
		popUpOffset: {x:4,y:0},
		popupDelay:550,
		isIcon:true,
		theme:'orange',
		popUpPosition:"l-r",
		inline:true,
		preferredAltPositions:["r-l"],
		maxWidth:400,
		title:"",
		links:null
	};
	var global_text = {};
	var pageLevelHelpSet = false;
	function buildLinks(e, opts, group) {
        var self = this;
		var $container = $("<div target='_blank' class='inlineHelpLinksBox'></div>");
        var totalAdded = 0;
		for(var i = 0; i < opts.links.length;i++) {
            var a = opts.links[i];
            if (a.group === group || group === null) {
                var anchor = document.createElement('a');
                anchor.href = a.href;
                if (a.onclick) {
                    anchor.onclick = a.onclick;
                    $(anchor).unbind("click.hideInlineHelp").bind("click.hideInlineHelp", function(){
                        $(e).dr.inlineHelp.hide();
                    });
                }
                if (a.text) {
                    anchor.innerHTML = a.text;
                }
                $container.append(anchor);
                if (i < opts.links.length-1) {
                    $container.append("<span>|</span>");
                }
                totalAdded++;
            }
		}
		return totalAdded===0 ? "" : $container;
	}
	function bind(e, content, title, opts, dataKey, group) {
            var self = this;
			var $e = $(e);
			content = addTitle(title || this.options.title, content);
			var c = content;
			if (!_.isEmpty(opts.links)) {
				c = $(document.createElement("div")).append(content).append(buildLinks.call(this, e, opts, group));
			}
            $(e).dr.hover({
				offsets:				opts.popUpOffset,
				targetMouseInDelay:		opts.popupDelay,
				preferredAltPositions:	opts.preferredAltPositions,
				customContent:			c,
				theme:					opts.theme,
				showArrow:				true,
                position:				opts.popUpPosition,
                maxWidth:				opts.maxWidth,
                customClass:			"helpPopUp",
                showCloseButton:		true
            });
            //analytics recording
            //Record the mouse-over
            $e.bind("dr-afterRender.hover", function() {
                self.open = true;
				var meta = {
					"openTime": new Date()
				};
				$(this).data("inlineHelpMeta", meta);
                $(e).trigger("tooltipOpened.inlineHelp");
                record.call(self, "InlineHelp", "HelpIconHovered", dataKey);
			});
			//Recording closing the popup
			$e.bind("dr-hidePopup.hover", function() {
                if (self.open === true) {
                    self.open = false;
                    var meta = {"closeTime": new Date()};
                    var currentData = $(this).data("inlineHelpMeta");
                    var newMeta = $.extend({}, meta, currentData);
                    $(this).data("inlineHelpMeta",newMeta);
                    $(e).trigger("tooltipClosed.inlineHelp");
                    record.call(self, "InlineHelp", "TimeOpen", dataKey, meta.closeTime.getTime() - newMeta.openTime.getTime());
                }
            });
            //Record link clicking, and time took from opening popup to clicking the link
            if (c instanceof $ && !_.isEmpty(opts.links)) {
				c.find(".inlineHelpLinksBox a").bind("click", function() {
					var meta = $e.data("inlineHelpMeta");
					var clickTime = new Date();
					$(e).trigger("linkClicked.inlineHelp", this);
					record.call(self, "InlineHelp", "HelpLinkClicked", dataKey, clickTime.getTime() - meta.openTime.getTime());
				});
            }
	}

	function addTitle(title, content) {
		if (title && title.length > 0) {
			return "<div class='helpTitle'>"+title+"</div>" + content;
		}
		return content;
	}
	//processes special cases for beacon specific widgets
	function processSpecialCasesForWidgets($helpElement, $siblings) {
		var $textAreaInfo = $siblings.filter("textarea").next("div").find(".textareaInfo");
		if ($textAreaInfo.length === 1) {
			$textAreaInfo.parent().before($helpElement.detach());
			return true;
		}
		var $ms = $siblings.filter(".multiSelect");
		if ($ms.length > 0) {
			$ms.last().after($helpElement.detach());
			return true;
		}
		return false;
	}
    function record() {
        if (this.recorder) {
            this.recorder.record.apply(window, arguments);
        }
    }
	function correctIconPlacement(helpElement) {
		var $helpElement = $(helpElement);
		$helpElement.each(function(){
			var $this = $(this);
			var $siblings = $this.siblings();
			var didProcess = processSpecialCasesForWidgets($this, $siblings);
			if (!didProcess) {
				//inlineHelpAnchor tells us where exactly we should put the help icon
				var $anchor = $siblings.filter(".inlineHelpAnchor");
				if ($anchor.length === 1) {
					$anchor.after($this.detach());
				} else if ($siblings.length > 0) {
					//avoid extraneous #text nodes that can affect spacing
                    $siblings.each(function(){
                        if (this.nodeType === 3 && $.trim(this.nodeValue)==="") {
                            $siblings.first().after($this.detach());
                            return false;
                        }
                    });

				}
			}
			if ($this.parent()[0].nodeName.toUpperCase() === "LEGEND") {
				$this.css("vertical-align","baseline");
			}
			//[block] + [inline-block] wraps
			var $visibleSiblings = $siblings.filter(":visible");
			if ($visibleSiblings.length === 1 && $visibleSiblings.eq(0).css("display") === "block") {
				$visibleSiblings.eq(0).css("display","inline-block");
			}
		});
	}
	function InlineHelp(opts) {
		this.options = $.extend(this.options, defaults, opts);
        	this.recorder = this.options.recorder || null;
	}
	InlineHelp.prototype.init = function(mapping, element) {
		var self = this;
		var $elements = $(element);
		$elements.each(function(){
			var $this = $(this);
			var dataKey = $this.attr("data-help-key");
			dataKey = _.isUndefined(dataKey) ? "__" : dataKey;
			var extendedInlineOpts = $.extend({}, self.options, ($.dr.utils.evalString($(this).attr("data-options-help")) || {}));
			var include = false;
			var content, title, group;
			var mappingObject = global_text.hasOwnProperty(dataKey) ? global_text : mapping;
			var dataObject = {};
			if (typeof mappingObject === "string") {
				dataObject[dataKey] = {"content": mapping};
			} else if (!mappingObject.hasOwnProperty(dataKey) && $.isPlainObject(mappingObject)) {
				dataObject = mappingObject;
			} else if (mappingObject.hasOwnProperty(dataKey)) {
				dataObject = mappingObject[dataKey];
			}
			if (!_.isEmpty(dataObject) && dataObject !== null) {
				title = dataObject.title || "";
                group = dataObject.group || null;
				content = dataObject.content;
				if (_.isEmpty(content)) {
					return false;
				}
				extendedInlineOpts = $.extend({}, extendedInlineOpts, mappingObject);
				bind.call(self, this, content, title, extendedInlineOpts, dataKey, group);
				$this.addClass("inlineHelp_initialized inlineHelpHandle");
				include = true;
				if (extendedInlineOpts.isIcon) {
					correctIconPlacement($this);
				}
			}
		});
	};
	$.namespace('dr', {
		inlineHelp: function(opts) {
			var help = new InlineHelp();
			help.init(opts || {}, this);
			return $(this);
		}
	});
	/* Public methods */
	$.namespace("dr.inlineHelp", {
		show: function() {
			$(this).dr.hover.show();
		},
		hide: function() {
			$(this).dr.hover.hide();
		},
		disable: function() {
			$(this).dr.hover.disable();
		},
		enable: function() {
			$(this).dr.hover.enable();
		}
	});
	$.dr.inlineHelp = {
		setPageLevelHelp: function(mappings) {
			if ($.isPlainObject(mappings)) {
				global_text = mappings;
				pageLevelHelpSet = true;
			}
		},
		setDefaults: function(options) {
            if (options) {
                $.extend(true, defaults, options);
            }
		},
        correct: function() {
            if ($(this).hasClass("inlineHelpHandle")) {
                correctIconPlacement(this);
            }
        }
	};
    $.dr.addUnobtrusiveEvent(function(evt, context){
		if (typeof INLINE_HELP !== "undefined" && pageLevelHelpSet === false) {
			$.dr.inlineHelp.setPageLevelHelp(INLINE_HELP);
		}
		var $inlineHelpFields = $(".inlineHelp").not(".inlineHelp_initialized");
		if ($inlineHelpFields.length) {
			$inlineHelpFields.dr.inlineHelp();
		}
    }, 'unobtrusiveEventLate');	
})(jQuery);



;(function($) {
	
	// PRIVATE GLOBAL PROPERTIES **********************************************************/
	

	var defaults = {
		pagesStartAtZero: false,
		pagingOverride:null,
		selectAllAcrossPagesEnabled: true,
		selectAllResults: "all",
		submitType: 'get',
		clientsideSortingEnabled:true,
		searchPersistCallback:function(){}
	};
	
	/**
	 * Legacy mappings.
	 */
	var legacyMappings = {
		PAGES_START_AT_ZERO: 				"pagesStartAtZero",
		PAGING_OVERRIDE: 					"pagingOverride",
		SELECT_ALL_ACROSS_PAGES_ENABLED: 	"selectAllAcrossPagesEnabled",
		SELECT_ALL_RESULTS: 				"selectAllResults",
		SUBMIT_TYPE: 						"submitType",
		CLIENTSIDE_SORTING_ENABLED: 		"clientsideSortingEnabled",
		SEARCH_PERSIST_CALLBACK: 			"searchPersistCallback"
	}
	
	/*
 	var messages = {
		SORT_BY: "Sort by {0}",
		INVALID_NUMBER: "Please enter a valid number.",
		VIEW_SELECTIONS: "View Selections",
		CLEAR_SELECTIONS: "Clear Selections",
		VIEW_ALL_MSG: "Only Selected {0} are Visible",
		VIEW_ALL_LINK: "Remove This Filter",
		ITEMS: "Items",
		ITEM: "Item",
		SELECTED: "Selected",
		SELECT_ALL: "Select/Clear All",
		ALL_ITEMS_SELECTED: "All {0} Selected",
		SELECT_ALL_ITEMS: "Select All {0} {1}"
	};
	*/
			
 	var messages = {
		SORT_BY: "\u6392\u5E8F\u4F9D\u636E{0}",
		INVALID_NUMBER: "\u8BF7\u8F93\u5165\u4E00\u4E2A\u6709\u6548\u6570\u5B57\u3002",
		VIEW_SELECTIONS: "\u67E5\u770B\u9009\u62E9",
		CLEAR_SELECTIONS: "\u6E05\u9664\u9009\u62E9",
		VIEW_ALL_MSG: "\u4EC5\u9009\u5B9A\u7684{0}\u53EF\u89C1",
		VIEW_ALL_LINK: "\u5220\u9664\u6B64\u8FC7\u6EE4\u5668",
		ITEMS: "\u5546\u54C1",
		ITEM: "\u6761\u76EE",
		SELECTED: "\u9009\u5B9A\u7684",
		SELECT_ALL: "\u9009\u62E9/\u6E05\u9664\u5168\u90E8",
		ALL_ITEMS_SELECTED: "\u5168\u90E8{0}\u5DF2\u9009\u5B9A",
		SELECT_ALL_ITEMS: "\u5168\u9009{0} {1}"
	};

	// jQuery pattern used to select checkboxes
	var ALL_CHECKBOX_SELECTOR = "TD.actionCol input[type=checkbox], TD.actionCol input[type=radio]";
	
	var submitListAction = function(_list,_action){
		// find the first input, and then get a handle to its form parent
		var form = $('input:first',_list.container).parents('form');
		if(form.length>0){
			form = form[0];
			var listAction = $('input.listAction',form);
			if(listAction.length==1){
				listAction.val(_action);
				form.submit();
			}
		}
	}

	/******************************************************************************
	* Holds controls for lists: highlights rows, enables/disables buttons, sorts columns<br />
	* Assumptions:<br />
	* 1) Table has a unique prefix in "prefix_table" format<br />
	* 2) Checkboxes/radio buttons have a name attribute with the prefix as the value<br />
	* 3) Action Buttons are disabled by default<br />
	* 4) Checkboxes may or may already be selected<br />
	* 5) Top and bottom button rows are the same<br />
	* @constructor
	* @author scollings
	* @param {String} prefix Name given to the checkboxes/radio buttons and table
	*****************************************************************************/
	var list = function(containerId)
	{
		// INSTANCE PROPERTIES ******************************************************/
		this.containerId = containerId;
		this.searchPanel = null;
		this.container = (typeof containerId == 'string') ? $('#'+containerId) : containerId;
		this.actionRowTop =  $("DIV.actionRow",this.container);
		this.actionRowBottom =  $("DIV.actionRowBottom",this.container);
		this.submitType = defaults.submitType;
		this.hasRadios = false;
		this.clientSideSortingEnabled = defaults.clientsideSortingEnabled;
		
		// array that holds the names of the action buttons
		this.buttonsTop = [];
		this.buttonsBottom = [];
		
		// array that holds all of the currently selected checkboxes
		this.currentSelectedItem=null;
		this.selectedItemLength = 0;
		this.disabledBtnArray = [];
		this.disabledButtons = [];
		
		// array that holds all of the values of the currently selected checkboxes
		this.selectedItemsValues = [];
		this.persistedSelectionCount = 0;
		this.paddedList = "";
		this.persistedSelections = "";
		
		// setup the list
		this.init();

	};
	
	// INSTANCE METHODS **********************************************************/
	list.prototype = {

		/******************************************************************************
		*  Initializes the list using unobtrusive techniques<br />
		*  Example: <code>obj.init()</code>
		*  @private
		*  @return VOID
		*****************************************************************************/
		init: function(){
			//try{
				//DR_Utils_Profiler.clear();
				//DR_Utils_Profiler.start();
				this.initPaging();				//DR_Utils_Profiler.log('initPaging');
				this.initCheckboxes(true);		//DR_Utils_Profiler.log('initCheckboxes');
				this.initSelectAll();			//DR_Utils_Profiler.log('initSelectAll');
				this.initButtons();				//DR_Utils_Profiler.log('initButtons');
				this.initSelectionCounter();	//DR_Utils_Profiler.log('initCounter');
				this.refreshState(true);		//DR_Utils_Profiler.log('refreshState');
				this.initSortableColumns();		//DR_Utils_Profiler.log('initSortableColumns');
				this.initTabs();				//DR_Utils_Profiler.log('initTabs');
				//DR_Utils_Profiler.view();
			//}catch(e){
				//if(window.console){
				//	console.log(e);
				//}
			//}
		},
		
		/******************************************************************************
		*  Binds onclick to checkboxes/radio buttons in table cells that <br />
		*  have class of actionCol  <br />
		*  @return VOID
		*****************************************************************************/
		initCheckboxes: function(init){
			var oSelf = this;
			if(init){
			  	this.items = $(ALL_CHECKBOX_SELECTOR,this.container).click(function(){oSelf.toggle(this);}).addClass('initalized');
				
			}else{
				// select all checkboxes/radiobuttons that DO NOT have a class of initialized, this
				// prevents multiple click events being bound to the same item
				$("TD.actionCol input[type=checkbox]:not(.initalized), TD.actionCol input[type=radio]:not(.initalized)",this.container).click(function(){oSelf.toggle(this);}).addClass('initalized');
				
				//select all checkboxes/radiobuttons that match our jquery selector
			  	this.items = $(ALL_CHECKBOX_SELECTOR,this.container);
			}

			this.hasRadios = (this.items.filter(':radio:first').length>0)? true : false;
		},
		
		initTabs: function(){
			var listTabsContent = $('.listTabsContent', this.container);
			var listTabs = $('.listTabs', this.container);
			var oSelf = this;
			$('.search',listTabs).click(function(){
				oSelf.toggleTab('search');
				return false;
			});
			$('.columns',listTabs).click(function(){
				oSelf.toggleTab('columns');
				return false;
			});
			this.listTabsContent = listTabsContent;
			this.listTabs = listTabs;
			// check if the search panel is marked to be open, but the content is set to display none.
			if($('.searchExpanded', this.container).val()=='true' && !$('.listTabsContent', this.container).is(':visible') ){
				// remove the selected class, so the toggleTab function will work correctly
				$('.search', listTabs).removeClass('selected');
				oSelf.toggleTab('search');
			}
			
			// make sure the search button is enabled in case user clicks the back button
			$('button.search',listTabsContent).removeAttr('disabled');
		},
		
		toggleTab: function(id){
			var listTabsContent = this.listTabsContent;
			var listTabs = this.listTabs;		
			var searchTab = $('.search', listTabs);
			var columnsTab = $('.columns', listTabs);
			var currentID = (searchTab.hasClass('selected')) ? 'search' : (columnsTab.hasClass('selected')) ? 'columns' : null;
			$('div', listTabs).removeClass('selected');
			var searchExpanded =$('.searchExpanded', this.container);

			if(currentID==id){
				listTabsContent.hide();
				searchExpanded.val('false');
			}else{
				listTabsContent.show();
				$('.'+id, listTabs).addClass('selected');
				$('.'+id, listTabsContent).show();
				
				currentID = (id=='search') ? 'columns' : 'search';
				if(id=='search'){
					searchExpanded.val('true');
				}else{
					searchExpanded.val('false');
				}
				
				$('.'+currentID, listTabsContent).hide();
				var $inputs = $('.'+id+' :input', listTabsContent).filter('input[type=text], textarea, select');
				if($inputs.length>0){
					try{
						$inputs[0].focus();
					}
					catch(e){
						//trap the error in case the control cannot be focused to
					};
				}
			}
			
			defaults.searchPersistCallback(this.container, (searchTab.hasClass('selected')) ? 'true' : 'false');
		},
		
		/******************************************************************************
		*  Binds onclick to the Select All checkbox, if present.
		*  @private
		*  @return VOID
		*****************************************************************************/
		initSelectAll: function(){
			var oSelf=this;
			var th = $('thead th.actionCol:first', this.container);
			if(th.length>0){
				th.html('<input title="'+messages.SELECT_ALL+'" type="checkbox" class="selectAll" />');
				this.selectAllCheckbox = $("INPUT.selectAll",this.container).click(function(){oSelf.toggleSelectAll();}).get(0);
				if(this.hasRadios || this.items.length===0 ){
					$(this.selectAllCheckbox).hide().insertAfter('<span>&nbsp;</span>');
				}
			}

		},
		
		/******************************************************************************
		*  Stores buttons in the actionButtons[] array and initializes their count to zero<br />
		*  @private
		*  @return VOID
		*****************************************************************************/
		initButtons: function() {
			//Assumption that the buttons are the same between in both the top and bottom actionRows
			var buttonRow = (this.actionRowTop) ? this.actionRowTop : this.actionRowBottom;
			var oSelf=this;
			if (buttonRow) {
				var buttonsBottom = $("BUTTON.single,BUTTON.multiple", this.actionRowBottom);
				var buttons = $("BUTTON.single,BUTTON.multiple", buttonRow).each(function(i){
					var btn = $(this);
					var _type="_single"
					var isSingle = btn.hasClass('single');
					var isMultiple = btn.hasClass('multiple');
					//test for indexOf just in case other classes or spaces have been added
					if (isSingle || isMultiple){
						oSelf.buttonsTop[oSelf.buttonsTop.length] = {buttonObj:this,name:this.name,isSingle:isSingle,isMultiple:isMultiple};
						if(buttonsBottom.length>0 && typeof buttonsBottom[i] !== undefined){
							oSelf.buttonsBottom[oSelf.buttonsBottom.length] = {buttonObj:buttonsBottom[i],name:buttonsBottom[i].name,isSingle:isSingle,isMultiple:isMultiple};
						}
					}
				});
			}
			
			// asign onclick events to the buttons that do not already have an onclick
			$("UL.buttons BUTTON[name]",this.container).not('[onclick]').click(function(){
				var $this = $(this);
				var name = $this.attr('name');
				var confirmAction = $(this).attr('data-confirm-action');
				if(confirmAction){
					var func = function(ok){
						if(ok){
							oSelf.submitActionButton($this[0],name);
						}
					};
					$.dr.confirm(confirmAction, func)
				}else{
					oSelf.submitActionButton(this,name);
				}
			});
		},
		
		submitActionButton: function(btn,action){
			btn = (typeof btn == 'String' ) ? document.getElementById(btn) : btn;
			action = (action) ? action : btn.name;
			submitListAction (this,action);
		},
		
		/******************************************************************************
		*  Initalizes sortable columns for the list.
		*  @private
		*  @return VOID
		*****************************************************************************/
		initSortableColumns: function(){
			var clientSideSortTable = $('TABLE.clientSideSort:first',this.container);
			var sortColumns = $("TABLE THEAD A",this.container).filter(function(){
				var href = this.href;
				if(!href){
					$(this).css('cursor','pointer');
					return true;
				}
				var locationHref = window.location.href.replace(window.location.hash,'');
				href = href.replace(locationHref,'');
				return ( href.length==0 || href.indexOf('#')===0);
			}).each(function(){
				$(this).attr('title',messages.SORT_BY.replace('{0}',$(this).text()));
			});
			
			// add a class of sortable when the TH has a link inside it.
			$("TABLE THEAD TH",this.container).filter(function(){
				return $('a',this).length>0;
			}).addClass('sortable');
			
			if(clientSideSortTable.length>0 && this.totalPages==1 && this.clientSideSortingEnabled){
				if(typeof $.fn.tablesorter == 'function'){
					if(clientSideSortTable.length==0){
						// if the list has only one page of results, turn on client side sorting
						clientSideSortTable = $('TABLE.dataTable',this.container);
					}
					var initialsortColumn = 0;
					var initialsortDirection = 0;
					var offset = ($("TABLE THEAD TH.actionCol",this.container).length > 0 ) ? 1 : 0;

					$("TABLE THEAD TH",this.container).not('TH.actionCol').each(function(count){
						var td = $(this);
						if(td.hasClass('ascending') ){
							initialsortColumn = count+offset;
						}else if(td.hasClass('descending') ){
							initialsortColumn = count+offset;
							initialsortDirection = 1;
						}
					});
					//attach client side sorting object
					var sortObj = {
						sortList:[[initialsortColumn,initialsortDirection]]
					}
					if(offset){
						sortObj.headers = { 0: { sorter: false} }
					}
					clientSideSortTable.tablesorter(sortObj);
				}
			}else{
				var oSelf=this;
				sortColumns.click(function(){
					var columnId = $(this).attr("data-sort-column");
					oSelf.changeSortColumn(this,columnId);
					return false;
				});
			}
		},
		
		initSelectionCounter: function(){
			this.persistedSelections = $('.persistedSelections',this.container);
			var itemCount = $('.itemCount', this.container);
			this.allSelected = false;

			if(this.persistedSelections.length>0 && itemCount.length){
				//set the list to use post as method for pagination, so the persistedSelections will get posted
				this.submitType = 'post';
				var val = this.persistedSelections.val();
				if(val=='all'){
					this.allSelected = true;
					this.persistedSelectionCount = this.totalItems - this.items.length;
				}else{
					var originalList = val.replace(/,\s/g,',');
					var paddedList = ',' + originalList + ',';
				
					//check the persisted selections to make sure that none of the items are duplicated in the checkbox list
					this.items.each(function(){
						var listCheck = new RegExp(',' + this.value + ',');
						if (listCheck.test(paddedList)) {
							//  match to value in the persistedSelections hidden field, so remove it
						  	paddedList = paddedList.replace(listCheck, ',');
						}
					});
					
					var scrubbedValue = "";
					var paddedListLength = paddedList.length;
					if(paddedListLength>2){
						// remove the leading and trailing commas
						scrubbedValue = paddedList.substring(1,paddedList.length-1);
					}
					
					// reset the value of the persistedSelections field with the new scrubbed value 
					$('.persistedSelections',this.container).val(scrubbedValue); 
					this.persistedSelectionCount = (scrubbedValue.length==0) ? 0 : scrubbedValue.split(',').length;
				}
				
				// get the label for the list objects. For example if the list is a product list, then the label would be "Products"
				var itemType = $('.itemType',this.container);
				this.itemType = (itemType.length>0) ? itemType.val() : messages.ITEMS;
				this.viewingOnlySelections = ($('.viewingOnlySelections',this.container).val()=='true') ? true : false;
				var itemTypeSingular = $('.itemTypeSingular',this.container);
				this.itemTypeSingular = (itemTypeSingular.length>0) ? itemTypeSingular.val() : messages.ITEM;
				
				// look for the all selected message in the hidden field
				var allSelected = $('.allSelectedMessage',this.container).val();
				if(!allSelected){
					// if no message found, then use the default
					allSelected = messages.ALL_ITEMS_SELECTED.replace('{0}',this.itemType);
				}
				
				// look for the viewing only selected message in the hidden field
				var viewingOnlySelectionsMessage = $('.viewingOnlySelectionsMessage',this.container).val();
				if(!viewingOnlySelectionsMessage){
					// if no message found, then use the default
					viewingOnlySelectionsMessage = messages.VIEW_ALL_MSG.replace('{0}',this.itemType);
				}
						
				// look for the viewing only selected message in the hidden field
				var viewingOnlySelectionsLink = $('.viewingOnlySelectionsLink',this.container).val();
				if(!viewingOnlySelectionsLink){
					// if no message found, then use the default
					viewingOnlySelectionsLink = messages.VIEW_ALL_LINK;
				}
				
				var selectAllLink = messages.SELECT_ALL_ITEMS.replace('{0}','<strong>'+this.totalItems + '</strong>').replace('{1}',this.itemType);
				var viewAllMsg = messages.VIEW_ALL_MSG.replace('{0}',this.itemType);
				
				var s = [];
				s.push('<table cellpadding="0" cellspacing="0" border="0"><tr>');
				s.push(		'<td class="count">'+this.persistedSelectionCount + this.selectedItemLength+'</td>');
				s.push(		'<td class="itemLabel">' + this.itemType + '</td>');
				s.push(		'<td>');
				s.push(			'<div class="selectAll" style="display:none"><span class="link">'+selectAllLink+'</span></div>');
				s.push(			'<div class="selected" style="display:none"><span class="msg">'+allSelected+'</span></div>');
				s.push(		'</td>');
				
				if(this.viewingOnlySelections){
					s.push(		'<td><div class="selectedFilter" ><span class="msg">'+viewingOnlySelectionsMessage+' &nbsp;  | &nbsp; <span class="msgLink">'+viewingOnlySelectionsLink+'</span></span></div></td>');
				}else{
					s.push(		'<td class="view"><span class="link">'+messages.VIEW_SELECTIONS+'</span></td>');
				}
				s.push(		'<td class="clear"><span class="link">'+messages.CLEAR_SELECTIONS+'</span></td>');
				s.push(	'</tr></table>');
				
				itemCount.append(s.join(''));
				
				this.itemLabel = $('.itemLabel',itemCount);
				
				if(this.persistedSelectionCount>0){
					$('.clear, .view',itemCount).show();
				}else{
					$('.clear, .view',itemCount).hide();
				}
				
				this.refreshSelectionCount();
				
				var oSelf = this;
				
				//bind onclick events for the links
				$('.selectAll .link',itemCount).click(function(){
					var persistedSelections = defaults.selectAllResults;
					if(oSelf.totalPages==1){
						persistedSelections = oSelf.persistedSelections;
					}
					$('.persistedSelections',this.container).val(persistedSelections);
					$('.clear, .selected',itemCount).show();
					$('.selectAll, .view',itemCount).hide();
					$('.count',itemCount).text(oSelf.totalItems);
				});
				
				$('.clear .link',itemCount).click(function(){
					oSelf.selectAllCheckbox.checked = false;
					oSelf.toggleSelectAll();
					oSelf.persistedSelectionCount = 0;
					$('.persistedSelections',this.container).val('');
					$('.count',itemCount).text(0);
					$('div, .selected, .clear, .view, .selectAll',itemCount).hide();
					if(oSelf.viewingOnlySelections){
						submitListAction(oSelf,'viewAll');
					}
				});
				
				if(this.allSelected){
					$('.selected', itemCount).show();
				}
				
				$('.view .link',itemCount).click(function(){
					$('.currentPage',oSelf.container).val('1');
					submitListAction(oSelf,'viewSelections');
				});
				
				$('.msgLink',itemCount).click(function(){
					submitListAction(oSelf,'viewAll');
				});
			}
		},

		
		refreshSelectionCount: function(){
			var count = this.persistedSelectionCount + this.selectedItemLength;
			$('.itemCount .count',this.container).text(count);

			if(this.itemLabel){
				var itemsLabel = this.itemType;
				if(count==1){
					itemsLabel = this.itemTypeSingular;
				}
				this.itemLabel.text(itemsLabel + " " + messages.SELECTED);
			}
			var view = $('.itemCount .view',this.container)
			if(count==0 || $('.persistedSelections',this.container).val()==defaults.selectAllResults){
				view.hide();
			}else{
				view.show();
			}
			
		},


		toggleSelectAllMsg: function(showMsg){
			// show the select all message
			if(defaults.selectAllAcrossPagesEnabled){
				//All X items on this page are selected. Select all items that match this search.
				var itemCount = $('.itemCount', this.container);
				if(showMsg){
					if(!this.viewingOnlySelections){
						$('.selectAll').show();
						$('.selected',itemCount).hide();
					}
				}else{
					if(this.allSelected){
						this.persistedSelectionCount==0
						this.allSelected = false;
						$('.count',itemCount).text(0);
					}
					if(this.persistedSelectionCount==0){
						$('.clear',itemCount).hide();
					}

					$('div:not(.selectedFilter)',itemCount).hide();
					if($('.persistedSelections',this.container).val()==defaults.selectAllResults){
						$('.persistedSelections',this.container).val('');
						this.persistedSelectionCount=0;
					}
				}
			}
		},
	
		
		/******************************************************************************
		*  Enables buttons and highlights rows for checked items <br />
		*  Then loops through the check boxes and performs each item's onclick() method.<br />
		*  Example: <code>obj.refreshState()</code>
		*  @private
		*  @return VOID
		*****************************************************************************/
		refreshState: function(init){
			// reset properties
			this.disabledBtnArray = [];
			this.disabledButtons = [];
			this.disabledButtonNameArray = [];
			var oThis=this;
			//DR_Utils_Profiler.clear();
			//DR_Utils_Profiler.start();
			//log(jQuery(":checkbox:checked",this.container).attr('data-disabled-buttons').length);
					
			this.selectedItemLength = 0;
			
			this.items.each(function(){
				
				if (typeof this.onclick == 'function') {
					// emulate a mouse click on the check box, it will run whatever was in the onclick attribute for the checkbox
					this.onclick();
				}
				if (this.checked) {
					oThis.selectedItemLength++;

					oThis.updateDisabledButtons(this, true, false);
					//this.disabledBtnArray[this.disabledBtnArray.length] = disabledButtons;
					if (init) {
						oThis.highlightRow(this);
					}
				}
			});
			//DR_Utils_Profiler.log('Finished indexing');
			//DR_Utils_Profiler.view();
			this.refreshButtonState();	
			this.refreshSelectAllState(false);
			
		},
		
		updateDisabledButtons: function(item,add,single){
			
			var disabledButtons = item.getAttribute("data-disabled-buttons");
			if(disabledButtons!==undefined && disabledButtons!==null ){
				var disabledButtons = disabledButtons.trim().split(' ');
				
				for(var i=0;i<disabledButtons.length;i++){
					var btnName = disabledButtons[i];
					var total=0;
					var currentValue = this.disabledButtons[btnName];
					if(currentValue!==undefined){
						if(single && !add){
							total = currentValue-1;
						}else{
							total = currentValue+1;
						}
					}else if (add){	
						total = 1;
					}
					this.disabledButtons[btnName] = total;
				}
			}
		},
			
		refreshButtonState: function(){
			//loop buttons to see which should be disabled
			var selectedCount = this.persistedSelectionCount+this.selectedItemLength;
			for (var j=0; j < this.buttonsTop.length; j++){
				var btn = this.buttonsTop[j];
				var btnIsDisabled = (selectedCount==0) ? true : false;
				/*
				var disabledButtonsStr = this.disabledBtnArray.join(" ");
				
				//Check to see if one or more of the selected checkboxes has requested this button be disabled
				if(disabledButtonsStr.trim().length>0){
					var matches = disabledButtonsStr.match(new RegExp(btn.name,"g"));
					if (matches!==null) {
						
						btnIsDisabled=true;
					}
				}*/
				if(this.disabledButtons[btn.name]!==undefined){
					if(this.disabledButtons[btn.name]>0){
						btnIsDisabled=true;
					}
				}
				
				// if multiple checkboxes are checked, disable "single" buttons
				if(!btnIsDisabled){
					if (selectedCount >= 2 && btn.isSingle) {
						btnIsDisabled=true;
					} 
				}
				
				//based on the logic above, we now update the button disabled state
				btn.buttonObj.disabled=btnIsDisabled;
				
				//we also need to update the matching button in the bottom row, if it is present
				if(this.buttonsBottom.length>0 && typeof this.buttonsBottom[j] !== undefined ){
					this.buttonsBottom[j].buttonObj.disabled=btnIsDisabled;
				}
			}
		},
		
		refreshSelectAllState: function(noRefresh){
			if (this.selectAllCheckbox){
				if (!this.selectAllCheckbox.disabled){
					
					this.selectAllCheckbox.checked = (this.selectedItemLength ==  this.items.length) ? true: false;
				}
			}
			if(!noRefresh){
				this.refreshSelectionCount();
			}
		},

		
		/******************************************************************************
		*  Called when the user clicks on a checkbox/radio button<br />
		*  @param {Object} item Object to toggle
		*  @return VOID
		*****************************************************************************/
		toggle: function(item){
			if(item.type=='radio'){
				if(this.currentSelectedItem!=item && this.currentSelectedItem!==null){
					this.highlightRow(this.currentSelectedItem);
                    this.updateDisabledButtons(this.currentSelectedItem,false,true);
				}
				this.currentSelectedItem=item;
			}else{
				if(!item.checked){
					this.toggleSelectAllMsg(false);
				}
			}
			this.highlightRow(item);
			this.refreshSelectionCount();
			this.selectedItemLength = this.items.filter(":checked").length;
			this.updateDisabledButtons(item,item.checked,true);
			this.refreshButtonState();	
			this.refreshSelectAllState(false);
		},

		
		/******************************************************************************
		*  Selects/deselects all checkboxes in the list depending on state of <code>prefix_selectAll</code> checkbox<br />
		*  Example: <code>offersList.toggleSelectAll()</code>
		*  @return VOID
		*****************************************************************************/
		toggleSelectAll: function(){
			var checkboxes = this.items;
			var isChecked = (this.selectAllCheckbox && this.selectAllCheckbox.checked) ? true : false;
				
			// select/deselect accordingly
			this.items.attr('checked', isChecked);

			//highlight rows
			this.tableRows = $("TABLE.dataTable > TBODY > TR:not(.unselectable)",this.container);
			if(isChecked){	
				this.tableRows.addClass("selected");
			}else{
				this.tableRows.removeClass("selected");
			}
			this.refreshState();
			this.toggleSelectAllMsg(isChecked);
		},
		


		/******************************************************************************
		*  Changes class name of object to highlight row<br />
		*  Example: <code>obj.highlightRow(obj)</code>
		*  @private
		*  @param {Object} obj Object to apply highlight class name
		*  @return VOID
		*****************************************************************************/
		highlightRow: function(obj){
			var isChecked = (obj.checked) ? true : false;
			var row = obj.parentNode.parentNode;

			if (isChecked){
				// highlight
				$(row).addClass("selected");
			}
			else{
				// remove highlighting
				$(row).removeClass("selected");
			}
		},

		/******************************************************************************
		*  Sorts list columns ascending or descending depending on their current state<br />
		*  Example: <code>offersList.sortColumn()</code>
		*  @param {AnchorTagObject} obj Anchor tag clicked on to sort the column
		*  @param {String} columnID Name of column you want to sort
		*  @return VOID
		*****************************************************************************/
		changeSortColumn: function(obj, columnID)
		{
			var defaultSortDirection =  "ascending";
			var drDefaultsortDirection = $(obj).attr("data-default-sort-direction");
			if(drDefaultsortDirection){
				if(drDefaultsortDirection.indexOf("desc")>-1 || drDefaultsortDirection.indexOf("descending")>-1){
					defaultSortDirection = "descending";
				}
			}
			var direction = defaultSortDirection;
			
			if($(obj.parentNode).hasClass("ascending") || $(obj.parentNode).hasClass("descending")){
				// the user clicked a column that is the current sort
				var currentDirection = $(obj.parentNode).hasClass("descending") ? "descending" : "ascending";
				direction = (currentDirection=="ascending") ? "descending" : "ascending";
			}

			if(this.sortColumn.length>0){
				/*
				 * Prevent the processing image from showing up on the search button
				 */
				if(DR.Widgets.Button!==undefined){
					DR.Widgets.Button.disableSearchButton = function(){
						// Do nothing
					}
				}
				
				this.sortColumn.val(columnID);
				this.sortDirection.val(direction);
				
				this.changePage(1, false, null);

			}else{
				if(console){
					console.log('sortColumn and/or  sortDirection not found')
				}
			}
		},
				
		initPaging: function(){
			// check to see if the paging type is querystring
			
			//this.pageDisplayTop = $('.paginationTop',this.container)[0];
			//this.pageDisplayBottom = $('.paginationBottom',this.container)[0];
			this.controls = $('.pagination', this.container);
			this.itemCountContainers = $('.items',this.container);
			this.refreshItemCount();
			
			var oSelf = this;
			$('A',this.controls).click( function(){oSelf.handlePagerClick(this);return false;});
			this.pageInputs = $('INPUT.currentPage',this.controls);
			this.pageInputs.val(this.originalPageValue);
			this.pageInputs.keypress(function(evt){oSelf.doEnterPush(evt, this); });
			
			this.pageUrl = $('.pageUrl',this.container); 
			this.searchFilters = $('.searchFilters',this.container);
			this.sortColumn = $(".sortColumn",this.container);
			this.sortDirection = $(".sortDirection",this.container);
			
			this.resetPagerState();
		},
		
		refreshItemCount: function(){
			
			this.originalPage = $('.originalPage',this.container)
			this.originalPageValue = parseInt(this.originalPage.val(),10);
			
			this.currentPage = this.originalPageValue;
			this.totalPages = parseInt($('input.totalPages',this.container).val(),10);
			if (isNaN(this.totalPages)){
				this.totalPages = 1;
			}
	
			// get the latest item counts
			this.totalItems = $('.totalItems',this.container).val();
			this.firstItem = $('.firstItemOnPage',this.container).val();
			this.lastItem = $('.lastItemOnPage',this.container).val();
		
			// update the UI with the new counts
			$('.totalItems',this.itemCountContainers).text(this.totalItems);
			$('.firstItem',this.itemCountContainers).text(this.firstItem);
			$('.lastItem',this.itemCountContainers).text(this.lastItem);
			// show the item couns
			this.itemCountContainers.css('visibility','visible');
		},
		
		handlePagerClick: function(link){
			link = $(link);
			if(link.hasClass('off')){
				// the button is disabled, so do nothing
				return ;
			}else if(link.hasClass('first')){
				this.changePage(1);
			}else if(link.hasClass('prev')){
				this.changePage(this.originalPageValue-1);
			}else if(link.hasClass('next')){
				this.changePage(this.originalPageValue+1);
			}else if(link.hasClass('last')){
				this.changePage(this.totalPages);
			}
		},
		
		resetPagerState: function(){
			var totalPages = this.totalPages;
			var currentPage = this.currentPage;
			$('strong.totalPages',this.controls ).text(totalPages);
			var disable = false;
			if(totalPages==1){
				disable = true;
				$('A',this.controls).addClass('off');	
			}else if(currentPage==1){
				$('A.first, A.prev',this.controls).addClass('off');	
				$('A.next, A.last',this.controls).removeClass('off');
			}else if(this.currentPage==totalPages){
				$('A.first, A.prev',this.controls).removeClass('off');	
				$('A.next, A.last',this.controls).addClass('off');
			}else{
				$('A',this.controls).removeClass('off');
			}

			if(disable){
				this.pageInputs.attr("disabled", "disabled");
			}else{
				this.pageInputs.removeAttr("disabled");
			}
		},
		
		doEnterPush: function(evt, el){
			// if the Enter key was pressed, change the page
			if (evt.keyCode==13)
			{
				var pageNumber = el.value;
				if (isNaN(pageNumber) || pageNumber < 0)
				{
					alert(messages.INVALID_NUMBER);
					el.select();
					if (evt.preventDefault) {
					  evt.preventDefault();
					} else if (window.event) {
						window.event.cancelBubble = true;
						window.event.returnValue = false;	
					}

		            return false;		
				}else{
					if (pageNumber > this.totalPages){
		      			pageNumber = this.totalPages;
		  		  	}else if (parseInt(pageNumber,10) === 0){
						pageNumber = 1;
					}
	
					this.changePage(pageNumber,true,evt);
				}
			}
		},
		
		changePage: function(pageNumber, enterPush, evt){
			this.currentPage = pageNumber;

			if(defaults.pagesStartAtZero){
				pageNumber--;
			}
			
			if(typeof defaults.pagingOverride =='function'){
				defaults.pagingOverride(this.container, pageNumber);
			}else{
				if(this.submitType.toLowerCase()=='post'){
					var changePageInput = $('.currentPage',this.container);
					changePageInput.val(pageNumber);
					changePageInput[0].form.submit();
				}else{
					var url = "";
					url += this.pageUrl ? this.pageUrl.val() + "?" : "?";
					url += '&page='+pageNumber;
					if(this.searchFilters){
						url += '&' + this.searchFilters.val();
					}
					if(this.sortColumn[0] && this.sortDirection[0]){
						url += '&' + this.sortColumn[0].name+'='+this.sortColumn.val();
						url += '&' + this.sortDirection[0].name+'='+this.sortDirection.val();
					}
					window.location = url;
				}
			}
			
			// prevent the form from being submitted
			if(enterPush){
				if (evt.preventDefault) {
				  evt.preventDefault();
				} else if (window.event) {
					window.event.cancelBubble = true;
					window.event.returnValue = false;	
				}
				return false;
			}

		}
		
		
	};
	
	/*
	 * List Public API for static methods
	 */
	$.dr.list = {
		
		/*
		 * Gets localized strings
		 */
		getMessages: function(){
			return messages;
		},
		
		/*
		 * Gets defaults, localized strings
		 */
		getDefaults: function(){
			return defaults;
		},
		
		/*
		 * Sets defaults
		 * Example of options being passed:
		 * $.dr.list.setDefaults( {VIEW_SELECTIONS:'View Selections'} );
		 */
		setDefaults: function(options){
			if(options){
				options = $.dr.utils.legacyMap(options, legacyMappings);
				$.extend(defaults, options);
			}
			//inform any listeners to the event
			$(document).trigger('afterListSetDefaults',[options]);
		},
	
		/*
		 * Sets defaults, localized strings
		 * Example of options being passed:
		 * $.dr.list.setMessages( {GROUP_ERROR_BOX_ITEM_TITLE:"Click to jump to field"} );
		 */	
		setMessages: function(newMessages){
			if(newMessages) {
				$.extend(messages, newMessages);
			}
			//inform any listeners to the event
			$(document).trigger('afterListSetMessages',[newMessages]);
		}
	};
	
	/******************************************************************************
	*  Searches page for DIV's with class of listControl, and then<br />
	*  creates a $.dr.list object bound to the ID of the DIV if present.<br />
	*  Example: <code>$.dr.list.init()</code>
	*  @return VOID
	*****************************************************************************/
	var initLists = function(evt, context){
		var lists = $('DIV.listControl',context).each(function(count){
			var dataTable = $('TABLE.dataTable',this);
			if(dataTable.length>0 ||  $('div.listTabs',this).length>0){
				var id = this.getAttribute('id');
				if(!id){
					id = 'list_' + count + "_" + new Date().getTime();
					this.id = id;
				}
				 $(this).data('list',new list(id));
			}
		});
	}
	
	$.dr.addUnobtrusiveEvent(initLists);
	
	
	/*
	 * Setups list controls for a context area
	 * 
	 * $('#myContext').dr.list();
	 */
	$.namespace('dr',{
		list: function(){
			return this.each(function(){
				var context = this;
				if(this.tagName!='body'){
					context = this.parentNode;
				}
				initLists(null, context);
			});
		}
	});
	
	/*
	 * Refreshes the button state after using ajax to replace table rows
	 * 
	 * $('#myTable').dr.list.refreshState();
	 */
	
	$.namespace('dr.list',{
		refreshState: function(){
			return this.each(function(){
				var listObj =  $(this).data('list');
				if(listObj){
					listObj.refreshItemCount();
					listObj.resetPagerState();
					listObj.initCheckboxes(false);
					listObj.refreshState();
				}
			});
		}
	});
	
})(jQuery);

;
(function($){
    $.fn.extend({
		// sets the max height of a container based on the tallest child that matches tag
        	setMaxHeight: function(tag, minHeight, setMaxHeight){
			// if we sent in a list of tags, loop through each tag.
            return this.each(function(){
				var maxHeight = 0, mh = 0;
				if (jQuery.isArray(tag)) {
					for (var i = 0, len = tag.length; i< len; i++) {
						if (typeof tag[i] !== 'undefined') {
							var mh = Math.max($(this).getMaxHeight(tag[i]), minHeight);
							if (mh > maxHeight) {
								maxHeight = mh;
							}
	                	}
					}
				} else {
	                if (typeof tag !== 'undefined') {
	                    maxHeight = Math.max($(this).getMaxHeight(tag), minHeight);
	                }					
				}
				
				if(maxHeight > setMaxHeight && setMaxHeight != null){
					var newHeight = setMaxHeight - 9;  //resize so that it does not go over menu border and shadow
					$(this).height(setMaxHeight).find('.tier3-container').height(newHeight).addClass('scroller');
					
				} else {
					$(this).height(maxHeight);	
				}
            });
        },
        getMaxHeight: function(tag){
            var maxHeight = 0;
            $(tag, this).each(function(){
                maxHeight = Math.max(maxHeight, $(this).outerHeight(true));
            });
            return maxHeight;
        }
    });
})(jQuery);

(function($){
	// set a constant to hold the text we show if we can't find help text for an element
	var BLANK_LABEL = '';
	var BLANK_TEXT = '';

	var MIN_HEIGHT = 220;
	var MORE_ABOUT_TEXT = '\u4E86\u89E3\u66F4\u591A{0}';
	var $activeMenu; 
	
	var hideHelp = false; //shows help by default
	var scroller = false; //hides scroller by default
	var maxSubNavHeight = null; //set default
	var hideIcons = false;  
	
    var defaults = {
		recentItemsUrl: 'test-json.jsp',
		recentItemsKey: 'key',
		helpCallback: function(url){
			var obj = { url: url, width: 500, height: 500 };
			$.dr.popup(obj);
		},
		errorCallback : function(xhr, statusText, errorThrown) {
			$.dr.utils.logError(errorThrown);
		},
		externalLinkMouseover : function() {
			var $li = $(this);
			var $link = $li.find('>a');
			
			var args = Array.prototype.slice.call(arguments);
			var $help = args[0];
			var options = args[1];
			var tier1ID = args[3];
			var $menu;
			
			if (! $li.data("loaded")) {
				// TODO get the link from data-ajax-url. This requires a taglib change in pacific-gc to HoverMenuExternalLink.java
				var ajaxUrl = $link.attr('href');
				if (ajaxUrl.indexOf('#') === -1) {
					// set a loading mask on the help container, and get some AJAX
					$.dr.menu.setHelpContainerText.apply(this, [$help, options.loadingMask, "expanded"]);

					$.ajax({
						url: ajaxUrl,
						dataType: 'text',
						success: function(htmlStr) {
							htmlStr = $.trim(htmlStr);
							// create a document fragment from the response
							var $resp = $(htmlStr);
							if ($resp.hasClass('menu')) {
								$li.removeClass('external').addClass('more');
								$menu = $li.find('div.tier3-container');
								var params = [$resp.html()].concat(args);
								$.dr.menu.addMenu.apply($menu, params);
 
								// if we are still hovering on the link ...
								if ($li.hasClass('hover')) {
									$.dr.menu.setActiveMenu($menu);
									args[2] = "collapsed";
									$.dr.menu.setHelpContainer.apply(window, args);
								}							
							} else if ($resp.hasClass("helpText")) {
								$li.data('loaded', $resp.html());
								$.dr.menu.setHelpContainerText.apply($li[0],[$help,  $resp.html(), "expanded"]);							
							}
						},
						error : function(xhr, errorText) {
							$.dr.menu.setHelpContainerText.apply($li[0],[$help, "Error retrieving content: " + xhr.status + ' ' + xhr.statusText, "expanded"]);	
						}
					});				
				}	
			} else {
				$.dr.menu.setHelpContainerText.apply($li[0],[$help, $li.data('loaded'), "expanded"]);
			}			
		},
		loadingMask : '<div class="loadingSmall"><div class="abs"><span>Loading</span></div></div>'
	};

	var setURL = null;
	
	var legacyMappings = {
		RECENT_ITEMS_URL: 			"recentItemsUrl",
		RECENT_ITEMS_KEY: 			"recentItemsKey",
		HELP_CALLBACK: 				"helpCallback",
		ERROR_CALLBACK: 			"errorCallback",
		EXTERNAL_LINK_MOUSEOVER: 	"externalLinkMouseover",
		LOADING_MASK: 				"loadingMask"
	}
	
	var escapeXml = function(str) {
		return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&apos;');
	}
	
    var cancelAll = function(timeout, animator) {
    	if (typeof(timeout) != "undefined" && timeout !== null) {
            clearTimeout(timeout);
        }
        
    	if (typeof animator !== "undefined" & animator !== null) {
            animator.stop(true, true);
			// reset the width and left css to their original values
			animator.css('left', '').css('width','');
        }
    };
	      
	var errorCallback = function(xhr) {
		$.dr.utils.logError(xhr);
		//window.location = $.dr.LOGIN_URL;
	};
	
	var setHelpContainerText = function($container, txt, size) {

        if (hideHelp === true) {
            $('.help-text').css('display', 'none');
        }
		
		else {
            var $menu = $container.parents('.mega-menu');

            $container.find('.help-text-container').html(txt).find('a.helpPopup').click(function(){
                defaults.helpCallback($(this).attr('data-help-url'));
                $menu.hide(0).parent().removeClass('hover');
                return false;
            });

            if (size === "collapsed") {
                $container.removeClass('mega-menu-help-expanded').addClass('mega-menu-help-collapsed');
            }
            else {
                $container.addClass('mega-menu-help-expanded').removeClass('mega-menu-help-collapsed')
            }
            
        }
	};

	var setRecentItems = function($container, txt, key, size) {
		var $ric = $('.recent-items-container', $container);
		$ric.find('.ric-subcontainer').hide();
		
		var $sub = $("#ric_" + key);
		if (! $sub.length) {
			$sub = $ric.append('<div id="ric_' + key + '" class="ric-subcontainer">').find("#ric_" + key);
		}
		$sub.html(txt).show();
		var $menu =  $container.parents('.mega-menu');
		$sub.find('a.recent-item').click(function(e) {
			$menu.hide(0).parent().removeClass('hover');
		});
		
		var $scroller = $sub.find('.recentScroller');
		if ($scroller.length) {
			// set scrolling
			var h2h = $sub.find('>h2').outerHeight();
			var h = $container.innerHeight();
			$scroller.height(h - h2h);
		}
		
		if (size === "collapsed") {
			$container.removeClass('mega-menu-help-expanded').addClass('mega-menu-help-collapsed');
		} else {
			$container.addClass('mega-menu-help-expanded').removeClass('mega-menu-help-collapsed')
		}				
	};

	var getLabel = function(args) {
		var result = (args.length) ? $.dr.menu.strings[args[0]] || {} : {};
		for (var i=1, len = args.length; i < len; i++) {
			if (result[args[i]]) {
				result = result[args[i]];
			} else {
				break;
			}
		}
		return result.label || BLANK_LABEL;
	};
	
	var getRecentLabel = function(args) {
		var result = (args.length) ? $.dr.menu.strings[args[0]] || {} : {};
		for (var i=1, len = args.length; i < len; i++) {
			if (result[args[i]]) {
				result = result[args[i]];
			} else {
				break;
			}
		}
		return result.label || BLANK_LABEL;
	};

	var getText = function(args) {
		var result = (args.length) ? $.dr.menu.strings[args[0]] || {} : {};
		for (var i=1, len = args.length; i < len; i++) {
			if (result[args[i]]) {
				result = result[args[i]];
			} else {
				break;
			}
		}
		return result.helpText || BLANK_TEXT;				
	};
	
	var getLink = function(args) {
		var result = (args.length) ? $.dr.menu.strings[args[0]] || {} : {};
		for (var i=1, len = args.length; i < len; i++) {
			if (result[args[i]]) {
				result = result[args[i]];
			} else {
				break;
			}
		}
		return result.helpLink || null;				
	};

	var getHelpText = function() {
		var args = arguments;
		var key = args[(args.length - 1)];
		var html = '';

		var label = getLabel(args);
		var hText = getText(args);
		var link = getLink(args);
		var className = 'info';
		
		if (key) {
			var c = $('#' + key).attr('class'), classNames=[];
			
			if (c && c.length) {
				classNames = c.split(' ');
			}
	
			for (var i = 0, len = classNames.length; i < len; i ++) {
				if (classNames[i] !== 'more' 
						&& classNames[i] !== "standalone"
						&& classNames[i] !== "external"  
						&& classNames[i] !== "tier3-list"
						&& classNames[i] !== 'tier1'
						&& classNames[i] !== 'hover' 
						&& classNames[i] !== 'active') {
							
					className = classNames[i];
				}	
			}			
		}else{
			return '';
		}
		
		if (label) {
			html += '<h2 class="' + className + '">' + label + '</h2>';
		}
		
		if (hText) {
			html += '<p>' + hText +'</p>';
		}

		if (link) {
			html += '<p><a class="helpPopup" data-help-url="'+ link +'" href="' + link + '">' + MORE_ABOUT_TEXT.replace("{0}",label) + '</a></p>';
		}

		return html;
	};

	var createRecentItemsList = function() {
		var args = Array.prototype.slice.apply(arguments);
		var items = args.shift();
		var label, list;
		var key = args[(args.length -1)];

		var list = '<div class="recentScroller"><ul>';
		for (var i=0, len = items.length; i<len; i++) {
			list += '<li><a href="' + items[i][1] + '" class="recent-item">' + escapeXml(items[i][0]) + '</a></li>';
		}
		list += '</ul></div>';
		label = '<h2 class="'+ key + '">Recent ' +  getRecentLabel.apply(this, args) + '</h2>';
		return label + list;
	};
	
	var setHelpContainer = function() {
		var $help = this; // $help is the parent help container
		
		var args = Array.prototype.slice.apply(arguments);
		var options = args.shift();
		var size = args.shift();
		
        var key = args[(args.length - 1)];
        if (typeof hasRecentItems !== "undefined" && hasRecentItems[key]) {
			// Hide the help text container
			$('.help-text-container', $help).hide();
		
			// Show the recent items container
			$('.recent-items-container', $help).show();
			
			// Set the loading mask on the recent items sub container
			setRecentItems($help, defaults.loadingMask, key, size);

            $.dr.menu.getRecentItemsJson(key, options, function(json, cached) {
				var html = createRecentItemsList(json.items, args);
               	setRecentItems($help, html, key, size);
			});
        } else {
			// show the help text container
			$('.help-text-container', $help).show();
			
			// hide the recent items container
			$('.recent-items-container', $help).hide();
		
			var html = getHelpText.apply(this, args);
			if(html){
				setHelpContainerText($help, html, size);
			} else {
				setHelpContainerText($help, '', size);
			}
		}
	};
	
	// Controls how fast the menus open and close
    var interval = [
		{open: 400, close: 400}, // level 1
		{open: 400, close: 400}
	];

    var tier1ID, tier2ID, tier3ID;

	$.dr.menu = {
		cache: {},
		showMethod : ($.browser.msie) ? $.fn.show : $.fn.fadeIn,
		hideMethod : ($.browser.msie) ? $.fn.hide : $.fn.fadeOut,
		TO: null, 
		animator: null,
		setActiveMenu: function(jObj) {
			$activeMenu = jObj;
			$activeMenu.show();
			$activeMenu.parent().addClass('active');
		},
		getActiveMenu: function() {
			return $activeMenu;
		},
		getRecentItemsJson: function(key, options, callback, errorCallback) {
			var oThis = this;
			if (typeof this.cache[key] === "undefined") this.cache[key] = {};
			if (this.cache[key].xhrData) {
				// second flag alerts the callback that cached data is coming.
				var cached = (typeof this.cache[key].xhrRequest === "boolean") ? false : true;
				callback(this.cache[key].xhrData, cached);
			} else {
				if (! this.cache[key].xhrRequest) {
					
					var data = {ajaxTime: new Date().getTime()};
					data[options.recentItemsKey] = key;

					this.cache[key].xhrRequest = $.ajax({
						data: data,
						dataType: 'json',
						url: options.recentItemsUrl,
						success: function(json, status, xhr) {
								//Adapting single quotes to double quotes
								var json_parse = ($.parseJSON) ? $.parseJSON : JSON.parse;
									jsonResult = json_parse(xhr.responseText);
								if (jsonResult != false){
									json = jsonResult;
									oThis.cache[key].xhrData = json;
									if (typeof callback === "function") {
										callback(json, false);// false to alert the callback that the data is not cached
									}
								}else{
									// show the help text container
									$('.help-text-container').show();
									
									// hide the recent items container
									$('.recent-items-container').hide();
									hasRecentItems = undefined;
									oThis.cache[key].xhrData = undefined;
								}
								
						},
						error: function(xhr, statusText, errorThrown) {
							delete oThis.cache[key];
							if (typeof errorCallback === "function") {
								errorCallback(xhr, statusText, errorThrown);
							} else {
								options.errorCallback.call(this, xhr, statusText, errorThrown);
							}
						}
					});
				}
			}
		},

		setRecentItemsJson : function(key, items, callback) {
			if (typeof this.cache[key]=== "undefined") {
				this.cache[key]= {};
			}
			this.cache[key].xhrData = {
				items: items
			};
			this.cache[key].xhrRequest = true;
		},
		/*
		 * Gets defaults, localized strings
		 */
		getDefaults: function(){
			return defaults;
		},
		
		/*
		 * Sets defaults
		 * Example of options being passed:
		 * $.dr.menu.setDefaults({
		 *  	recentItemsKey: 'key,
		 *  	recentItemsUrl: 'foo.jsp',
		 *  	helpCallback: function(){}
		 * 		externalCallback: function()  
		 *      hideHelp: true
		 *  });
		 */
		setDefaults: function(options){
			if (options) {
				options = $.dr.utils.legacyMap(options, legacyMappings);
				$.extend(true, defaults, options);
				
				
				if(options.hideHelp != null)hideHelp = options.hideHelp;
				if(options.maxSubNavHeight != null)maxSubNavHeight = options.maxSubNavHeight;
				if(options.hideIcons != null)hideIcons = options.hideIcons;
			}
			//inform any listeners to the event
			$(document).trigger('afterMenuSetDefaults', [options]);
		},

		setHelpContainer: function() {
			var args = Array.prototype.slice.call(arguments);
			var container = args.shift();
			
			setHelpContainer.apply(container, args);
		},

		setHelpContainerText : function() {
			setHelpContainerText.apply(this, arguments);
		},
		
		addMenu : function() {
			var $menu = $(this);
			var args = Array.prototype.slice.call(arguments);

			$menu.html(args.shift());
			var $help = args[0];

			// Tier 3 Behaviors 
			$('ul.tier3-list', $menu).hover(
				function() {
					var $this = $(this);
					cancelAll($.dr.menu.TO, $.dr.menu.animator);

					$help.addClass('hover');
					$this.addClass('hover').find('a').addClass('over');
					tier3ID = $this.attr("id");
					$.dr.menu.TO = setTimeout(function() {
						var params = args.slice();
						params.push(tier3ID);
						params[2] = 'collapsed';

						$.dr.menu.setHelpContainer.apply(this, params);
						$this.addClass('active').siblings().removeClass('active');
					}, interval[1].open);
				},
				function() {
					var $this = $(this);
					cancelAll($.dr.menu.TO, $.dr.menu.animator);

					$this.removeClass('hover').find('a').removeClass('over');
					var $help = $this.parents('.mega-menu').find('.help-text');
					
					$.dr.menu.TO = setTimeout(function(){
						$help.removeClass('hover');
						$this.removeClass('active').siblings().removeClass('active');

						var params = args.slice()
						params[2] = 'collapsed';
						
						$.dr.menu.setHelpContainer.apply(this, params);
					}, interval[1].close);
				}
			);			
		},

        setPosition : function($menu) {
            $menu.css({
                'left': this.getPosition($menu.parent(), $menu) + 'px',
                'display': 'none'
            });            
        },

        getPosition : function(parent, child) {
            childWidth = $(child).width();
            windowWidth = $(window).width();
            posX = $(parent).offset().left;
            targetPosX = posX - (childWidth * 0.05) - 10;
            
            if ((targetPosX + childWidth) > windowWidth) {
                targetPosX = windowWidth - childWidth;
            } else if (targetPosX < 0) {
                targetPosX = 0;
            }
            return targetPosX;            
        },
        
        // override this method to provide strings for helpText
        strings : {}
	};
 	var inited = false;
    $.namespace('dr', {
        menu: function(menuOptions){
        	var $this = $(this), fadeSpeed = $.browser.msie ? 0 : 200;	
        	if ($this.length <= 0 && inited === false ) {
                return false;
            }				
			
			//if there are no help text divs then it sets show help to false
			//if it is missing a help text div but has others then it adds the missing div
			
			if ($('div.help-text', $this).length == 0) {
				hideHelp = true;
			}
		
			//help-text divs are required to be there even if you don't plan to show help
			$('.mega-menu .inner', this).each(function(){
				if (!$('div', this).hasClass('help-text')) {
					$('<div>').addClass('help-text').appendTo(this);
				}
			});
		
			inited = true;
            return this.each(function(count){
				
				var $oThis = $this;
				
				if (menuOptions) {
					menuOptions = $.dr.utils.legacyMap(menuOptions, legacyMappings);
				}
                var options = $.extend(true, menuOptions, defaults);

				if (hideHelp) {
					$('.mega-menu .inner', $this).css('width', '400px');
				}

				if (hideIcons){
 					$('.nav').addClass('noIcons');
				}
				
				// set the shadow and the height of the menu
				// sets maxHeight and scroller
				// takes into account maxSubNavHeight
                if (!$('#menu_marketing .wrapper').attr('data-shadowInit')) {
					$('.wrapper', $this).dr.shadows().find('.inner').setMaxHeight(['ul', 'div'], MIN_HEIGHT, maxSubNavHeight).end().attr('data-shadowInit', true);
				}
					
				// Tier 1 behaviors
                $('.mega-menu', this)
					.bind('menuOpen', function(e){
                        var $target = $(e.target);												

						cancelAll($.dr.menu.TO, $.dr.menu.animator);

						// find the correct help text for this menu. Set the tier1ID for later.
						var $li = $target.parents('ul.nav >li');
						tier1ID = $li.attr('id');
						
						var $help = $('.help-text', $target).removeClass('hover');

						// check to see if the user left a menu open
						if ($target.find('ul.tier2-list>li.active').length == 0) {
							setHelpContainer.call($help, options, "expanded", tier1ID);
						} else {
							setHelpContainer.call($help, options, "collapsed", tier1ID, tier2ID);
						}

                        // sets the left position and display to none
                        $.dr.menu.setPosition.call($.dr.menu, $target);
                        $.dr.menu.TO = setTimeout(function(){
                            $.dr.menu.showMethod.call($target, fadeSpeed, function(){
                                $target.data('active', true);
                                
                            });
                        }, $target.data('interval').open - fadeSpeed);
                	})
					.bind('menuClose', function(e){
                        var $target = $(e.target);
						
						cancelAll($.dr.menu.TO,$.dr.menu.animator);

                        if ($target.data('active')) {
                            $.dr.menu.TO = setTimeout(function(){
                                $.dr.menu.hideMethod.call($target, fadeSpeed, function(){
                                    $target.data('active', false).parent().removeClass('hover');
                                })
                            }, $target.data('interval').close);
                        } else {
                            $target.hide().parent().removeClass('hover');
                        }
						$('ul.tier3-list', $(this)).removeClass('active');
						tier3ID = null;
                	})
					.each(function(idx){
                        $(this).data('idx', idx).data('active', false).data('interval', {
                            open: interval[$(this).parents('.mega-menu').length].open,
                            close: interval[$(this).parents('.mega-menu').length].close
                        })
                	})
					.find('a').click(function(){			
						if ($(this).parent().hasClass('more') || $(this).parent().hasClass('external')) {
							// examine the link to see if there is url. If so, allow the click. Otherwise return false.
							if ($(this).attr('href').length && 
									! $(this).attr('href').match(/#$/)) {
								$('.mega-menu', $this).hide();
							} else {
								return false;																
							}			
						} else {
							$('.mega-menu', $this).hide();
						}
                	});

                $('> li', this)
					.hover(
						function(){
	                    	$('.mega-menu:not(:eq(' + $('.mega-menu', $(this)).data('idx') + '))', $this)
								.hide()
								.parent()
								.removeClass('hover');
	                    	$('.mega-menu', $(this))
								.trigger('menuOpen')
								.parent()
								.addClass('hover');
	                	}, 
						function(){
	                    	$('.mega-menu', $(this)).trigger('menuClose');
               			}
					)
					.filter(':has(.mega-menu)')
						.find('> a')
						.click(function(e){
                    		e.preventDefault()
                		});

				// Tier 2 Behaviors
                $('ul.tier2-list>li>a', this)
					.bind('mouseover', function(evt){
						cancelAll($.dr.menu.TO, $.dr.menu.animator);
						var $active = $.dr.menu.getActiveMenu();

                        var $a = $(evt.target);
                        var $li = $a.parent();
						var $help = $li.parent().siblings('.help-text').removeClass('hover');
						if (tier3ID) {
							$('ul.tier3-list', $this).removeClass('active');
							tier3ID = null;
						}
                        if ($a.attr('href').length && 
								! $a.attr('href').match(/#$/)) {
                            $a.addClass('active-link');
                        }														                      

                        if ($li.hasClass('more')) {
							var fn = function() {
								// find the correct help text for this menu. Set the tier1ID for later.
								tier2ID = $li.attr('id');							
									
                                if ($active) {
									$active.parent('li').removeClass('active');
                                    $active.hide();
                                }
                                $active = $a.siblings('div.tier3-container').show();
                                $active.parent().addClass('active');
								$.dr.menu.setActiveMenu($active);

								setHelpContainer.call($help, options, "collapsed", tier1ID, tier2ID);							
							};
                            
							$.dr.menu.animator = $help;
							if ($help.hasClass('mega-menu-help-collapsed')) {
								$.dr.menu.TO = setTimeout(fn, interval[0].open);
							} else {
								$.dr.menu.TO = setTimeout(function() {
									$.dr.menu.animator.removeClass('hover').animate({left: "+=210px",width: "-=210px"}, fadeSpeed, fn);
								}, interval[0].open)
							}                        
                        } else if ($a.parent().hasClass('standalone')) {
							$.dr.menu.animator = $help;
							var fn = function() {
                                // find the correct help text for this menu. Set the tier1ID for later.
                                tier2ID = $li.attr('id');
									
								if ($active) {
									$active.parent('li').removeClass('active');
									$active.hide();
								}
								setHelpContainer.call($help, options, "expanded", tier1ID, tier2ID)								
							};

							if ($help.hasClass('mega-menu-help-expanded')) {
								$.dr.menu.TO = setTimeout(fn, interval[0].close);
							} else {
								$.dr.menu.TO = setTimeout(function() {
									$.dr.menu.animator.removeClass('hover').animate({left: "-=210px",width: "+=210px"}, fadeSpeed, fn);
								}, interval[1].close)
							} 
                        } else if ($a.parent().hasClass('external')) {
							$.dr.menu.animator = $help;
							var fn = function() {
                                // find the correct help text for this menu. Set the tier1ID for later.
                                tier2ID = $li.attr('id');
									
								if ($active) {
									$active.parent('li').removeClass('active');
									$active.hide();
								}
								options.externalLinkMouseover.call($li[0], $help, options, "expanded", tier1ID, tier2ID);							
							};

							if ($help.hasClass('mega-menu-help-expanded')) {
								$.dr.menu.TO = setTimeout(fn, interval[0].close);
							} else {
								$.dr.menu.TO = setTimeout(function() {
									$.dr.menu.animator.removeClass('hover').animate({left: "-=210px",width: "+=210px"}, fadeSpeed, fn);
								}, interval[1].close)
							}
						}
						$li.addClass('hover');
                	})
					.bind("mouseout", function(evt){
						cancelAll($.dr.menu.TO, $.dr.menu.animator);
						var $active = $.dr.menu.getActiveMenu();

                        var $a = $(evt.target);
                        var $li = $a.parent();
						var $help = $li.parent().siblings('.help-text').removeClass('hover');
						
						$li.removeClass('hover');
                        $a.removeClass('active-link');
						
						var fn = function() {
                            if ($active) {
                                $active.parent('li').removeClass('active');
                                $active.hide();
                            }
							$active = null;
							setHelpContainer.call($help, options, tier1ID);
						};
						
						$.dr.menu.animator = $help;
						if ($help.hasClass('mega-menu-help-expanded')) {
							//$.dr.menu.TO = setTimeout(fn, interval[0].close);
						} else {
							$.dr.menu.TO = setTimeout(function() {
								$.dr.menu.animator.animate({left: "-=210px",width: "+=210px"}, fadeSpeed, fn);
							}, interval[1].close)
						}																						
                	});
					
 				$('.tier2-list div.tier3-container', $this)
					.hide()
					.bind('mouseenter', function(){
						if (! tier3ID) cancelAll($.dr.menu.TO, $.dr.menu.animator);
					});               

				// Tier 3 Behaviors 
				$('ul.tier3-list').hover(
					function() {
						var $this = $(this);
						cancelAll($.dr.menu.TO, $.dr.menu.animator);
						
						var $help = $this.parents('.mega-menu').find('.help-text').addClass('hover');
						$this.addClass('hover').find('a').addClass('over');
						tier3ID = $this.attr("id");

						$.dr.menu.TO = setTimeout(function() {	
							setHelpContainer.call($help, options, "collapsed", tier1ID, tier2ID, tier3ID);
							$this.addClass('active').siblings().removeClass('active');
						}, interval[1].open);
					},
					function() {
						var $this = $(this);
						cancelAll($.dr.menu.TO, $.dr.menu.animator);

						$this.removeClass('hover').find('a').removeClass('over');
						var $help = $this.parents('.mega-menu').find('.help-text');
						
						$.dr.menu.TO = setTimeout(function(){
							tier3ID = null;
							$help.removeClass('hover');
							$this.removeClass('active').siblings().removeClass('active');
							setHelpContainer.call($help, options, "collapsed", tier1ID, tier2ID);
						}, interval[1].close);
					}
				);
				
				// Help-text behavior
				$('.help-text', this)
					.each(function() {
						$(this).height($(this).parent().innerHeight());
					})
					.bind('mouseenter', function(evt){
						cancelAll($.dr.menu.TO);
						if (!tier3ID) {
							$(this).removeClass('hover').removeClass('active');
						}
					})
					.bind('mouseleave', function(evt){
						var $this = $(this);
						$this.removeClass('hover');							
					});
            });
			
        },

        menuAjax : function(options){
			var self = this;
			$.ajax({
				url: options.url,
				type: 'GET',
				dataType: 'html',
				success: function(html) {
					$(self).append(html);
						$(self).find('.nav').dr.menu();
				}
			});
		}
    });   

  	var initMegaNav = function(){
		$('.nav').dr.menu();
	};     

	if ($.browser.msie === true) {
		$.dr.addDomReadyEvent(initMegaNav,'domReadyNormal');
	} else {
		$.dr.addDomReadyEvent(initMegaNav,'domReadyEarly');       
	}

})(jQuery);
;(function($) {
  $.namespace('dr',{
		navigation: function(){		
			var $this = $(this), timeout = "", fadeSpeed = !$.browser.msie ? 'fast' : 0;
			var interval = [
				{'open':'100','close':'800'}  // level 1
			];
			var rows = {
				'dfltCol':'3',
				'oneCol':'1',
				'twoCol':'2'
			};	
					
			var getPosition = function(parent,child){			
				childWidth = $(child).width();
				windowWidth = $(window).width(); 											
				posX = $(parent).offset().left;
				targetPosX = posX - (childWidth * 0.05) - 10;

				if((targetPosX + childWidth) > windowWidth){
					targetPosX = windowWidth - childWidth;
				} else if(targetPosX < 0){
					targetPosX = 0;
				}
				return targetPosX;	
			};
			
			var	setPosition = function(){
				$('.menu',$this).each(function(idx){
					$(this).css({'left':getPosition($(this).parent(),$(this))+'px','display':'none'})
				});				
			};
			
			var getRowLen = function(){
				var rowLen = '';
				
				for (var key in rows) {
					if($(this).attr('class').match(key)) {
						rowLen = rows[key];
					} 
				}
				 
				return rowLen == '' ? rows.dfltCol : rowLen;
			};				
						
			return this.each(function(){
				$('.menu:not(.mega-menu)',this)
						.bind('menuOpen',function(e){
							var $target = $(e.target);
							if(typeof(timeout) != "undefined"){
								clearTimeout(timeout);				
							}							
							timeout = setTimeout(function(){
								$target.fadeIn(fadeSpeed,function(){
									$target.data('active',true);
								});										
							}, $target.data('interval').open);
						})
						.bind('menuClose',function(e){
							var $target = $(e.target);
							if(typeof(timeout) != "undefined"){
								clearTimeout(timeout);				
							}	
							if($target.data('active')){
								timeout = setTimeout(function(){
									$target.fadeOut(fadeSpeed,function(){
										$target.data('active',false).parent().removeClass('hover');
									}) 								
								}, $target.data('interval').close);							
							} else {
								$target.hide().parent().removeClass('hover');
							}
						})							
						.each(function(idx){
							$(this)
								.data('idx',idx)
								.data('active',false)
								.data('interval',{open : interval[ $(this).parents('.menu').length ].open, close : interval[ $(this).parents('.menu').length ].close})
						})
						.find('a').click(function(){
							$('.menu',$this).hide();
						})
						.end()
						.find('> ul')
							.dr.shadows()
							.each(function(){
								var $this = $(this), rowHeights = [];

								$(this).children().each(function(index){									
									var row = index == 0 ? 0 : Math.floor(index/getRowLen.call($this));
									$(this).data('row',row);	
									if(typeof(rowHeights[row]) == 'undefined') {
										rowHeights[row] = 0;
									}
									rowHeights[row] = $(this).height() > rowHeights[row] ? $(this).height() : rowHeights[row];					
								});
							
								$(this).children().each(function(){		
									$(this).height(rowHeights[$(this).data('row')]);
								});									
							});
						
				$('> li',this)
					.hover(function(){							
						$('.menu:not(:eq(' + $('.menu',$(this)).data('idx') + '))',$this).hide().parent().removeClass('hover');
						$('.menu',$(this)).trigger('menuOpen').parent().addClass('hover');						
					},function(){
						$('.menu',$(this)).trigger('menuClose');					
					})
					.filter(':has(.menu)')
					.find('> a').click(function(e){e.preventDefault()});
									
				$(window).bind('load resize',setPosition)
			});
		}
  });                            
  var initNav = function(){
		$('.nav').dr.navigation();
  };      
	$.dr.addDomReadyEvent(initNav,'domReadyEarly');  
	     
})(jQuery);
;
(function($){
	$.namespace('dr',{		
		message: function(type){
			return this.each(function(){
				var $this = $(this);			
				var $thisClass = 'messageDialog';			
				var $thisType = type;						
																	
				$this
					.wrap('<div class="' + $thisClass + '" ><div class="messageDialogContent"></div></div>')
					.removeAttr('style')
          .addClass($thisType)
					.parent()
					.dr.shadows()
					.prepend('<a class="close" href="#">Close</a>');

				$('.' + $thisClass)
					.css({
            'top' : '-' + $('.' + $thisClass).height() + 'px',
            'left' : ($(window).width() / 2) - ($('.' + $thisClass).width() / 2) + 'px'
          })
					.animate({top:0}, 1000);
					
				$('a.close').click(function(){
					$('.' + $thisClass).animate({top:'-' + $('.' + $thisClass).height() + 'px' }, 500)
					return false;
				});
        
        $(window).resize(function(){
          $('.' + $thisClass)
					  .animate({
              'left' : ($(window).width() / 2) - ($('.' + $thisClass).width() / 2) + 'px'
            });     
        });
			});
		}
	});
})(jQuery);


	/******************************************************************************
	 * Utility function that displays a javascript prompt that returns true/false
	 * Example: <code>DR.Widgets.Prompt()</code>
	 * @return {Boolean} Boolean
	 *****************************************************************************/	
;(function($) {

	DR.Widgets.Prompt = function(){
		this._type = 'Prompt';
		this.built = false;
		this.questionDiv = null;
		this.liveChangeTextDiv = null;
		this.textInput = null;
		this.overlay = null;
		this.size = 'normal';
		this.isPrompt=false;
		this.isAlert=false;
		this.isCriticalConfirm=false;
		this.isConfirm=false;
		this.isCheckboxPrompt = false;		
		this.modalWarning=false;
		this.isSuccess=false;
		this.iconClass="";
		this.width = 415;
		this.height = 200;
	};
	
	/*
	DR.Widgets.Prompt.CONFIRM = "Confirm";
	DR.Widgets.Prompt.PROMPT = "Prompt";
	DR.Widgets.Prompt.CHECKBOX_PROMPT = "Prompt";
	DR.Widgets.Prompt.ALERT = "Alert";
	DR.Widgets.Prompt.WARNING = "Warning";
	DR.Widgets.Prompt.LIVE_CHANGE_TITLE = "Live Change Warning";
	DR.Widgets.Prompt.LIVE_CHANGE_QUESTION = "Please enter your username as it appears below to confirm you want to save these changes.{0}Username: {1}";
	DR.Widgets.Prompt.INCORRECT_VALUE = "The value you entered is incorrect.";
	*/
	
	DR.Widgets.Prompt.PROMPT = "\u63D0\u793A";
	DR.Widgets.Prompt.CHECKBOX_PROMPT = "\u63D0\u793A";
	DR.Widgets.Prompt.CHECKBOX_PROMPT_QUESTION = "\u6211\u540C\u610F";
	DR.Widgets.Prompt.ALERT = "\u8B66\u544A";
	DR.Widgets.Prompt.WARNING = "\u8B66\u544A";
	DR.Widgets.Prompt.CONFIRM = "\u786E\u8BA4";
	DR.Widgets.Prompt.SUCCESS = "\u6210\u529F";
	DR.Widgets.Prompt.LIVE_CHANGE = "\u6D3B\u52A8\u66F4\u6539\u8B66\u544A";
	DR.Widgets.Prompt.LIVE_CHANGE_QUESTION = "\u8981\u786E\u8BA4\u4FDD\u5B58\u8FD9\u4E9B\u66F4\u6539\uFF0C\u8BF7\u8F93\u5165\u4E0B\u9762\u6240\u663E\u793A\u7684\u60A8\u7684\u7528\u6237\u540D\u3002{0}\u7528\u6237\u540D\uFF1A{1}";
	DR.Widgets.Prompt.INCORRECT_VALUE = "\u8F93\u5165\u7684\u6570\u503C\u9519\u8BEF\u3002";
	
	DR.Widgets.Prompt.prototype = {

		init: function()
		{
			switch(this._type)
			{
				case "Prompt":  			this.modalTitle = DR.Widgets.Prompt.PROMPT;			this.isPrompt=true;  			this.iconClass='modalPrompt'; 		break;
				case "CheckboxPrompt":		this.modalTitle = DR.Widgets.Prompt.CHECKBOX_PROMPT;this.isCheckboxPrompt=true;		this.iconClass="modalPrompt";		this.height = 300; break;
				case "Confirm": 			this.modalTitle = DR.Widgets.Prompt.CONFIRM; 		this.isConfirm=true; 			this.iconClass=''; 					break;	
				case "Alert":   			this.modalTitle = DR.Widgets.Prompt.ALERT; 			this.isAlert=true;  			this.iconClass='modalAlert';		break;
				case "Warning": 			this.modalTitle = DR.Widgets.Prompt.WARNING; 		this.isWarning=true; 			this.iconClass='modalWarning';		break;	
				case "Success": 			this.modalTitle = DR.Widgets.Prompt.SUCCESS; 		this.isSuccess=true; 			this.iconClass='modalSuccess';		break;	
				case "Critical_Confirm":  	this.modalTitle = DR.Widgets.Prompt.LIVE_CHANGE; 	this.isCriticalConfirm=true; 	this.iconClass='modalLiveChange';	this.height = 300; break;
			}
			
			this.instanceId = 'DR.Utils.'+this._type.toUpperCase();
			this.prefixId = 'modal_'+this._type;
			
			var d = document.createElement('div');
				d.id = this.prefixId + "_container";
			
			var f = document.createElement('div');
				f.className = 'questionBg';
				
			var q = document.createElement('div');
				q.className = 'question';
			
			var questionContainer = document.createElement('div');
				q.appendChild(questionContainer);
				
			this.questionDiv = questionContainer;
			
			var saveBtnClass = 'check';
			
			
			
			var cancelBtnOnClick = this.instanceId + '.cancel()';
			var okBtnOnClick = this.instanceId + '.ok()';
			
			var promptInput;
			var liveChangeTextDiv;
			if(this.isPrompt || this.isCriticalConfirm){
				promptInput = document.createElement("div");
				promptInput.className = "input";
				promptInput.innerHTML = '<input type="text" id="'+this.prefixId +'_input" autocomplete="off" onkeyup="'+this.instanceId+'.enterKey(event)" />';
				saveBtnClass= "save";
			}
	
			if(this.isCheckboxPrompt){
				promptInput = document.createElement("div");
				promptInput.className = "input";
				promptInput.innerHTML = '<input type="checkbox" id="'
					+ this.prefixId +'_input" /><label for="' 
					+ this.prefixId +'_input">'
					+ DR.Widgets.Prompt.CHECKBOX_PROMPT_QUESTION + '</label>';
				
				saveBtnClass= "save";
			}
						
			var liveChangeTextDiv;
			var liveChangeText = '';
			if(this.isCriticalConfirm){
				var liveChangeTextDiv = document.createElement('div');
				liveChangeTextDiv.className = 'liveChangeText';
				this.liveChangeTextDiv = liveChangeTextDiv;
			}
			
			var s='';
			if(!this.isAlert && !this.isSuccess)
			{
				s+='<button id="'+this.prefixId+'_cancelBtn" class="button secondary" type="button" onclick="'+cancelBtnOnClick+'"></button>';
			}
			s+='<button id="'+this.prefixId+'_okBtn" type="button" class="button secondary" onclick="'+okBtnOnClick+'" style="margin-right:0;"></button>';

			var pageButtons = document.createElement("div");
				pageButtons.className = "pageButtons";
				pageButtons.innerHTML = s;

			if(this.isPrompt || this.isCriticalConfirm || this.isCheckboxPrompt)
			{
				f.appendChild(q);
				d.appendChild(f);
				if(this.isCriticalConfirm){
					d.appendChild(liveChangeTextDiv);
				}
				d.appendChild(promptInput);
			}else{
				f.appendChild(q);
				d.appendChild(f);
			}
			
			d.appendChild(pageButtons);


			var parentDiv = $('div.content:first');
			if (parentDiv.length === 0) {
				parentDiv = $('body');
			}
			parentDiv.append(d);
			this.okButton =  $('#'+this.prefixId + '_okBtn')[0];
			if(!this.isAlert && !this.isSuccess)
			{
				this.cancelButton = $('#'+this.prefixId + '_cancelBtn')[0];
			}

			if(this.isPrompt || this.isCriticalConfirm)
			{
				$(this.cancelButton).dr.button.text($.dr.strings.CANCEL);
				if(this.isCriticalConfirm){
					$(this.okButton).dr.button.text($.dr.strings.OK);
				}else{
					$(this.okButton).dr.button.text($.dr.strings.SAVE);
				}
				this.textInput = $('#'+this.prefixId + '_input')[0];
			}else if (this.isCheckboxPrompt) {
				this.textInput = $('#' + this.prefixId + '_input').parent('div');
				this.textInput.addClass('checkbox-prompt');
				$(this.okButton).attr('disabled','disabled');
				
			}else if(this.isAlert || this.isSuccess){
				$(this.okButton).dr.button.text($.dr.strings.OK);
			}else{
				$(this.cancelButton).dr.button.text($.dr.strings.NO);
				$(this.okButton).dr.button.text($.dr.strings.YES);
			}
			
			if(this.isCheckboxPrompt) {
				
				// set buttons here
			}
			//$('span span', this.okButton).css('min-width','55px');
			//$('span span', this.cancelButton).css('min-width','55px');
			
			var opts = {
				inline:true,
				id:this.prefixId+'_container',
				optionalClassName:this.iconClass +" modalConfirm",
				showCloseIcon:false,
				width: this.width,
				height: this.height
			};
			
			if(this.isSuccess){
				opts.type='modeless';
			}

			this.overlay = $.dr.overlay(opts);
		},
		
		open: function(question,text,callback,_title,acceptKey,buttonText,timer, acceptQuestion)
		{
			if( (this.isAlert || this.isSuccess || typeof(callback)=='function'  || callback === null) && typeof(question)=='string')
			{
				if(acceptKey){
					this.acceptKey = acceptKey.trim();
					
					var liveChangeText = (acceptQuestion) ? acceptQuestion : DR.Widgets.Prompt.LIVE_CHANGE_QUESTION;
					liveChangeText = liveChangeText.replaceBreaks().replace('{1}','<strong><span id="liveChangeKey">'+this.acceptKey +'<span></strong>');
					this.liveChangeTextDiv.innerHTML = liveChangeText;
				}

				this.questionDiv.innerHTML = question;
				this.overlay.setTitle(_title || this.modalTitle);
				this.overlay.setDisabled(true);
				this.overlay.show();
				
				if(this.isPrompt || this.isCriticalConfirm)
				{
					if(this.isCriticalConfirm){
						acceptQuestion
					}
					this.textInput.value = text;
					this.textInput.focus();
					this.textInput.select();
					
				}else if (this.isCheckboxPrompt){					
					var bText = buttonText || $.dr.strings.OK;

					if (text && text !== '') {
						var label = $('label', this.textInput).html(text);
					} else {
						var label = $('label', this.textInput).html(DR.Widgets.Prompt.CHECKBOX_PROMPT_QUESTION);
					}
					
					var btn = this.okButton;					
					
					if (timer) {						
						var counter = parseInt(timer, 10);
						$(btn).dr.button.text(counter).attr('disabled','disabled');
	
						var fn = function() {
							counter --;
							if (counter === 0) {
								$(btn).dr.button.text(bText);
								$(btn).removeAttr('disabled');
								
							} else {
								$(btn).dr.button.text(counter.toString());
								setTimeout(fn, 1000);
							}						
						}
						setTimeout(fn, 1000);						
					} else {
						$(btn).removeAttr('disabled');
						$(btn).dr.button.text(bText);
					}
						
				}else if (this.isSuccess){
					this.okButton.focus();
				}
				this.callback = callback;				
			}
		},
		
		ok: function()
		{
			var _close = true;
			if(typeof(this.callback)=='function')
			{
				if(this.isPrompt)
				{
					this.callback(this.textInput.value);
				} else if (this.isCheckboxPrompt) {
					// text input is actually a jQuery selector with the parent div of the checkbox and label selected.
					if (this.textInput.find('[type="checkbox"]')[0].checked) {
						var t = this.textInput.find('label').text();
						this.callback(true, t);
					} else {
						this.callback(false);
					}
				} else if (this.isCriticalConfirm) {
					if (this.acceptKey == this.textInput.value.trim()) {
						this.callback(true);
					} else {
						_close = false;
						this.showCriticalConfirmWarning();
					}
				} else {
					this.callback(true);
				}
			}
			if(_close){
				this.overlay.cancel();
			}
		},
		
		enterKey: function (evt)
		{
			var key = (evt.which) ? evt.which : event.keyCode;
			// if the Enter key was pressed, change the page
			if (key==13) {
				var val = this.textInput.value.trim();
				if( ( this.lastValue!==undefined && this.lastValue != val ) || (this.isCriticalConfirm && this.acceptKey==val)){
					this.ok();
				}
				this.lastValue = val;
			}
		},
		
		showCriticalConfirmWarning: function()
		{
			alert(DR.Widgets.Prompt.INCORRECT_VALUE);
			this.textInput.focus();
			this.textInput.select();
		},
		
		cancel: function()
		{
			this.overlay.cancel();
			if(typeof(this.callback)=='function')
			{
				if(this.isPrompt || this.isCheckboxPrompt)
				{
					this.callback(null);
				}else{
					this.callback(false);
				}
			}
		}
	};
	
	DR.Widgets.CheckboxPrompt = function() {
		this._type = 'CheckboxPrompt';
	}
	DR.Widgets.CheckboxPrompt.prototype = new DR.Widgets.Prompt();
	
	DR.Widgets.Confirm = function(){
		this._type = 'Confirm';
	};
	DR.Widgets.Confirm.prototype = new DR.Widgets.Prompt();
		
	DR.Widgets.Warning = function(){
		this._type = 'Warning';
	};
	DR.Widgets.Warning.prototype = new DR.Widgets.Prompt();
	
	DR.Widgets.Alert = function(){
		this._type = 'Alert';
	};
	DR.Widgets.Alert.prototype = new DR.Widgets.Prompt();
	
	DR.Widgets.Success = function(){
		this._type = 'Success';
	};
	DR.Widgets.Success.prototype = new DR.Widgets.Prompt();
	
	DR.Widgets.CriticalConfirm = function(){
		this._type = 'Critical_Confirm';
	};
	DR.Widgets.CriticalConfirm.prototype = new DR.Widgets.Prompt();
	
})(jQuery);
;(function($) {

	/******************************************************************************
	 * Utility function that displays a message to user
	 * Example: <code>DR.Utils.alert()</code>
	 * @return {Boolean} Boolean
	 *****************************************************************************/
	DR.Utils.alert = function(question,callback,title)
	{
		if(!DR.Utils.ALERT)
		{
			DR.Utils.ALERT = new DR.Widgets.Alert();
			DR.Utils.ALERT.init();
		}
		DR.Utils.ALERT.open(question,null,callback,title);
	};

	DR.Utils.ALERT = null;
	
	/******************************************************************************
	 * Utility function that displays a success message to user
	 * Example: <code>DR.Utils.success()</code>
	 * @return {Boolean} Boolean
	 *****************************************************************************/
	DR.Utils.success = function(question,callback,title)
	{
		if(!DR.Utils.SUCCESS)
		{
			DR.Utils.SUCCESS = new DR.Widgets.Success();
			DR.Utils.SUCCESS.init();
		}
		DR.Utils.SUCCESS.open(question,null,callback,title);
	};

	DR.Utils.SUCCESS = null;
	
	/******************************************************************************
	 * Utility function that displays a custom modal confirm that returns true/false 
	 * Example: <code>DR.Utils.confirm()</code>
	 * @return {Boolean} Boolean
	 *****************************************************************************/
	DR.Utils.warning = function(question,callback,title)
	{
		if(!DR.Utils.WARNING)
		{
			DR.Utils.WARNING = new DR.Widgets.Warning();
			DR.Utils.WARNING.init();
		}
		DR.Utils.WARNING.open(question,null,callback,title);
	};

	DR.Utils.WARNING = null;
	
	
	/******************************************************************************
	 * Utility function that displays a custom modal confirm that returns true/false 
	 * Example: <code>DR.Utils.confirm()</code>
	 * @return {Boolean} Boolean
	 *****************************************************************************/
	DR.Utils.confirm = function(question,callback,title)
	{
		if(!DR.Utils.CONFIRM)
		{
			DR.Utils.CONFIRM = new DR.Widgets.Confirm();
			DR.Utils.CONFIRM.init();
		}
		DR.Utils.CONFIRM.open(question,null,callback,title);
	};

	DR.Utils.CONFIRM = null;

	/******************************************************************************
	 * Utility function that displays a javascript prompt that returns true/false
	 * Example: <code>DR.Utils.prompt()</code>
	 * @return {Boolean} Boolean
	 *****************************************************************************/
	DR.Utils.prompt = function(question,text,callback,title)
	{
		if(!DR.Utils.PROMPT)
		{
			DR.Utils.PROMPT = new DR.Widgets.Prompt();
			DR.Utils.PROMPT.init();
		}
		
		DR.Utils.PROMPT.open(question,text,callback,title);
	};
	
	DR.Utils.PROMPT = null;

	DR.Utils.checkboxPrompt = function(text, promptText, callback, title, buttonText, timer)
	{
		if(!DR.Utils.CHECKBOXPROMPT)
		{
			DR.Utils.CHECKBOXPROMPT = new DR.Widgets.CheckboxPrompt();
			DR.Utils.CHECKBOXPROMPT.init();
		}
		
		DR.Utils.CHECKBOXPROMPT.open(text, promptText, callback, title, null, buttonText, timer);
	};
	
	DR.Utils.PROMPT = null;	
	/******************************************************************************
	 * Utility function that displays a javascript prompt that requires the user
	 * to enter a string that matches a key passed in.
	 * 
	 * This can be used to make sure the user is aware that the action they are
	 * about to take can be destructive with no Undo possible.
	 * 
	 * Example: <code>DR.Utils.criticalConfirm()</code>
	 * @return {Boolean} Boolean
	 *****************************************************************************/
	
	// @TODO dpease - remove text as an argument in this function
	DR.Utils.criticalConfirm = function(question,text,callback,title,acceptKey, acceptQuestion)
	{
		if(!DR.Utils.CRITICAL_CONFIRM)
		{
			DR.Utils.CRITICAL_CONFIRM = new DR.Widgets.CriticalConfirm();
			DR.Utils.CRITICAL_CONFIRM.init();
		}
		
		DR.Utils.CRITICAL_CONFIRM.open(question,text,callback,title,acceptKey, null, null, acceptQuestion);
	};
	
	DR.Utils.CRITICAL_CONFIRM = null;
	
	/*
	 * jQuery API to modal overlay
	 */
	
	var defaults = {
		title: null,
		callback: null
	};
	var CHECKBOX_PROMPT;
	
	var _extend = function(options){
		options = (options) ? options : {};
		return $.extend({},defaults, options);
	}
	
	$.dr.alert = function(text,options){
		options = _extend(options);
		DR.Utils.alert(text,options.callback,options.title);
	};
		
	$.dr.success = function(text, options){
		options = _extend(options);
		DR.Utils.success(text,options.callback,options.title);
	};

	$.dr.warning = function(text, callback, options){
		options = _extend(options);
		DR.Utils.warning(text,callback,options.title);
	}

	$.dr.confirm = function(text, callback, options){
		options = _extend(options);
		DR.Utils.confirm(text,callback,options.title);
	};
	
	$.dr.checkboxPrompt = function(text, promptText, callback, options){
		options = _extend(options);
		DR.Utils.checkboxPrompt(text, promptText, callback, options.title, options.buttonText, options.timer);
	}; 
	
	$.dr.prompt = function(text, promptText, callback, options){
		options = _extend(options);
		DR.Utils.prompt(text,promptText,callback,options.title);
	};
	
	$.dr.criticalConfirm = function(text, promptText, callback, acceptKey, options){
		options = _extend(options);
		DR.Utils.criticalConfirm(text,promptText,callback,options.title, acceptKey, options.acceptQuestion);
	};

	
})(jQuery);

;(function($) {
	/******************************************************************************
	 * DR.Widgets.ModelessOverlay(id,url)
	 *
	 * The modeless overlay is a in-page emulation of a popup window.
	 * The overlay is built dynamically and is attached to the page via DOM
	 *
	 * The modeless overlay differs from the modal overlay, in that more than one
	 * can be open on the page at a time, requiring a behind the scenes object
	 * that keeps track of the stacking order (z-index)
	 *
	 * Another difference is that the masking layer is not shown for a modeless
	 * overlay, so the user can still interact with the other elements on the screen
	 *
	 * Steps to create a  Modeless Overlay:
	 * 1) Create an instance of a DR.Widgets.ModalOverlay	EXAMPLE:  var FilePicker = new DR.Widgets.ModelessOverlay('FilePicker',"http://www.yahoo.com/");
	 *
	 * 2) Set any opional fields, such as cssSize, title
	 *
	 * 3) Call the ".show()" function
	 *
	 * 4) Call this function from a button or anchor link
	 *
	 * @param id = The id given to the container DIV, should be the same as the name of the object
	 * @param url = The url of the page that will be loaded in the iframe
	 *
	 * Internal Properties:
	 *
	 * title 			==> Emulates the page title shown in popup windows - NOT REQUIRED
	 * built			==> Initially set to false, once the overlay layer has been attached to the DOM, flagged to true
	 * maskBuilt		==> Initially set to false, once the masking layer has been attached to the DOM, flagged to true
	 * loading			==> Flag set to true when the url is passed to the Iframe, once the iframe is loaded, flagged to false
	 * cancelFunction 	==> If a cancel button is placed in the page loaded into the iframe, and the user wished to initiate a callBack
	 *                      function on the original page, this function runs.
	 * ModalType		==> By default it is "Modeless", but can be set to "Modal", which will add a visible masking layer
	 * titleBarHeight	==> Height of the title bar area
	 * borderWidth		==> Width of the border
	 * shadowRight		==> Width of the right drop shadow
	 * shadowBottom		==> Height of the bottom drop shadow
	 * contentWidth		==> Width of the iframe that holds the content
	 * contentHeight	==> Height of the iframe that holds the content
	 * width			==> Width of the container DIV
	 * height			==> Height of the container DIV
	 * dragObject 		==> Reference to DR.Utils.DragObject Class
	 *
	 *****************************************************************************/


	DR.Widgets.ModelessOverlay = function (id,url,optionalClassName)
	{
		this.id = id;
		this.parentId = -1;
		this.parentWindowIndex=-1;
		this.url = url;
		this.stackID = "";
		this.title = "&nbsp;";
		this.built=false;
		this.isOpen=false;
		this.hasFocus=false;
		this.hasChildren=false;
		this.hasModalChildren=false;
		this.blurWindow=false;
		this.isInStack=false;
		this.modalMaskBuilt=false;
		this.modelessMaskBuilt=false;
		this.loading = false;
		this.cancelFunction = "";
		this.callBackFunction = "";
		this.abortFunction = "";
		this.modalType="Modeless";
		this.inline = false;
		this.titleBarHeight = 28;
		this.borderWidth = 2;
		this.inlineDialogPadding = 10;
		this.shadowRight = 36;
		this.shadowBottom = 36;
		this.contentWidth = 580;
		this.contentHeight = 520;
		this.waitToLoadIframe=true;
		this.ieTimeout=false;
		this.Dragging=true;
		this.dragObject=null;
		this.autoCenter=true;
		this.scrollBarsHidden=false;
		this.width = this.contentWidth+this.shadowRight+(this.borderWidth*2);
		this.height = this.contentHeight+this.shadowBottom+this.titleBarHeight+(this.borderWidth*2);
		this.optionalClassName = (optionalClassName) ? optionalClassName : null;
		this.showMaximize = false;
		this.startMaximized = false;
	};

	DR.Widgets.ModelessOverlay.prototype ={
		
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.show()
		 *
		 * This function first sees if the mask layer is built, if not, it calls the
		 * self referencing function, this.buildMask()
		 *
		 * Second, it looks to see if the dialog has been built yet, if not it calls the
		 * self referencing function, this.build()
		 *
		 * Next, we check the current size of the window/document, and get an object
		 * passed back with those values. Sometimes IE doesn't reset the width of the mask
		 * so we force an update inside an IE specific conditional. The mask is resized
		 * to be the same height and width as the document.
		 *
		 * Next, we size the dialog window according to the CSS class set for it. We
		 * also center the window vertically and horizontally and scroll into view
		 *
		 * We then load the iframe with the URL set for the object, a loading layer
		 * is set to be visible until the page loads in the iframe, which triggers
		 * the hideloading function that shows the iframe content and hides the loading
		 * animated gif
		 *
		 * @return VOID
		 *****************************************************************************/

		show: function ()
		{
			this.checkBrowser();
	
			if(window!=top && !this.inline)
			{
					this.addToStack();
					parent.overlayStack.addChildWindow(this, overlayStack.currentWindow);
			}
			else
			{
		
				if (!this.built)
				{
					this.addToStack();
					this.build();
				}
	
				if (!this.modalMaskBuilt)
				{
					this.buildModalMask();
				}
	
				if(this.modalType=="Modal")
				{
					this.modalMask.style.display = 'block';
					this.modalMaskIEOver.style.display = 'block';
					this.modalMask.className = "modalOverlayMask";
				}
				
				if(this.modalType=="Modeless")
				{
					this.modalMask.className = "modelessOverlayMask";
				}
				
				this.isOpen=true;
				this.position();
				var func = function(){
					overlayStack.getCurrent().center(false);	
				};
				window.setTimeout(func,10);
				this.focus();
				this.refreshMaskSize();
				this.refreshSize();
				this.dialog.style.display = 'block';
				this.showLoading();
				this.hideDocScrollBars();
				this.center();
				if (!this.inline)
				{
	
					if(this.waitToLoadIframe)
					{
						// IE has a problem where it won't show the modal until after the call to load the url is made.
						// The solution is to force IE to show the modal overlay first, wait 50 milliseconds,
						// and then load the url
	
						var ieFunc = function (){ overlayStack.buildIframe(); };
							window.setTimeout(ieFunc,50);
							this.ieTimeout = true;
					}
					else
					{
						this.buildIframe();
					}
					
					if(this.modalType=="Modal")
					{
						this.addEvent( document, 'keypress', DR.Utils.suppressKeypress, 1 );
					}
				}
			}
		},
		
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.position()
		 *
		 * When the user resizes the window, or has shown a dialog, we refresh the
		 * size of the masking layer
		 *
		 * @return VOID
		 *****************************************************************************/
		position: function ()
		{
			if (this.anchorId) {
			// If an anchorId coordinate is given, position with those
				this.setPositionTo();	
			} else {
			// otherwise center
				this.center();
			}
		},
		
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setPositionTo()
		 *
		 * When the user resizes the window, or has shown a dialog, we refresh the
		 * size of the masking layer
		 *
		 * @return VOID
		 *****************************************************************************/
		setPositionTo: function ()
		{
			var overlayPos = new DR.Utils.Position(this.dialog);
			this.dialog.style.position = 'absolute';
			overlayPos.setRelativePosition(this.anchorId, DR.Utils.Position.ON_LEFT, DR.Utils.Position.DRAW_RIGHT, DR.Utils.Position.ON_TOP, DR.Utils.Position.DRAW_DOWN, (0-this.shadowRight/2), 0, false);
	
			//v ar buttonPos = new Position(this.anchorId);
			//v ar top = buttonPos.top;
			//v ar left = buttonPos.left;
		    //this.dialog.style.left = left + "px";
			//this.dialog.style.top = top + "px";
		},
		
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.center()
		 *
		 * When the user resizes the window, or has shown a dialog, we refresh the
		 * size of the masking layer
		 *
		 * @return VOID
		 *****************************************************************************/
		center: function (modalCallback)
		{
			if(!this.anchorId){
				var w = this.width;
				var h = this.height;
		
				// Get current window height and width
			   overlayStack.getPageSize();
		
				var x,y;
				var scrollBarWidth = 0;
				var ieXOffset = 0;
				var ieYOffset = 0;
				var isIE6 = $.browser.msie6;
				if (document.documentElement) {
					if(isIE6)
					{	
						// In IE 6 we cannot use position:fixed, so we hide the scrollbars
						// need to account for that in the math
						if($('body.modalPage').length==0 && !modalCallback){
							scrollBarWidth = 18;
							ieXOffset = 1;
							ieYOffset = 9;
						}
						x = document.documentElement.scrollLeft + document.body.scrollLeft;
						y = document.documentElement.scrollTop + document.body.scrollTop;
					}
				}
				
				if(this.autoCenter || (!this.autoCenter && !modalCallback) )
				{
					// Center the dialog based on the width and height
					if(isIE6){
					    this.dialog.style.left = (x+(overlayStack.doc.windowWidth/2)-( (w-scrollBarWidth)/2  + ieXOffset )) + "px";
						this.dialog.style.top = (y+(overlayStack.doc.windowHeight/2)-( (h-scrollBarWidth)/2  + ieYOffset)) + "px";
					}else{
					    this.dialog.style.left = Math.round(overlayStack.doc.windowWidth/2 - w/2) + "px";
						this.dialog.style.top = Math.round(overlayStack.doc.windowHeight/2 - h/2) + "px";
					}

				}
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.refreshMaskSize()
		 *
		 * When the user resizes the window, or has shown a dialog, we refresh the
		 * size of the masking layer
		 *
		 * @return VOID
		 *****************************************************************************/
		refreshMaskSize: function ()
		{
			overlayStack.refreshMaskSize();
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.addToStack()
		 *
		 * When the dialog is built, it is added to the global dialog stack. When the
		 * dialog has been added, we add the stackID field, so we can then reference
		 * the dialog from the stack.
		 *
		 * @return VOID
		 *****************************************************************************/
		addToStack: function ()
		{
		    if (!this.isInStack)
		    {
		    	this.stackId = overlayStack.add(this);
		    	this.isInStack = true;
		    }
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.checkBrowser()
		 *
		 * This function checks the browser type
		 *
		 * @return VOID
		 *****************************************************************************/
		checkBrowser: function ()
		{
			if(document.all)
			{
				this.browserType = 'IE';
				this.filtersSupported = true;
				this.iframeTransparency = true;
				this.waitToLoadIframe = true;
			}
			else
			{
				this.broswerType = 'Standard';
				this.filtersSupported = false;
				this.iframeTransparency = false;
				this.waitToLoadIframe = false;
			}
			this.isIE7 = (navigator.appVersion.indexOf("MSIE 7") > -1);
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.focus()
		 *
		 * This function gets a new z-index from the global stack, and is thus raised
		 * above any other dialogs on the page.  To prevent the mouse from losing focus
		 * when dragged over another dialogs iframe, we raise the transparent modeless
		 * mask above all the other dialogs, but below the current dialog.
		 *
		 * If there is a parent window, it means we are in a modal dialog, and we
		 * want to set that windows modal dialog to inactive
		 *
		 * @return VOID
		 *****************************************************************************/
		focus: function ()
		{
			// The if statement would only fail if we are inside a modal overlay iframe
	
			if (overlayStack.checkAnyOpen() && this.isOpen)
			{
				if(!this.hasChildren && !this.hasModalChildren)
				{
					overlayStack.bringToFront(this.stackId);
				}
				else if (this.hasChildren)
				{
					window.frames[this.iframe.id].overlayStack.focusCurrent(false);
				}
	
				if(window!=top)
				{
					parent.overlayStack.setCurrentHasChildren(true);
					parent.overlayStack.blurCurrent();
				}
	
				overlayStack.blurOtherWindows();
	
			}
			else
			{
				// We are inside an overlay, so we focus the parent
				// this would only happen if we just closed an inline overlay
				// inside a modal overlay
	
				if(window!=top)
				{
					parent.overlayStack.focusCurrent(true);
				}
			}
	
			this.hasFocus=true;
			this.isBlurred=false;
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.blur()
		 *
		 * Sets the class to be inactive status
		 *
		 * @return VOID
		 *****************************************************************************/
		blur: function ()
		{
	
			//if (this.titleBar.className!="titleBarInActive")
			//{
				//this.titleBar.className="titleBarInActive";
			//}
			
			DR.Utils.addCSSClass(this.contentTable,"inActive");
	
			if(this.hasChildren && this.blurWindow)
			{
				this.blurWindow=false;
				window.frames[this.iframe.id].overlayStack.blurCurrent();
			}
			this.isBlurred=true;
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.cancel()
		 *
		 * If a cancel button is placed in the page loaded into the iframe, and the
		 * user wished to initiate a callBack function on the original page when the
		 * button is clicked, this function runs that function
		 *
		 * @return VOID
		 *****************************************************************************/
		cancel: function ()
		{
	
			if (typeof this.cancelFunction == 'function')
			{
				this.cancelFunction();
			}
		    this.close();
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setCancelFunction (func)
		 *
		 * @param func ==> Variable of type FUNCTION
		 *
		 * @return VOID
		 *****************************************************************************/
		setCancelFunction: function (func)
		{
		   if (typeof func == 'function')
			{
		    	this.cancelFunction = func;
		    }
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setCallBackFunction (func)
		 *
		 * @param func ==> Variable of type FUNCTION
		 *
		 * @return VOID
		 *****************************************************************************/
		setCallBackFunction: function (func)
		{
			if (typeof func == 'function')
			{
				this.callBackFunction = func;
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setAbortFunction (func)
		 *
		 * @param func ==> Variable of type FUNCTION
		 *
		 * @return VOID
		 *****************************************************************************/
		setAbortFunction: function (func)
		{
			if (typeof func == 'function' || func === null)
			{
				this.abortFunction = func;
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.callBack()
		 *
		 * Called usually from inside an iframe when we want to return some data to
		 * the parent window and also so some action on the page.
		 *
		 * @return VOID
		 *****************************************************************************/
		callBack: function (arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)
		{
		   if (typeof this.callBackFunction == 'function')
			{
		    	this.callBackFunction(arg1,arg2,arg3,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
		    }
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.close()
		 *
		 * This function hides the masking layer and the dialog
		 *
		 * @return VOID
		 *****************************************************************************/
		close: function ()
		{
			if (typeof this.abortFunction == 'function')
			{
				this.abortFunction();
			}
			else
			{
				this.isOpen = false;
				this.hasFocus = false;
				this.dialog.style.display = 'none';
				overlayStack.setCurrentWindow(this.stackId);
	
				if (!overlayStack.checkAnyModalOpen())
				{
					if (this.modalType=="Modal")
					{
						this.modalMask.style.display = 'none';
						this.modalMaskIEOver.style.display = 'none';
						this.ScrollBars();
					}
				}
	
				if (!overlayStack.checkAnyModelessOpen() || !overlayStack.checkAnyModelessOpen() )
				{
					if(window!=top)
					{
						parent.overlayStack.setCurrentHasChildren(false);
						parent.overlayStack.focusCurrent(true);
					}
				}
				if (!this.inline)
				{
					if (this.parentId>-1 && this.parentWindowIndex>-1)
					{
						window.frames[overlayStack.windows[this.parentId].iframe.id].overlayStack.destroyWindow(this.parentWindowIndex);
					}
					overlayStack.setCurrentHasModalChildren(false);
					overlayStack.destroyCurrent();
					if(this.modalType=="Modal")
					{
						this.removeEvent( document, 'keypress', DR.Utils.suppressKeypress, 1);
					}
				}else{
					overlayStack.bringOpenOverlayToFront();
				}
			}
		},
		
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.hideDocScrollBars()
		 *
		 * Makes the body scrollbars hidden when opening a modal modal overlay
		 *
		 * @return VOID
		 *****************************************************************************/
		hideDocScrollBars: function ()
		{
	
			/*
		 	
		 	// this code below is an attempt to cancel the scrolling,
			// but it doesn't work currently
		 
			var func = function(evt){
				if(window.event)
				{
					window.event.cancelBubble=true;
				}else
				{
					evt.preventDefault();
					evt.stopPropagation();
				}
				return false;
			}
			if (document.attachEvent) {
				document.attachEvent("onscroll", func );
			}else{
				document.addEventListener("scroll", func,	false);
			}
			*/
			if(this.modalType=="Modal")
			{
				if(this.browserType=="IE" && parseInt($.browser.version, 10) < 7)
				{
					var a = document.getElementsByTagName('html')[0];
						a.style.overflow='hidden';
						this.scrollBarsHidden = true;
				}else{
					//document.body.style.overflow='hidden';
				}
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.ScrollBars()
		 *
		 * Makes the body scrollbars visible when closing the last open modal overlay
		 *
		 * @return VOID
		 *****************************************************************************/
		ScrollBars: function ()
		{
			if(!overlayStack.checkAnyModalOpen() && this.modalType=="Modal")
			{
				if(this.browserType=="IE")
				{
					var a = document.getElementsByTagName('html')[0];
						a.style.overflow='auto';
						this.scrollBarsHidden = false;
				}else{
					//document.body.style.overflow='auto';
				}
			}
		},
						
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.hideLoading()
		 *
		 * Shows the iframe content and hides the loading layer when the iframe has
		 * loaded. This function runs automatically EVERY time a page is loaded in the
		 * iframe. There is no need to add any code into the iframe html
		 *
		 * @return VOID
		 *****************************************************************************/
		hideLoading: function ()
		{
			if (!this.inline && !this.ieTimeout && this.iframeSpacer)
			{
				// Hide the current modal dialog
			    this.iframeSpacer.style.display='none';
			    this.iframe.style.display='block';
			    this.iframe.style.visibility='visible';
			    this.loading=false;
			    // We assume that since the page just loaded, that there are no modal
			    // dialogs open inside this modal dialog.
			   	overlayStack.setCurrentHasChildren(false);
		    }
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.showLoading()
		 *
		 * Hides the iframe and shows the animated loading gif
		 *
		 * @return VOID
		 *****************************************************************************/
		showLoading: function ()
		{
			if (!this.inline)
			{
	
				// Hide the current modal dialog
				//this.iframeSpacer.style.visibility='visible';
			    this.iframeSpacer.style.display='block';
				if(this.iframe)
				{
			    	this.iframe.style.display='none';
				    this.iframe.style.visibility='hidden';
				}
			    this.loading=true;
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.buildModalMask()
		 *
		 * This function adds a DIV to the DOM, that when activated, adds a masking
		 * layer behind the modal overlay.  The layer is set to semi-transparent, so
		 * the page content can still be seen, but all events are eaten by the layer
		 * No user clicks or selections can occur while the mask is visible
	
		 * For IE, we have to add an Iframe inside of the DIV, to hide the Selects
		 * which otherwise bleed through DIVs. IE7 has fixed this, but until that browser
		 * is the only supported IE browser, this code must remain.
		 *
		 * @return VOID
		 *****************************************************************************/
		buildModalMask: function ()
		{
			if (document.getElementById('modalMask') === null)
			{
				var d = document.createElement("div");
					d.id = "modalMask";
					d.className = "modalOverlayMask";
	
				var f = document.createElement("IFRAME");
					f.className = "modalOverlayMaskIframe";
					f.id = "modalOverlayMaskIframe";
					f.src = $.dr.BLANK_PAGE_URL;
					d.appendChild(f);
	
				var dd = document.createElement("div");
					dd.className = "modalOverlayMaskDiv";
					dd.id = "modalOverlayMaskDiv";
	
				this.modalMaskIframe = f;
				this.modalMaskIEOver = DR.Utils.addToBody(dd);
				this.modalMask = DR.Utils.addToBody(d);
	
				// Free up the memory
				f=null;
				dd=null;
				d=null;
			}
			else
			{
				this.modalMask = document.getElementById('modalMask');
				this.modalMaskIframe = document.getElementById('modalOverlayMaskIframe');
				this.modalMaskIEOver = document.getElementById('modalOverlayMaskDiv');
			}
			this.modalMaskBuilt = true;
			
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.buildModelessMask()
		 *
		 * This function adds a DIV to the DOM, that when activated, adds a masking
		 * layer behind the modeless overlay.  The layer is set to fully-transparent, so
		 * the page content can still be seen, but all events are eaten by the layer
		 * No user clicks or selections can occur while the mask is visible.
		 *
		 * @return VOID
		 *****************************************************************************/
		buildModelessMask: function ()
		{
			if (!document.body.modelessMask)
			{
	
				var d = document.createElement("div");
					d.id = "modelessMask";
					d.className = "modelessOverlayMask";
	
				this.modelessMask = DR.Utils.addToBody(d);
	
				// free up the memory
				d=null;
			}
			this.modelessMaskBuilt = true;
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.build()
		 *
		 * This function builds the Modal Dialog part of the overlay, and attaches it
		 * to the DOM.
		 *
		 * The structure and behavior is defined in this function, css class names
		 * control the look of the interface.
		 *
		 * The table is used to show the shadow png's on the right and bottom of the
		 * dialog.
		 *
		 * The Iframe is hidden at first, until its url loads. We attach an onmousedown
		 * method to the title bar, so the user can drag the window around the page
		 *
		 * The dialog, iframe, spacer, and loading elements are joined to the Modal
		 * object, for referencing by other methods
		 *
		 * @return VOID
		 *****************************************************************************/
		build: function ()
		{

			// We attach the masking layer to the body
			var bodyObj = document.getElementsByTagName("BODY")[0];
	
			var dialogDiv = document.createElement("div");
				dialogDiv.id = "modal_"+this.id;
				dialogDiv.className = 'modalOverlay';
	
			var myDialog = this;
			var ie6=false;
			var tblRowSpan = ' colspan="2"  rowspan="2"';
			
			if($.browser.msie && parseInt($.browser.version, 10) < 7){
				ie6=true;
				tblRowSpan = '';
				this.shadowRight = 8;
				this.shadowBottom = 8;
			}
			
			var s = [];
			var optionalCSS = "";
			if(this.optionalClassName!=null){
				optionalCSS = 'class="'+this.optionalClassName+'"';
			}
			var closeButtonStyle="";
			if(this.disabled){
				closeButtonStyle = 'style="display:none"';
			}
			if(this.modalType=="Modeless"){
				s[s.length] = '<div class="modalWrapper" id="{0}_modalWrapper">';
				s[s.length] = 	'<div class="divFloat" id="{0}_divFloat">';
			}
			
			s[s.length] = '<div id="{0}_contentTable" '+optionalCSS+' >';
			s[s.length] = 	'<table border="0" cellpadding="0" cellspacing="0" class="wrapperTbl">';
			
			if(!ie6){
				s[s.length] = 		'<tr><td colspan="2" class="topLeft">&nbsp;</td><td colspan="2" class="topRight">&nbsp;</td></tr>';
				s[s.length] = 		'<tr><td class="leftTop">&nbsp;</td>';
			}else{
				s[s.length] = 		'<tr>';
			}

			s[s.length] = 			'<td '+tblRowSpan+' id="{0}_content" >';
			s[s.length] = 				'<div class="inner" id="{0}_inner" >';
			
			/*  Overlay Title Bar */
			s[s.length] = 					'<table border="0" cellpadding="0" cellspacing="0" class="titleBar" id="{0}_titleTbl">';
			s[s.length] = 						'<tr>';
			s[s.length] =							'<td class="title" ><div id="{0}_title">'+this.title+'</div></td>';
			
			if (this.showMaximize) {
				s[s.length] = '<td class="maximize" title="'+DR.Widgets.ModalOverlay.MAXIMIZE+'"><a href="#" style="display:block;" onmousedown="if (window.event){window.event.cancelBubble = true;}else{event.preventDefault();event.stopPropagation();}" id="{0}_maximize" ></a></td>';
			}
			
			s[s.length] = 							'<td class="close" '+closeButtonStyle+' title="'+DR.Widgets.ModalOverlay.CLOSE_WINDOW+'"><a href="#" onmousedown="if (window.event){window.event.cancelBubble = true;}else{event.preventDefault();event.stopPropagation();}" id="{0}_closeLink" ></a></td>';
			s[s.length] =						'</tr>';
			s[s.length] = 					'</table>';


			if (!this.inline)
			{
				/* Loading div, for Iframe overlays */
				s[s.length] = 				'<div id="{0}_iframeSpacer" >';
				s[s.length] = 					'<div class="modalLoading" id="{0}_loadingDiv" >';
				s[s.length] = 						'<div class="modalLoadingTextWrapper" id="{0}_loadingTextWrapper" >';
				s[s.length] = 							'<div class="modalLoadingText">'+DR.Widgets.ModalOverlay.LOADING_WINDOW+'</div>';
				s[s.length] = 							'<div class="modalLoadingImg"></div>';
				s[s.length] = 						'</div>';
				s[s.length] = 					'</div>';
				s[s.length] = 				'</div>';
			}
			
			s[s.length] = 				'</div>';
			s[s.length] = 			'</td>';
			s[s.length] = 			'<td class="rightTop">&nbsp;</td></tr>';
			
			if(!ie6){
				s[s.length] = 	'<tr><td class="leftBottom">&nbsp;</td><td class="rightBottom">&nbsp;</td></tr>';
				s[s.length] = 	'<tr><td colspan="2" class="bottomLeft">&nbsp;</td><td colspan="2" class="bottomRight">&nbsp;</td></tr>';
			}else{
				s[s.length] = 	'<tr><td class="bottomLeft">&nbsp;</td><td class="bottomRight">&nbsp;</td></tr>';
			}
			

			s[s.length] = '</table>';
			s[s.length] = '</div>';	
			
			if(this.modalType=="Modeless"){
				s[s.length] = 	'</div>'; // end modalWrapper
				s[s.length] = 	'<iframe  src="'+ $.dr.BLANK_PAGE_URL+'" class="modelessOverlayMaskIframe" id="{0}_modelessOverlayMaskIframe" ></iframe>';
				s[s.length] = '</div>'; // end divFloat
			}
			
			/* Turn the buffer back into a string */
			s = s.join("");
			s = s.replace(/\{0\}/g,this.id);

			dialogDiv.innerHTML = s;

			if (this.inline)
			{
				// Attach the dialog to the page, and move it next to where the source DIV is at.
				// Then move the source div inside the overlay.
				
				var sourceDiv = document.getElementById(this.inlineId);
				sourceDiv.style.display='block';
				dParent = sourceDiv.parentNode;
				this.dialog =  dParent.insertBefore(dialogDiv,sourceDiv);
				var dialogClone = document.createElement("div");
				dialogClone.className = "inlineDialog";
				getElem(this.id+'_inner').appendChild(dialogClone);
				this.dialogClone = dialogClone;
				dialogClone.appendChild(sourceDiv);
			}else
			{
				// Setup reference to html ojbects just created.
				this.dialog = bodyObj.appendChild(dialogDiv);
				this.iframeWrapper = getElem(this.id+'_inner');
				this.iframeSpacer = getElem(this.id+'_iframeSpacer');
				this.loadingDiv = getElem(this.id+'_loadingDiv');
				this.loadingTextWrapper = getElem(this.id+'_loadingTextWrapper');
			}
			
			if(this.modalType=="Modeless"){
				// These prevent selects from bleeding through the DIV
				this.modelessMaskingDiv = getElem(this.id+'_divFloat');
				this.modelessMaskingIframe = getElem(this.id+'_modelessOverlayMaskIframe');
			}
			
			this.windowIcon = getElem(this.id+'_title');
			this.contentTable = getElem(this.id+'_contentTable');
			this.closeLink = getElem(this.id+'_closeLink');
			
			var oThis = this;		
			
			getElem(this.id+'_closeLink').onclick = function(){
				if (oThis.inline && oThis.showMaximize && oThis.isMaximized && !oThis.startMaximized) {
					//need to know the toggle state here and only click if its maximized
					$("#" + oThis.id + '_maximize').click();//manual click to set the toggle state			
				}
				myDialog.cancel();
				return false;
			};
			$(getElem(this.id)).find("button.cancel").bind("click",function(){
				if (oThis.inline && oThis.showMaximize && oThis.isMaximized && !oThis.startMaximized) {
					//need to know the toggle state here and only click if its maximized
					$("#" + oThis.id + '_maximize').click();//manual click to set the toggle state			
				}			
			});
			oThis.isMaximized = false;
			//Bind maximize/minimize button
			if (this.showMaximize || this.startMaximized) {
				var resize = function(windowWidth, windowHeight) {
					//compensate for scrollbar width
					if ($(window).height() < document.body.scrollHeight) {
						var scrollBarWidth =$("#modal_"+oThis.id).data("scrollBarWidth") || 17;
						if (oThis.inline && oThis.modalType == "Modeless") {
							windowWidth = windowWidth - oThis.shadowRight - (oThis.borderWidth*2) - scrollBarWidth - 2; //default to 17px
						}
						if (oThis.iframe) {							
							windowWidth = windowWidth - oThis.shadowRight - (oThis.borderWidth*2) - 2;
						}
					}
					
					oThis.setSize(windowWidth, windowHeight);
					if (oThis.showMaximize && oThis.inline) {
						$("#"+oThis.id+'_inner').css("height", (windowHeight - oThis.shadowBottom - (oThis.borderWidth*2))+"px");
					}
					
					oThis.refreshSize();
					if (oThis.inline && oThis.showMaximize) {	//needs to be set here because refreshSize sets width as well	
						$("#modal_"+oThis.id).css("width",parseInt(windowWidth,10)+"px");
					}
					
				}
				var dialogElement = dialogDiv;
				var $maximizeButton = $("#" + this.id + '_maximize');
				$maximizeButton.data("clickState",0).bind("click", function(){
					var $this = $(this);
					if ($this.data("clickState") === 0) {
						$this.data("clickState", 1);
						var windowWidth = $(window).width();
						var windowHeight = $(window).height();
						var $dialogElement = $(dialogElement);
						$dialogElement.data({"originalHeight":oThis.contentHeight,"originalWidth": oThis.contentWidth,"originalLeft": $dialogElement.css("left"),"originalTop": $dialogElement.css("top")});
						$dialogElement.css({"left": "0px","top": "0px"});

						resize(windowWidth,windowHeight);
						oThis.isMaximized = true;
						$("#modal_"+oThis.id).find("td.maximize").removeClass("maximize").addClass("minimize").find("a").attr("title",DR.Widgets.ModalOverlay.MINIMIZE);
						$("#"+oThis.id).trigger("dr-modalMaximize");
						return false;
					} else {
						$this.data("clickState", 0);
						var $dialogElement = $(dialogElement);
						$("#modal_"+oThis.id).find("td.minimize").removeClass("minimize").addClass("maximize").find("a").attr("title",DR.Widgets.ModalOverlay.MAXIMIZE);
						oThis.isMaximized = false;
						$("#"+oThis.id+'_inner').css("height","");
						$("#modal_"+oThis.id).css("width","");
						oThis.setSize($dialogElement.data("originalWidth") - ( (oThis.inline) ? oThis.inlineDialogPadding*2 : 0 ), $dialogElement.data("originalHeight"))
						oThis.refreshSize();
						$dialogElement.css({"left":$dialogElement.data("originalLeft"), "top":$dialogElement.data("originalTop") });
						$("#"+oThis.id).trigger("dr-modalMinimize");
						return false;
					}
				});
				
				$(window).resize(function(){
					if (oThis.isMaximized) {
						resize($(window).width(),$(window).height());
					}					
				});
				if (this.startMaximized === true && $maximizeButton.data("clickState") === 0) {
					setTimeout(function(){
						$maximizeButton.trigger("click");
					},0);
				}
			}
			
			if ($(window).height() < document.body.scrollHeight && $("#modal_"+this.id).data("scrollBarWidth") == undefined) {
				//get width of scrollbar
				var $body = $('body');
				var w = $body.css('overflow', 'hidden').width();
				$body.css('overflow','scroll');
				w -= $body.width();
				if (!w) {
					w = $body.width() - $body[0].clientWidth;// IE in standards mode
				} 
				$body.css('overflow','');	
				$("#modal_"+this.id).data("scrollBarWidth", w);
			}

			function myDialogInitDrag(event){myDialog.initDrag(event);}
			if (this.Dragging){
				getElem(this.id+'_titleTbl').onmousedown=myDialogInitDrag;
			}
				

			overlayStack.addWindowEventHandlers();
			
			function eventMyDialogFocus(event){myDialog.focus();}
			dialogDiv.onclick=eventMyDialogFocus;

			// Free up all the memory from temporary vars used in this function
			s = null;

			function cleanupIE_Events()
			{
				// The following lines prevent a memory leak in Internet Explorer from the closure type of leak
				// We need to detach all the functions that were dynamically assigned to any DOM elements
				dialogDiv.detachEvent("onclick",eventMyDialogFocus);
				overlayStack.destroyAll();
				window.detachEvent("onunload",cleanupIE_Events);
			}
			
			if (this.browserType=="IE"){
				window.attachEvent("onunload",cleanupIE_Events);
			}else{
				// For non IE browsers, we can safely null out these variables,
				// IE needs them non nulled for garbage collection
				dialogDiv = null;
			}
			
			this.built=true;
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.buildIframe()
		 *
		 * Attach a new IFRAME to the dialog and loads the URL
		 *
		 * @return VOID
		 *****************************************************************************/
		buildIframe: function ()
		{
	
			this.iframeCountID = overlayStack.getNewIframeID();
			var newIframe = document.createElement("IFRAME");
				newIframe.id = "modal_iframe_"+this.iframeCountID;
				newIframe.name = "modal_iframe_"+this.iframeCountID;
				newIframe.frameBorder=0;
	
			if (this.iframeTransparency){
				newIframe.allowTransparency=true;
				// Note that in order for the scrollbars to work as expected in IE, add scroll="yes" to the body tag to the page inside the iframe
				// Otherwise a horizontal scrollbar appears due to margin issues
			}
			
			var self = this;
	
			function myDialogHideLoading(){self.hideLoading();}
			function myDialogFocus(){self.focus();}
	
			if (document.attachEvent) {
				newIframe.attachEvent("onload", myDialogHideLoading );
				//newIframe.attachEvent("onfocus",myDialogFocus );
			}else{
				newIframe.addEventListener("load", myDialogHideLoading,	false);
			}
	
			// Add in a random number to prevent browser caching.
			
			
			
			if (this.url.indexOf("modalTime") == -1) {
				var seconds = new Date().getTime();
				if (this.url.indexOf("?") == -1) {
					this.url += '?modalTime='+seconds;
				} else {
					this.url += '&modalTime='+seconds;
				}
			}

			// We need to set the iframe to a page to prevent SSL warnings in IE
			newIframe.src = this.url;
			newIframe.style.display='none';
			
	
			this.iframeWrapper.appendChild(newIframe);
			this.iframe = newIframe;

			function cleanupIE_Events()
			{
				// The following lines prevent a memory leak in Internet Explorer from the closure type of leak
				// We need to detach all the functions that were dynamically assigned to any DOM elements
				if(newIframe)
				{
					newIframe.detachEvent("onload", myDialogHideLoading);
					newIframe.detachEvent("onfocus",myDialogFocus);
				}
				window.detachEvent("onunload",cleanupIE_Events);
			}
						
			if (this.browserType=="IE"){
				window.attachEvent("onunload",cleanupIE_Events);
			}else{
				// For non IE browsers, we can safely null out these variables,
				// IE needs them non nulled for garbage collection
				newIframe = null;
			}

			this.refreshSize();
		},
	
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.refreshSize()
		 *
		 * After the width and height of the content area has been set, we call this
		 * function to refresh the container and iframe sizes
		 *
		 * @return VOID
		 *****************************************************************************/
		refreshSize: function ()
		{
	
			overlayStack.getPageSize();
			
			this.width = this.contentWidth+this.shadowRight+(this.borderWidth*2);
			this.height = this.contentHeight+this.shadowBottom+this.titleBarHeight+(this.borderWidth*2);
	
			if (this.width > overlayStack.doc.windowWidth)
			{
				this.width = overlayStack.doc.windowWidth;
				this.contentWidth = this.width -this.shadowRight - (this.borderWidth*2);
			}
			if (this.height > overlayStack.doc.windowHeight)
			{
				this.height = overlayStack.doc.windowHeight;
				this.contentHeight = this.height - this.shadowBottom - this.titleBarHeight - (this.borderWidth*2);
			}
	
			var w  = this.width+"px";
			var h  = this.height+"px";
			var cw = this.contentWidth+"px";
			var ch = this.contentHeight+"px";
			
			this.dialog.style.width=w;
			this.dialog.style.height=h;
			
			if (!this.inline)
			{
				
				this.iframeSpacer.style.width=cw;
				this.iframeSpacer.style.height=ch;
				if(this.iframe)
				{
					this.iframe.style.width=cw;
					this.iframe.style.height=ch;
				}
				this.loadingDiv.style.width=cw;
				this.loadingDiv.style.height=ch;
				this.loadingTextWrapper.style.top=(Math.round(this.contentHeight/2) - 40)+"px";
				this.loadingTextWrapper.style.left=(Math.round(this.contentWidth/2) - 100)+"px";
			}
			if(this.modalType=="Modeless")
			{
				this.modelessMaskingDiv.style.width=w;
				this.modelessMaskingDiv.style.height=h;
				this.modelessMaskingIframe.style.width=w;
				this.modelessMaskingIframe.style.height=h;
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setSize()
		 *
		 * Set the content width and height and then calculate the outer dimensions
		 *
		 * @return VOID
		 *****************************************************************************/
		setSize: function (w,h)
		{
			this.contentWidth = parseInt(w,10);
			this.contentHeight = parseInt(h,10);
			if(this.inline){
				this.contentWidth += this.inlineDialogPadding*2;
				this.contentHeight += this.inlineDialogPadding*2;
			}
			this.width = this.contentWidth+this.shadowRight+(this.borderWidth*2);
			this.height = this.contentHeight+this.shadowBottom+this.titleBarHeight+(this.borderWidth*2);
		},
		
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.anchorId()
		 *
		 * Set the content width and height and then calculate the outer dimensions
		 *
		 * @return VOID
		 *****************************************************************************/
		setAnchorId: function (anchorId)
		{
			if(anchorId.length > 0){
				this.anchorId = anchorId;
			}
		},
		
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setDragNDrop()
		 *
		 * Set if the dialog can be dragged around. Default is true
		 *
		 * @return VOID
		 *****************************************************************************/
		setDragNDrop: function (v)
		{
			this.Dragging = v;
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.autoCenter()
		 *
		 * Set if the dialog will center itself after loading. Default is true
		 *
		 * @return VOID
		 *****************************************************************************/
		setAutoCenter: function (v)
		{
			this.autoCenter = v;
		},
	
		/******************************************************************************
		 * Public - this should only be called internally
		 *
		 * obj.setTitle(title)
		 *
		 * @param title ==> String that gets put into the dialog title area
		 *
		 * @return VOID
		 *****************************************************************************/
		setTitle: function (title)
		{
		   if (title!=="")
			{
		    	this.title = title;
		    	if (this.windowIcon){
			    	this.windowIcon.innerHTML = title;
			    }
		    }
		},

		 /******************************************************************************
		 * PUBLIC
		 *
		 * obj.setDisabled()
		 *
		 * Hides the close icon so the user cannot destroy the window
		 *
		 * @return VOID
		 *****************************************************************************/
		setDisabled: function (flag)
		{
			this.disabled = flag;
		},	
		
		 /******************************************************************************
		 * PUBLIC
		 *
		 * obj.disable()
		 *
		 * Hides the close icon so the user cannot destroy the window
		 *
		 * @return VOID
		 *****************************************************************************/
		disable: function ()
		{
			this.disabled = true;
			$(this.closeLink).hide();
			$("#modal_"+this.id).find("td.maximize, td.minimize").hide();
		},
        
        enable: function() {
            this.disabled = false;
            $(this.closeLink).show();
			$("#modal_"+this.id).find("td.maximize, td.minimize").show();
        },
		
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.initDrag()
		 *
		 * Initilizes mouse and element properties
		 *
		 * Load up the dragObject and assign the call back functions to it
		 *
		 * @return VOID
		 *****************************************************************************/
		initDrag: function(event)
		{
			if (this.dragObject === null)
			{
				this.dragObject = new DR.Utils.DragObject(this.dialog);
				this.dragObject.setType("Absolute", this);
				this.dragObject.setMoveDragCallback(true);
				this.dragObject.setStopDragCallback(true);
			}
			this.dragObject.initDrag(event);
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.moveDrag()
		 *
		 * When the user starts to move the window by clicking on the title bar, this
		 * function runs. Due to issues with the mouse moving into the iframe region
		 * and losing focus, we hide the iframe from view.
		 *
		 * So the user can more easily see what is behind the dialog, we set the dialog
		 * to be semi-transparent
		 *
		 * @return VOID
		 *****************************************************************************/
		moveDrag: function ()
		{
		   	if (!this.inline)
			{
				this.loadingDiv.style.visibility='hidden';
				this.iframe.style.display = 'none';
				this.iframeSpacer.style.display = 'block';
				
			}else{
				this.dialogClone.style.visibility='hidden';
			}
		    if (this.filtersSupported)
		    {
				this.contentTable.style.filter='alpha(opacity=50)';
				// The following lines are only needed if there is a PNG icon for the text
				// Currently there are no icons in use there.
				//if(!this.isIE7 && this.browserType == 'IE')
				//{
				//	this.windowIcon.style.visibility='hidden';
				//}
		    }else{
				this.contentTable.style.opacity='0.5';
		    }
		   	if(this.modalType=="Modeless")
			{
				this.modalMask.className = "modelessOverlayMask";
			    this.modalMask.style.display = 'block';
				this.modalMaskIEOver.style.display = 'block';
			}
			this.focus();
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.stopDrag()
		 *
		 * When the user stops the drag operation, we reset the condition of the dialog
		 * to be non-transparent, and we show the iframe again
		 *
		 * @return VOID
		 *****************************************************************************/
		stopDrag: function ()
		{
		    if (!this.inline)
			{
			    if (this.loading)
			    {
					this.loadingDiv.style.visibility='visible';
			    }else{
					this.iframeSpacer.style.display = 'none';
					this.iframe.style.display = 'block';
			    }
			}else{
				this.dialogClone.style.visibility='visible';
			}
		    if (this.filtersSupported)
		    {
				this.contentTable.style.filter='';
				//if(!this.isIE7 && this.browserType == 'IE')
				//{
				//	this.windowIcon.style.visibility='visible';
				//}
		    }else{
		        this.contentTable.style.opacity='1';
		    }
		    if(this.modalType=="Modeless")
			{
			    this.modalMask.style.display = 'none';
				this.modalMaskIEOver.style.display = 'none';
			}
		},
		
		/******************************************************************************
		 * obj.addEvent()
		 *
		 * @private
		 *
		 * Utility function that attaches an event to an element - cross browser
		 * 
		 * @TODO - make modaloverlay code call into the Utils.addEvent function
		 * and then delete this function
		 * 
		 * @return BOOL
		 * 
		 *****************************************************************************/
		addEvent: function( obj, evt, fn, useCapture )
		{
			if (obj.addEventListener)
			{
				obj.addEventListener(evt, fn, Boolean( useCapture ));
				return true;
			}
			else if (obj.attachEvent)
			{
				var r = obj.attachEvent("on"+evt, fn);
				
				return r;
			}
			else
			{
				return false;
			}
		},
	
		/******************************************************************************
		 * obj.removeEvent()
		 *
		 * @private
		 *
		 * Utility function that removes an event from an element - cross browser
		 * 
		 * @TODO - make modaloverlay code call into the Utils.removeEvent function
		 * and then delete this function
		 * 
		 * @return BOOL
		 * 
		 *****************************************************************************/
		removeEvent: function( obj, evt, fn, useCapture )
		{
			if (obj.addEventListener)
			{
				obj.removeEventListener(evt, fn, Boolean( useCapture ));
				return true;
			}
			else if (obj.attachEvent)
			{
				var r = obj.detachEvent("on"+evt, fn);
				return r;
			}
			else
			{
				return false;
			}
		}
	};
	
	 /******************************************************************************
	 * @public
	 *
	 * DR.Widgets.ModelessOverlay()
	 *
	 * The function opens a modeless overlay for a url.
	 *
	 * @param url ==> Url to load in the iframe
	 * @param width ==> Width of the Overlay
	 * @param height ==> Height of the Overlay
	 * @param title ==> Title of the Overlay
	 *
	 * @return DR.Widgets.ModelessOverlay
	 *****************************************************************************/
	DR.Widgets.ModelessOverlay.open = function (url,width,height,title)
	{
		var seconds = new Date().getTime();
		var m = new DR.Widgets.ModelessOverlay('modal_'+seconds,url);
		var t = title;	
			if(!title)
			{
				t = '&nbsp;';
			}
			m.setTitle(t);
			m.setSize(width,height);
			m.show();
			return m;
	};
	
	 /******************************************************************************
	 * The function closes a modeless overlay
	 *****************************************************************************/
	DR.Widgets.ModelessOverlay.close = function ()
	{
		parent.overlayStack.closeCurrent();
	};		

	/******************************************************************************
	 * DR.Widgets.ModalOverlay(id,url)
	 *
	 * The modal overlay is a in-page emulation of a popup window.
	 * The overlay is built dynamically and is attached to the page via DOM
	 *
	 * Steps to create a  Modal Overlay:
	 * 1) Create an instance of a DR.Widgets.ModalOverlay	EXAMPLE:  var FilePicker = new DR.Widgets.ModalOverlay('FilePicker',"http://www.yahoo.com/");
	 *
	 * 2) Set any opional fields, such as width, height, title
	 *
	 * 3) Call the ".show()" function
	 *
	 * 4) Call this function from a button or anchor link
	 *
	 * @param id = The id given to the container DIV, should be the same as the name of the object
	 * @param url = The url of the page that will be loaded in the iframe
	 *
	 *
	 *****************************************************************************/

	DR.Widgets.ModalOverlay = function(id,url,optionalClassName)
	{
		this.id = id;
		this.url = url;
		this.optionalClassName = (optionalClassName) ? optionalClassName : null;
	};

	DR.Widgets.ModalOverlay.prototype = new DR.Widgets.ModelessOverlay();
	DR.Widgets.ModalOverlay.prototype.modalType="Modal";
	/*
	DR.Widgets.ModalOverlay.CLOSE_WINDOW = "Close Window";
	DR.Widgets.ModalOverlay.LOADING_WINDOW = "Loading please wait..."
	*/
	DR.Widgets.ModalOverlay.CLOSE_WINDOW = "\u5173\u95ED\u7A97\u53E3";
	DR.Widgets.ModalOverlay.LOADING_WINDOW = "\u6B63\u5728\u52A0\u8F7D\uFF0C\u8BF7\u7A0D\u540E...";
	DR.Widgets.ModalOverlay.MAXIMIZE = "\u6700\u5927\u5316\u8986\u76D6";
	DR.Widgets.ModalOverlay.MINIMIZE = "\u6700\u5C0F\u5316\u8986\u76D6";
	
	 /******************************************************************************
	 * DR.Widgets.ModalOverlay.open()
	 *
	 * The function opens a modal overlay for a url
	 *
	 * @param url ==> Url to load in the iframe
	 * @param width ==> Width of the Overlay
	 * @param height ==> Height of the Overlay
	 * @param title ==> Title of the Overlay
	 *
	 * @return DR.Widgets.ModalOverlay
	 *****************************************************************************/
	DR.Widgets.ModalOverlay.open = function (url,width,height,title) {
		var seconds = new Date().getTime();
		var m = new DR.Widgets.ModalOverlay('modal_'+seconds,url);
		var t = title;	
			if(!title)
			{
				t = '&nbsp;';
			}
			m.setTitle(t);
			m.setSize(width,height);
			m.show();
			return m;
	};

	 /******************************************************************************
	 * DR.Widgets.ModalOverlay.close()
	 * The function closes a modal overlay
	 *****************************************************************************/	
	DR.Widgets.ModalOverlay.close = function () {
		parent.overlayStack.closeCurrent();
	};
	
	/******************************************************************************
	 * DR.Widgets.InlineModalOverlay(id)
	 *
	 * The inline modal overlay is a in-page emulation of a popup window.
	 * It differs from the standard overlay in that there is no iframe loaded, the
	 * overlay just pulls in any html element into the modal overlay.
	 *
	 * Steps to create an Inline Modal Overlay:
	 * 1) Create an instance of a DR.Widgets.InlineModalOverlay	EXAMPLE:  var newFolder = new DR.Widgets.InlineModalOverlay('NewFolderDiv');
	 *
	 * 2) Set any opional fields such as title, width and height
	 *
	 * 3) Call the ".show()" function
	 *
	 * 4) Call this function from a button or anchor link
	 *
	 * @param id = The id of the div to put into the modal overlay
	 *
	 *
	 *****************************************************************************/
	DR.Widgets.InlineModalOverlay = function(id,optionalClassName)
	{
		this.id = id;
		this.inlineId = id;
		this.optionalClassName = (optionalClassName) ? optionalClassName : null;
	};

	DR.Widgets.InlineModalOverlay.prototype = new DR.Widgets.ModelessOverlay();
	DR.Widgets.InlineModalOverlay.prototype.modalType="Modal";
	DR.Widgets.InlineModalOverlay.prototype.inline=true;

	DR.Widgets.InlineModelessOverlay = function(id,optionalClassName)
	{
		this.id = id;
		this.inlineId = id;
		this.optionalClassName = (optionalClassName) ? optionalClassName : null;
	};

	DR.Widgets.InlineModelessOverlay.prototype = new DR.Widgets.ModelessOverlay();
	DR.Widgets.InlineModelessOverlay.prototype.modalType="Modeless";
	DR.Widgets.InlineModelessOverlay.prototype.inline=true;

	DR.Widgets.ModalOverlay.iframeCallback = function(func){
		// If a function object was passed in, convert it to a string so that it can be executed in the context of THIS window
		if ($.isFunction(func)) {
			func = '(' + func +')();';
		}
		// Alternative to eval - create a function dynamically, then execute it immediately
		setTimeout(func,1);
	};
	
	/*
	 * jQuery API to modal overlay
	 */
	
	var defaults = {
		type: 'modal',
		inline:false,
		width:620,
		height:590,
		url:null,
		id:null,
		title: '&nbsp;',
		cancelFunction: null,
		callBackFunction: null,
		abortFunction: null,
		draggable: true,
		centered: true,
		relativePositioned: false,
		optionalClassName: null,
		showCloseIcon: true,
		showMaximize: false,
		startMaximized: false
	};
	
	$.dr.overlay = function(options){
		options = $.extend({},defaults, options);
		var m,
			id = options.id,
			url = options.url,
			type = options.type,
			inline = options.inline,
			optionalClassName = options.optionalClassName;

		if(inline){
			var d = $('#'+id).data('overlay');
			if(d){
				d.setTitle(options.title);
				d.setSize(options.width,options.height);
				d.show();
				return;
			}
		}else{
			if(url.length===0){
				// the user failed to specify the url
				return;
			}
		}
			
		var widgets = DR.Widgets;
		
		if(!id){
			id = 'modal_' + new Date().getTime();
		}
		
		if(!inline && type == 'modal'){
			m = new widgets.ModalOverlay(id,url,optionalClassName);
		}else if(!inline && type == 'modeless'){
			m = new widgets.ModelessOverlay(id,url,optionalClassName);
		}else if(type == 'modal'){
			m = new widgets.InlineModalOverlay(id,optionalClassName);
		}else if(type == 'modeless'){
			m = new widgets.InlineModelessOverlay(id,optionalClassName);
		}

		m.setTitle(options.title);
		m.setSize(options.width,options.height);
		
		if(!options.draggable){
			m.setDragNDrop(false);
		}
		
		if(!options.centered){
			m.setAutoCenter(false);
		}

		if(options.anchorId){
			m.setAutoCenter(false);
			m.setAnchorId(options.anchorId);
		}			
		
		if(typeof options.cancelFunction == 'function'){
			m.cancelFunction = options.cancelFunction;
		}

		if(typeof options.callBackFunction == 'function'){
			m.callBackFunction = options.callBackFunction;
		}

		if(typeof options.abortFunction == 'function'){
			m.abortFunction = options.abortFunction;
		}
		
		if(!options.showCloseIcon){
			m.setDisabled(true);
		}
		m.showMaximize = options.showMaximize;
		m.startMaximized = options.startMaximized;
		
		m.show();
		
		if(inline){
			$('#'+id).data('overlay', m);
		}

		return m;
	};
		
		
	$.dr.overlay.close = function(){
		DR.Widgets.ModalOverlay.close();
	};
	
	$.namespace('dr',{
		overlay: function(options){
			return this.each(function(){
				var opts = $.extend({}, options, {inline:true, id:this.id });
				$.dr.overlay(opts);
			});
		}
	});
	
	var getOverlay = function(obj){
		return $(obj).data('overlay');
	};
	
	/*
	 * Public API to overlay
	 */
	$.namespace('dr.overlay',{
		setTitle: function(title){
			return this.each(function(){
				var m = getOverlay(this);
				if(m){
					m.setTitle(title);
				}
			});
		}
	});
	
})(jQuery);
;(function($) {	 
	 /******************************************************************************
	 * DR.Widgets.ModalOverlayStack()
	 *
	 * Copyright 2006 Digital River
	 *
	 * Written by Dustin Pease - dpease@digitalriver.com
	 *
	 * The modal overlay base is the object that both the ModalOverlay and Modeless
	 * Overlay inherit from.
	 *
	 *
	 * Internal Properties:
	 *
	 * windows 			==> Array of all windows(dialogs) created on the page
	 * zIndex			==> Dialogs are given a z-index starting at 100,000 for the purposes of stacking
	 * windowIndex		==> Number of windows added to the page
	 * iframeCounter	==> Number of iframes added to the page
	 * currentWindow	==> Position in windows array, used to reference a modal dialog
	 * focusAndBlurSet	==> If not set, attach focus and blur events
	 *
	 *****************************************************************************/

	DR.Widgets.ModalOverlayStack = function ()
	{
		this.windows = [];
		this.zIndex = 100000;
		this.windowIndex=-1;
		this.iframeCounter=-1;
		this.currentWindow = -1;
		this.focusAndBlurSet = false;
		this.doc = {};
	};
	
	DR.Widgets.ModalOverlayStack.prototype = {
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.add()
		 *
		 * The function adds a reference to a dialog into the stack, and returns the
		 * position in the array that it was added to.
		 *
		 * @return INTEGER
		 *****************************************************************************/
		add: function (obj)
		{
			this.windowIndex++;
			this.windows[this.windowIndex] = obj;
			this.currentWindow = this.windowIndex;
			return this.windowIndex;
		},
	
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.addChildWindow()
		 *
		 * The function is called when a modal overlay has been opened from an iframe
		 * inside of a modal overlay. This creates the "stack" effect where the modal
		 * overlays layer on top of each other, and you can not click on the opener
		 * without dismissing the top overlay
		 *
		 * @return INTEGER
		 *****************************************************************************/
		addChildWindow: function (obj,parentWindowIndex)
		{
			this.setCurrentHasModalChildren(true);
	        var m = new DR.Widgets.ModalOverlay(obj.id,obj.url);
			m.parentId = this.currentWindow;
			m.parentWindowIndex = parentWindowIndex;
			m.setTitle(obj.title);
			m.setDragNDrop(obj.enableDragging);
			if (typeof(obj.callBackFunction)=="function")
			{
				m.setCallBackFunction(obj.callBackFunction);
			}
			if (typeof(obj.cancelFunction)=="function")
			{
				m.setCancelFunction(obj.cancelFunction);
			}
			if (typeof(obj.abortFunction)=="function")
			{
				m.setAbortFunction(obj.abortFunction);
			}
			m.setSize(obj.contentWidth,obj.contentHeight);
			m.showMaximize = obj.showMaximize;
			m.show();
			obj=null;
		},
	
		 /******************************************************************************
		 * PUBLIC - this should only be called internally
		 *
		 * obj.getCurrent()
		 *
		 * This function returns the modal dialog object that is at the top of the
		 * stack of dialogs on the page
		 *
		 * @return ModalOverlay
		 *****************************************************************************/
		getCurrent: function ()
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
				return c;
			}
		},
		
		/******************************************************************************
		 * PUBLIC - this should only be called internally
		 *
		 * obj.getById()
		 *
		 * This function returns the modal dialog object for an ID, if not found it 
		 * returns null
		 *
		 * @return ModalOverlay
		 *****************************************************************************/
		getById: function (id)
		{
			for (var i = 0; i < this.windows.length; i++)
			{
				if (this.windows[i].id==id)
				{
					return this.windows[i];
					break;
				}
			}
			return null;
		},
		
		 /******************************************************************************
		 * PUBLIC - this should only be called internally
		 *
		 * obj.checkCurrentLoading()
		 *
		 * Checks if the current overlay is still loading the iframe
		 *
		 * @return Bool
		 *****************************************************************************/
		checkCurrentLoading: function ()
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
				return c.loading;
			}
		},
	
		 /******************************************************************************
		 * PUBLIC - this should only be called internally
		 *
		 * obj.disableCurrent()
		 *
		 * Hides the close icon so the user cannot destroy the window
		 *
		 * @return VOID
		 *****************************************************************************/
		disableCurrent: function ()
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
					c.closeLink.style.visibility='hidden';
			}
		},
		
		/******************************************************************************
		 * PUBLIC - this should only be called internally
		 *
		 * obj.enableCurrent()
		 *
		 * Shows the close icon
		 *
		 * @return VOID
		 *****************************************************************************/
		enableCurrent: function ()
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
					c.closeLink.style.visibility='visible';
			}
		},
		
		 /******************************************************************************
	
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setCurrentWindow()
		 *
		 * This function sets the current window to a specific overlay
		 *
		 *
		 * @return VOID
		 *****************************************************************************/
		setCurrentWindow: function (id)
		{
			this.currentWindow = id;
		},
	
	
		 /******************************************************************************
	
		 * PRIVATE - this should only be called internally
		 *
		 * obj.getNewIframeID()
		 *
		 * This function increments the iframe property of the stack, and returns the
		 * new number. To prevent addressing issues, we always increase the iframe
		 * number even after we close an overlay and destroy it
		 *
		 * @return int
		 *****************************************************************************/
		getNewIframeID: function ()
		{
			this.iframeCounter++;
			return this.iframeCounter;
		},
	
		 /******************************************************************************
		 * Public
		 *
		 * obj.bringOpenOverlayToFront()
		 *
		 * This function checks to see if any of the windows in the stack are open, 
		 * the first open overlay is brought to front.
		 *
		 * @return undefined
		 *****************************************************************************/
		bringOpenOverlayToFront: function ()
		{
			for (var i = 0; i < this.windows.length; i++)
			{
				if (this.windows[i].isOpen)
				{
					overlayStack.bringToFront(i);
					return;
				}
			}
		},
			
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.checkAnyOpen()
		 *
		 * This function checks to see if any of the windows in the stack are open
		 *
		 * @return bool
		 *****************************************************************************/
		checkAnyOpen: function ()
		{
			var anyOpen = false;
			for (var i = 0; i < this.windows.length; i++)
			{
				if (this.windows[i].isOpen)
				{
					anyOpen=true;
				}
			}
			return anyOpen;
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.checkAnyModalOpen()
		 *
		 * This function checks to see if any of the windows in the stack is open
		 * and is of the type Modal
		 *
		 * @return bool
		 *****************************************************************************/
		checkAnyModalOpen: function ()
		{
			var anyOpen = false;
			for (var i = 0; i < this.windows.length; i++)
			{
				if (this.windows[i].isOpen && this.windows[i].modalType=="Modal")
				{
					anyOpen=true;
				}
			}
			return anyOpen;
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.checkAnyModelessOpen()
		 *
		 * This function checks to see if any of the windows in the stack is open
		 * and is of the type Modeless
		 *
		 * @return bool
		 *****************************************************************************/
		checkAnyModelessOpen: function ()
		{
			var anyOpen = false;
			for (var i = 0; i < this.windows.length; i++)
			{
				if (this.windows[i].isOpen && this.windows[i].modalType=="Modeless")
				{
					anyOpen=true;
				}
			}
			return anyOpen;
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setCurrentHasChildren()
		 *
		 * Sets if the current dialog has any inline child modal dialogs
		 *
		 * @return VOID
		 *****************************************************************************/
		setCurrentHasChildren: function (flag)
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
					c.hasChildren=flag;
			}
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setCurrentHasModalChildren()
		 *
		 * Sets if the current dialog has any child modal dialogs
		 *
		 * @return VOID
		 *****************************************************************************/
		setCurrentHasModalChildren: function (flag)
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
					c.hasModalChildren=flag;
			}
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.resizeCurrent(width,height)
		 *
		 * Gets the current window, and resizes it according to the width and height
		 * passed in via arguments
		 *
		 * @return VOID
		 *****************************************************************************/
		resizeCurrent: function (width,height)
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
					c.setSize(width,height);
					c.refreshSize();
					c.position();
			}
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.blurCurrent
		 *
		 * Gets the current window and calls the blur function
		 *
		 * @return VOID
		 *****************************************************************************/
		blurCurrent: function ()
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
					c.blurWindow=false;
					c.blur();
			}
		},
		
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.hideCurrent
		 *
		 * Hides the current window
		 *
		 * @return VOID
		 *****************************************************************************/
		hideCurrent: function ()
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
					c.dialog.style.display = 'none';
					c.enableScrollBars();
			}
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.blurOtherWindows
		 *
		 * If there are multiple modals open, we blur them, except the current window
		 *
		 * @return VOID
		 *****************************************************************************/
		blurOtherWindows: function ()
		{
			for (var i = 0; i < this.windows.length; i++)
			{
				if (this.windows[i].stackId!=this.currentWindow)
				{
					this.windows[i].hasFocus = false;
					this.windows[i].blur();
				}
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.windowOnBlur
		 *
		 * When the window is blurred, it blurs the currently focused overlay
		 *
		 * @return VOID
		 *****************************************************************************/
		windowOnBlur: function ()
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
					c.blurWindow=true;
					c.blur();
			}
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.focusCurrent
		 *
		 * Gets the current window and calls the focus function
		 *
		 * @return VOID
		 *****************************************************************************/
		focusCurrent: function (forceFocus)
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
				if (!c.hasFocus || forceFocus)
				{
					c.focus();
				}
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.bringToFront()
		 *
		 * This function increments the zindex of the stack, and returns that number.
		 *
		 * @return INTEGER
		 *****************************************************************************/
		bringToFront: function (id)
		{
			if (this.windowIndex>-1)
			{
				this.currentWindow = id;
				var c = this.windows[this.currentWindow];
	
				//if (c.dialog.style.zIndex == "")
				//{
					this.zIndex = this.zIndex + 5;
				//}
	
				if (this.currentWindow>-1)
				{
	
					//if (this.zIndex!=c.dialog.style.zIndex)
					//{
						c.dialog.style.zIndex = this.zIndex;
						//c.modalMaskIframe.style.zIndex = this.zIndex-3;
						c.modalMask.style.zIndex = this.zIndex-2;
						c.modalMaskIEOver.style.zIndex = this.zIndex-1;
					//}
					
					$(c.contentTable).removeClass("inActive");
	
					//if (c.titleBar.className!="titleBarActive")
					//{
					//	c.titleBar.className="titleBarActive";
					//}
	
				}
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.addWindowEventHandlers()
		 *
		 * This function attaches focus and blur events onto the window, so that we
		 * can emulate the standard blurring effect of popular Operating Systems
		 *
		 * @return INTEGER
		 *****************************************************************************/
		addWindowEventHandlers: function ()
		{
			// Commented out functions for automatic blurring of overlays
			// TO-DO - Get this working cross browser and re-enable
	
			//function overlayStackWindowOnBlur(){overlayStack.windowOnBlur();}
			//function overlayStackFocusCurrent(){overlayStack.focusCurrent(true);}
			function overlayStackFocusParent()
			{
				if(window!=top)
				{
						parent.overlayStack.setCurrentHasChildren(false);
						parent.overlayStack.focusCurrent(true);
				}
			}
	
			if (!overlayStack.focusAndBlurSet)
			{
				if (window.attachEvent)
				{
					//window.attachEvent("onblur", overlayStackWindowOnBlur);
					//window.attachEvent("onfocus", overlayStackFocusCurrent);
					window.attachEvent("onunload",overlayStackFocusParent);
				}
				else
				{
					//window.addEventListener("blur", overlayStackWindowOnBlur,	false);
					//window.addEventListener("focus", overlayStackFocusCurrent,	false);
					window.addEventListener("unload", overlayStackFocusParent,	false);
				}

				var oldfn = window.onresize;
				if (typeof window.onresize != 'function')
				{
					window.onresize = function(){overlayStack.refreshMaskSize();};
					this.onResizeSet=true;
				}
				else if (!this.onResizeSet)
				{
					window.onresize = function(){overlayStack.refreshMaskSize(); oldfn();};
				}
	
				overlayStack.focusAndBlurSet=true;
	

			}
			function cleanupEvents()
			{
				// The following lines prevent a memory leak in Internet Explorer from the closure type of leak
				//window.detachEvent("onblur", overlayStackWindowOnBlur);
				//window.detachEvent("onfocus", overlayStackFocusCurrent);
				window.detachEvent("onunload",cleanupEvents);
				window.onresize = null;
			}
			
			if (window.attachEvent){
				window.attachEvent("onunload",cleanupEvents);
			}
		},
	
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.setMaskSize()
		 *
		 * When the user resizes the window, or has shown a dialog, we refresh the
		 * size of the masking layer
		 *
		 * @return VOID
		 *****************************************************************************/
		refreshMaskSize: function ()
		{
			if (this.currentWindow>-1)
			{
				var c = this.windows[this.currentWindow];
				this.getPageSize();
				if (c != null && c.modalMask == null) {
					return false;
				}
				if(document.all)
				{
					c.modalMask.style.width 		= this.doc.windowWidth + 'px';
					c.modalMaskIframe.style.width 	= this.doc.windowWidth + 'px';
					c.modalMaskIEOver.style.width 	= this.doc.windowWidth + 'px';
				}
				c.modalMask.style.height 		= this.doc.pageHeight + 'px';
				c.modalMaskIframe.style.height 	= this.doc.pageHeight + 'px';
				c.modalMaskIEOver.style.height 	= this.doc.pageHeight + 'px';
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.buildIframe()
		 *
		 * This function loads the iframe url again.
		 *
		 * @return VOID
		 *****************************************************************************/
		buildIframe: function ()
		{
			if (this.currentWindow>-1)
			{
				this.windows[this.currentWindow].ieTimeout = false;
				
				this.windows[this.currentWindow].buildIframe();
			}
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.closeCurrent()
		 *
		 * This function finds the currently focused window, and closes it
		 *
		 * @return VOID
		 *****************************************************************************/
		closeCurrent: function ()
		{
			if (this.currentWindow>-1)
			{
				this.windows[this.currentWindow].cancel();
			}
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.cancelCurrent()
		 *
		 * This function finds the currently focused window, and calls cancel
		 *
		 * @return VOID
		 *****************************************************************************/
		cancelCurrent: function ()
		{
			if (this.currentWindow>-1)
			{
				this.windows[this.currentWindow].cancel();
			}
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.destroyAll()
		 *
		 * This function goes through all overlays, and nulls them out
		 *
		 * @return VOID
		 *****************************************************************************/
		destroyAll: function ()
		{
			var anyOpen = false;
			for (var i = 0; i < this.windows.length; i++)
			{
				if (!this.windows[i].inline)
				{
					this.currentWindow = i;
					this.destroyCurrent();
				}
			}
			return anyOpen;
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.destroyCurrent()
		 *
		 * Calls the destoryWindow with the current window id
		 *
		 * @return VOID
		 *****************************************************************************/
		destroyCurrent: function ()
		{
			if (this.currentWindow>-1)
			{
				this.destroyWindow(this.currentWindow);
			}
	
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.destroyWindow()
		 *
		 * This function frees up the memory for the current window, and removes from
		 * the stack
		 *
		 * @return VOID
		 *****************************************************************************/
		destroyWindow: function (windowId)
		{
			if (windowId>-1)
			{
				var myWindow = this.windows[windowId];
				var parentId = -1;
	
				if (myWindow.parentId>-1)
				{
					parentId = myWindow.parentId;
				}
				
				if(!myWindow.inline)
				{
					if(myWindow.iframe)
					{
						myWindow.iframe.parentNode.removeChild(myWindow.iframe);
						myWindow.iframeSpacer.parentNode.removeChild(myWindow.iframeSpacer);
						myWindow.contentTable.parentNode.removeChild(myWindow.contentTable);
						myWindow.windowIcon.parentNode.removeChild(myWindow.windowIcon);
						myWindow.dialog.parentNode.removeChild(myWindow.dialog);
			
						this.windows[windowId].iframe=null;
						this.windows[windowId].modalMask=null;
						this.windows[windowId].modelessMaskingDiv=null;
						this.windows[windowId].modelessMaskingIframe=null;
						this.windows[windowId].modalMaskIframe=null;
						this.windows[windowId].modalMaskIEOver=null;
						this.windows[windowId].iframeSpacer=null;
						this.windows[windowId].contentTable=null;
						this.windows[windowId].windowIcon=null;
						this.windows[windowId].dialog=null;
					}
					
					myWindow = null;
					this.windows[windowId]=null;
					this.windows.splice(windowId,1);
					this.windowIndex--;
					this.currentWindow = -1;
					windowId = this.windows.length - 1 ;
					
				}
				if (parentId>-1 && windowId > -1)
				{
					this.windows[parentId].hasModalChildren = false;
					this.windows[parentId].focus();
					this.reorderStack(false);
				}else{
						this.reorderStack(true);
				}
			}
		},
	
		 /******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.reorderStack
		 *
		 * Reassigns the stackId to dialogs after one has been destroyed
		 *
		 * @return VOID
		 *****************************************************************************/
		reorderStack: function (focus)
		{
			var lastWindow = -1;
			for (var i = 0; i < this.windows.length; i++)
			{
				if(this.windows[i].isOpen)
				{
					this.windows[i].stackId = i;
					lastWindow = i;	
				}
			}
			
			if(lastWindow>-1 && focus)
			{
				this.currentWindow = lastWindow;
				this.windows[this.currentWindow].focus();
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.callBack()
		 *
		 * Called usually from inside an iframe when we want to return some data to
		 * the parent window and also do some action on the page.
		 *
		 * @return VOID
		 *****************************************************************************/
		callBack: function (arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)
		{
			if (this.currentWindow>-1)
			{
				var myWindow = this.windows[this.currentWindow];
				if (myWindow.parentId>-1)
				{
					window.frames[this.windows[myWindow.parentId].iframe.id].overlayStack.callBack(arg1,arg2,arg3,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
				}else
				{
					myWindow.callBack(arg1,arg2,arg3,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
				}
			}
		},
		
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.getPageSize()
		 *
		 * Sets the window and page width and height
		 *
		 * @return VOID
		 *****************************************************************************/
		getPageSize: function ()
		{
			
			// TODO - link into a pageSizer object
	
			var xScroll, yScroll,pageHeight,pageWidth;
	
			var obj = {};
	
			if (window.innerHeight && window.scrollMaxY) {
				xScroll = document.body.scrollWidth;
				yScroll = window.innerHeight + window.scrollMaxY;
			} else if (document.body.scrollHeight > document.body.offsetHeight){ // all but Explorer Mac
				xScroll = document.body.scrollWidth;
				yScroll = document.body.scrollHeight;
			} else { // Explorer Mac...would also work in Explorer 6 Strict, Mozilla and Safari
				xScroll = document.body.offsetWidth;
				yScroll = document.body.offsetHeight;
			}
			var windowWidth, windowHeight;
			if (self.innerHeight) {	// all except Explorer
				windowWidth = self.innerWidth;
				windowHeight = self.innerHeight;
			} else if (document.documentElement && document.documentElement.clientHeight) { // Explorer 6 Strict Mode
				windowWidth = document.documentElement.clientWidth;
				windowHeight = document.documentElement.clientHeight;
			} else if (document.body) { // other Explorers
				windowWidth = document.body.clientWidth;
				windowHeight = document.body.clientHeight;
			}
	
			// for small pages with total height less then height of the viewport
			if(yScroll < windowHeight){
				pageHeight = windowHeight;
			} else {
				pageHeight = yScroll;
			}
	
			// for small pages with total width less then width of the viewport
			if(xScroll < windowWidth){
				pageWidth = windowWidth;
			} else {
				pageWidth = xScroll;
			}

			this.doc.pageWidth = pageWidth;
			this.doc.pageHeight = pageHeight;
			this.doc.windowWidth = windowWidth;
			this.doc.windowHeight = windowHeight;
		}
	};
	
	overlayStack = new DR.Widgets.ModalOverlayStack();
	
})(jQuery);
/*
 * This plugin is a heavily modified version of:
 * jQuery multiSelect
 * Version 1.2.2 beta
 *
 * Cory S.N. LaViska
 * A Beautiful Site (http://abeautifulsite.net/)
 * 09 September 2009
 *
 * Visit http://abeautifulsite.net/notebook/62 for more information
 * Licensing & Terms of Use
 * 
 * This plugin is dual-licensed under the GNU General Public License and the MIT License and
 * is copyright 2008 A Beautiful Site, LLC. 
 *  
 */

;(function($) {
    //the maximum number of options a segment can hold
    var SEGMENT_LENGTH = 1000;
    //number of segments to partition options into when inserting into DOM
    var MAX_SEGMENTS = 1;//Math.max(Math.floor(optLength/SEGMENT_LENGTH),1);
    //height of options inside the multiselect. used for determining how many options will be visible within multiSelectOptions
    var OPTION_HEIGHT = 5;   
    var messages = {
        SELECT_ALL: "\u5168\u9009",
        SELECT: "\u9009\u62E9",
        ALL: "All",
        START_TYPING: "Start typing to search..."
    };
    var defaults = {
        width:196,
        searchFilterAllText: messages.ALL,
        selectAll : true,
        selectAllText: messages.SELECT_ALL,
        selectText: messages.SELECT,
        searchFilterSelectAllValue: "NOFILTER",
        oneOrMoreSelected : "*",
        listHeight : 250,
        noneSelected: false,
        optGroupSelectable: false,
        isSearchFilter: false,
        showSearch: false,
        buildOnInit: false
    };
    
    var searchTermChars = [];
    var searchTimeout = null;
    var searchTermDefaulText = messages.START_TYPING;
    var searchTermInput = $("<div class='multiselectSearchTerms' style='z-index:999999;'>"+searchTermDefaulText+"</div>");

    $.dr.multiselect = {
        setDefaults: function(opts){
            if (opts) {
                 $.extend(defaults, opts);
            }
        }
    };
    var multiJoin = function(array) {
        var joinedHtml = [];
        for (var i=0;i<array.length;i++) {
            joinedHtml.push(array[i].join(""));
        }
        return joinedHtml.join("");
    };
    var bindOptions = function(multiSelectOptions, multiSelect, select) {
        var $select = $(select);
        var $multiSelect = $(multiSelect);
        multiSelectOptions.find("input").bind("dr-multiselectChecked", function(e, keyCode, options){
                var $target = $(e.target), index = $target.attr("data-index");
                var opt = $($select.find("option")[index]);
                if (opt) {
                    if ($(e.target).is(":checked")) {
                        opt.attr("selected",true);
                    } else {
                        opt.attr("selected",false);
                    }
                }
                setTimeout(function(){
                    $select.trigger("change");
                    $select.trigger("dr-afterMultiselectChange", [e.target, multiSelectOptions]);
                },0);
                if (keyCode != 13) {
                    //Why do we need to do this? Keep here until we know we can remove for good
                    //$multiSelect.data("ms").multiSelectReposition();      
                }
        });
    };
    /**
     * If a filter was removed, add it back to the element
     * @param{Object} $elem 
     */
    var reapplyIEShadow = function($elem) {
        if ($.browser.msie) {
            var filter = $.data($elem[0],"shadowFilter",filter);
            if (filter!=="") {
                $elem[0].style.filter = filter;
            }
        }
    };
    /**
     * Remove the shadow filter from the element 
     * @param{Object} $elem 
     */
    var removeIEShadow = function($elem) {
        if ($.browser.msie) {
            var filter = $elem[0].currentStyle.filter;
            if (typeof(filter)!="undefined") {
                $.data($elem[0],"shadowFilter",filter);
                $elem[0].style.filter = "";
            }
        }
    };
    /*
     * Update the optGroup checkboxes. Check it if all the options in the optgroup are checked
     * @param{Object} multiSelectOptions 
    */
    var updateOptGroupCheckboxes = function(multiSelectOptions) {
        var optGroups = multiSelectOptions.find("input.optGroup");
        for (var i = optGroups.length - 1; i >= 0; i--) {
            var $og = $(optGroups[i]);
            var $container = $og.parent().next("div.optGroupContainer");
            var $inputsInOptGroup = $container.find("input");
            var $inputsInOptGroupChecked = $inputsInOptGroup.filter(function(){ return this.checked === true;});
            if ($inputsInOptGroup.length === $inputsInOptGroupChecked.length) {
                $og.attr("checked",true);
            }
        }
    };
    var multiselect = function(select,options,callback) {
        if (!$(select).hasClass("initialized")) {
            this.built = false;
            this.select = select;
            this.multiSelect = null;
            this.multiSelectOptions = null;
            this.options = options;
            this.disabled = false;
            this.init(select,options,callback);
        }
    };
    multiselect.prototype = {
        init:function(select,o,callback) {  
            var oThis = this;   
            select.after('<a href="javascript:;" class="multiSelect"><span>&nbsp;</span></a><div class="multiSelectOptions" style="position: absolute; z-index: 99999;"></div>');
            var multiSelect = select.next('.multiSelect');
            this.multiSelect = multiSelect;
            var multiSelectOptions = multiSelect.next(".multiSelectOptions");
            this.multiSelectOptions = multiSelectOptions;
            if (o.showSearch) {
                multiSelectOptions.after(searchTermInput.clone().hide()[0]);
                o.searchTermInput = multiSelectOptions.next();
            }
            var msPadding = (parseInt(multiSelect.css("paddingRight"),10)+parseInt(multiSelect.css("paddingLeft"),10)) || 0;
            var msMargin = (parseInt(multiSelect.css("marginRight"),10)+parseInt(multiSelect.css("marginLeft"),10)) || 0;
            var msBorder = (parseInt(multiSelect.css("borderRightWidth"),10)+parseInt(multiSelect.css("borderLeftWidth"),10)) || 0;
            // if the select object had a width defined then match the new multilsect to it
            var width = parseInt($(select).dr.utils.getHiddenDimensions().width - msPadding - msMargin-msBorder,10);
            width = (width <= 30 || (o.width !== undefined && isNaN(parseInt(o.width,10))) ) ? o.width : width;
            multiSelect.find("span").css("width", width+"px");
            o.multiSelectOptions = multiSelectOptions;
            // Attach the config options to the multiselect
            $.data(multiSelect[0],"config",o);
            $.data(multiSelect[0],"ms",this);
            $.data(multiSelect[0],"allSelected", false);
            // Attach the callback to the multiselect
            $.data(multiSelect[0],"callback", callback);
            $.data(multiSelect[0],"built",false);
            // Serialize the select options into json options
            var options = [], i = 0;
            select.children().each( function() {
                var $this = $(this);
                if(this.tagName.toUpperCase() == 'OPTGROUP') {
                    var suboptions = [];
                    options.push({ optgroup: $this.attr('label'), options: suboptions });
                    $this.find('OPTION').each( function() {
                        var $othis = $(this);
                        if( $othis.val() != '' && $othis.val() != o.searchFilterSelectAllValue) {
                            suboptions.push({ text: $othis.html(), value: $othis.val(), selected: $othis[0].selected,index:i });
                        }
                        i++;
                    });
                } else if(this.tagName.toUpperCase() == 'OPTION') {
                    if( $this.val() != '' && $this.val() != o.searchFilterSelectAllValue) {
                        options.push({ text: $this.html(), value: $this.val(), selected: $this[0].selected, index: i});
                    }
                    i++;
                }
            });
            if (this.getOption("buildOnInit") === true) {
                oThis.buildOptions(options);
            }
            
            $.data(multiSelect[0],"option_elems", options);
            // HIDE the original form select element
            select.hide();
            // Add the id that was on the original select element to the new input
            multiSelect.attr("id", select[0].id + "_ms");       
            // Build the dropdown options
           // $.data(multiSelect,"multiselect",this);
            //Mirror selections with original select element
            this.setDisplayText(options);
            // Events
            multiSelect.hover( function() {
                $(this).addClass('hover');
                if (multiSelect.hasClass("active")) {
                    oThis.checkMultiSelectOptionsPosition(multiSelect,multiSelectOptions);
                }
            }, function() {
                $(this).removeClass('hover');
                if (multiSelect.hasClass("active")) {
                    oThis.checkMultiSelectOptionsPosition(multiSelect,multiSelectOptions);
                }
                
            }).click( function() {
                multiSelectOptions.trigger("internalClick.multiselect");
                // Show/hide on click
                if (oThis.isDisabled()) {
                    return false;
                }
                if( $(this).hasClass('active') ) {
                    oThis.multiSelectOptionsHide();
                } else {
                    $(oThis.select).trigger('dr-beforeOpen.multiSelect');
                    if (oThis.built === false) {
                        oThis.buildOptions(options);
                        setTimeout(function() {
                            oThis.multiSelectOptionsShow();
                        },0);
                    } else {
                        oThis.multiSelectOptionsShow();
                    }
                }
                return false;
            }).focus( function() {
                // So it can be styled with CSS
                $(this).addClass('focus');
            }).blur( function() {
                // So it can be styled with CSS
                $(this).removeClass('focus');
            });
            // Add an event listener to the window to close the multiselect if the user clicks off
            if ($(select).hasClass("disabled")) {
                this.setDisabled(true);
            }
            $(select).addClass("initialized").addClass("multiselect");
            $(select).trigger("dr-multiselectBuilt",[this.multiSelectOptions]);
        },
        setDisabled:function(d) {
            if (typeof d === "boolean") {
                this.disabled = d;
            }
            if (d===true) {
                $(this.multiSelect).addClass("disabled");
            } else if (d===false){
                $(this.multiSelect).removeClass("disabled");
            }
        },
        isDisabled:function() {
            return this.disabled;
        },
        renderOption: function(id, option){
            var html = [];
            var checkedClass = ( option.selected ) ? "class='checked' " : "";
            html.push('<label '+ checkedClass + ((option.text.length > 60) ? 'title="'+option.text+'"' : '' )+'><input data-index="'+option.index+'" type="checkbox" value="' + option.value + '"');
            if( option.selected ){
                html.push(' checked="checked"');
            }
            html.push(' title="' + option.text + '"');
            var labelText = option.text.substring(0,60);
            html.push(' />' + ((option.text.length > 60 ) ? labelText+"..." : labelText) + '</label>');
            
            return html.join("");
        },
        renderOptions: function(id, options, o, groupLimit) {
            var oThis = this;
            var html = [];
            var firstLimit = Math.round(this.options.listHeight / OPTION_HEIGHT);
            groupLimit = firstLimit || options.length;
            var addToHtml = function(htmlString,passSeg){
                if (typeof(html[passSeg]) === "undefined") {
                    html[passSeg] = [htmlString];
                } else {
                    html[passSeg].push(htmlString);
                }
            };
            var optLength = options.length;
            var segment = 0;
            for(var i = 0; i < optLength; i++) {
                //split loading into unit data segments
                if (i!==0 && (i%SEGMENT_LENGTH) === 0 && i >=SEGMENT_LENGTH && segment+1 < MAX_SEGMENTS) {
                    segment = ((i/SEGMENT_LENGTH)+1);
                } else if (i <= groupLimit) {
                    segment = 0;
                } else if (i<SEGMENT_LENGTH){
                    segment = 1;
                }
                if(options[i].optgroup) {
                    addToHtml('<label class="optGroup">',segment);
                    if(o.optGroupSelectable) {
                        addToHtml('<input type="checkbox" class="optGroup" />' + options[i].optgroup,segment);
                    }
                    else {
                        addToHtml(options[i].optgroup,segment);
                    }
                    addToHtml('</label><div class="optGroupContainer">',segment);
                    addToHtml(multiJoin(oThis.renderOptions(id, options[i].options, o)),segment);
                    addToHtml('</div>',segment);
                } else {
                    addToHtml(oThis.renderOption(id, options[i]),segment);
                }
            }
            return html;
        },
        buildOptions: function(options) {
            var oThis = this;
            var $select = this.select;
            var multiSelect = $(this.multiSelect);
            var multiSelectOptions = $.data(multiSelect[0],"config").multiSelectOptions;
            var o = $.data(multiSelect[0],"config");
            var callback = $.data(multiSelect[0],"callback");
    
            // clear the existing options
            multiSelectOptions.html("");
            var html = "";
            // if we should have a select all option then add it
            if( o.selectAll ) {
                html += '<label class="multiSelectAll"><input type="checkbox" class="multiSelectAll" />' + o.selectAllText + '</label>';
            }
            // generate the html for the new options
            var optionsHtml = this.renderOptions(multiSelect.attr('id'), options, o);
            if (optionsHtml.length === 0) {
                return false;
            }
            optionsHtml[0] = html + optionsHtml[0].join("");
            multiSelectOptions[0].innerHTML = optionsHtml[0]+"<div class='overflowOpts'></div>";
            var optLength = optionsHtml.length;
            // variables needed to account for width changes due to a scrollbar
            var msoWidth = ($(multiSelectOptions).dr.utils.getHiddenDimensions().width),
                msOuterWidth = $(multiSelect).dr.utils.getHiddenDimensions().outerWidth,
                msoHeight = $(multiSelectOptions).dr.utils.getHiddenDimensions().height;
            var initialWidth = multiSelectOptions.msoWidth;
            var hasScrollbar = false;
            
            // set the height of the dropdown options
            if(msoHeight > o.listHeight || msoHeight === 0) {
                multiSelectOptions.css("height", o.listHeight + 'px');
                hasScrollbar = true;
            } else {
                multiSelectOptions.css("height", '');
            }
            
            // if the there is a scrollbar and the browser did not already handle adjusting the width (i.e. Firefox) then we will need to manaually add the scrollbar width
            var scrollbarWidth = hasScrollbar && (initialWidth == msoWidth) ? 17 : 0;
    
            // set the width of the dropdown options
            if((msoWidth + scrollbarWidth) < msOuterWidth) {
                multiSelectOptions.css("width", msOuterWidth - 2/*border*/ + 'px');
            } else {
                multiSelectOptions.css("width", (msoWidth + scrollbarWidth) + 'px');
            }
            msoWidth = $(multiSelectOptions).dr.utils.getHiddenDimensions().width;
            msoHeight = $(multiSelectOptions).dr.utils.getHiddenDimensions().height;
            
            // Apply bgiframe if available on IE6
            if (($.browser.msie && parseInt($.browser.version, 10) == 6) && $.fn.bgiframe) {
                $.data(multiSelect[0],"config").multiSelectOptions.bgiframe( { width: msoWidth, height: msoHeight });
            }
            // Handle selectAll oncheck
            if(o.selectAll) {
                multiSelectOptions.find('INPUT.multiSelectAll').bind("click", function() {
                    // update all the child checkboxes
                    var $allCheckboxes = multiSelectOptions.find('INPUT:checkbox'), $this = $(this), isChecked = $this.is(":checked");
                    if ($select.triggerHandler("dr-beforeMultiselectChange", [this, multiSelectOptions]) === false) {
                        return false;
                    }
                    if (!o.isSearchFilter) {
                        oThis.selectAll(multiSelectOptions,isChecked);
                    } else {

                        this.checked = $(this).attr("checked");
                        //Do not allow unchecking of All checkbox...
                        var $allOtherCheckboxes = $allCheckboxes.not(".multiSelectAll");
                        if (this.checked === false && $allOtherCheckboxes.filter(function(){ return this.checked===true; }).length === 0) {
                            this.checked = "checked";
                            return;
                        } else {
                            $allCheckboxes.filter(".multiSelectAll:first").parent("LABEL").toggleClass("checked",true);
                        }
                        $allOtherCheckboxes.attr("checked",false).parent("LABEL").toggleClass("checked",false)
                            .end().trigger("dr-multiselectChecked");
                        $.data(multiSelect[0],"allSelected",true);
                        oThis.setDisplayText();
                    }
                });
            }
    
            // Handle OptGroup oncheck
            if(o.optGroupSelectable) {
                multiSelectOptions.addClass('optGroupHasCheckboxes');
            
                multiSelectOptions.delegate('INPUT.optGroup',"click",function(e) {
                    if ($select.triggerHandler("dr-beforeMultiselectChange", [this, multiSelectOptions]) === false) {
                        return false;
                    }                    
                    // update all the child checkboxes
                    var isChecked = this.checked;
                    var $checkedOptGroupChildren = $(this).parent().next().find('INPUT:checkbox').attr('checked', isChecked);
                    for (var i = 0; i < $checkedOptGroupChildren.length; i++) {
                        oThis.updateSelected( $($checkedOptGroupChildren[i]) );
                    }
                    $checkedOptGroupChildren.trigger("dr-multiselectChecked").parent("LABEL").toggleClass('checked', isChecked);
                    this.defaultChecked = isChecked;
                });
            }
            
            // Handle all checkboxes
            multiSelectOptions.delegate('INPUT',"click", function(e) {
                var $this = $(this);
                if ($this.hasClass("multiSelectAll") === false && $this.hasClass("optGroup") === false) {
                    if ($select.triggerHandler("dr-beforeMultiselectChange", [this, multiSelectOptions]) === false) {
                        return false;
                    }
                    // set the label checked class
                    $this.parent("LABEL").toggleClass('checked', $this.attr('checked'));
                    
                    oThis.updateSelected(e.target);
                    if($this.parent().parent().hasClass('optGroupContainer')) {
                        oThis.updateOptGroup($(this).parent().parent().prev());
                    }
                    $this.trigger("dr-multiselectChecked");
                    if( callback ) {
                        callback($this);
                    }
                }
            });
            
            // Initialize optgroups
            if(o.optGroupSelectable) {
                multiSelectOptions.delegate('LABEL.optGroup',"click",function(e) {
                    oThis.updateOptGroup($(this));
                });
            }
            // Keyboard
            $(document).unbind(".multiselectClick").bind("keydown.multiselectClick",function(e) {
                //Get the open multiSelect.
                var multiSelectParent = $(".multiSelectOptions:visible");
                if (multiSelectParent.length === 0) {
                    return;
                }
                var multiSelectOptions = multiSelectParent.data().snapTo_options.anchor.data().config.multiSelectOptions;
                var multiSelect = multiSelectParent.data().snapTo_options.anchor.data().ms.multiSelect;
    
                // Is dropdown visible?
                if( multiSelectOptions.is(":visible")) {
                    // Dropdown is visible
                    // Tab
                    if( e.keyCode == 9 ) {
                        $(this).addClass('focus').trigger('click'); // esc, left, right - hide
                        $(this).focus().next(':input').focus();
                        return true;
                    }
                    
                    // ESC, Left, Right
                    if( e.keyCode == 27 || e.keyCode == 37 || e.keyCode == 39 ) {
                        // Hide dropdown
                        $(this).addClass('focus').trigger('click');
                    }
                    // Down || Up
                    if( e.keyCode == 40 || e.keyCode == 38) {
                        var allOptions = multiSelectOptions.find('LABEL');
                        var oldHoverIndex = allOptions.index(allOptions.filter('.hover')) || 0;
                        var newHoverIndex = -1;
                        
                        // if there is no current highlighted item then highlight the first item
                        if(oldHoverIndex < 0) {
                            // Default to first item
                            multiSelectOptions.find('LABEL:first').addClass('hover');
                        }
                        // else if we are moving down and there is a next item then move
                        else if(e.keyCode == 40 && oldHoverIndex < allOptions.length - 1)
                        {
                            newHoverIndex = oldHoverIndex + 1;
                        }
                        // else if we are moving up and there is a prev item then move
                        else if(e.keyCode == 38 && oldHoverIndex > 0)
                        {
                            newHoverIndex = oldHoverIndex - 1;
                        }
    
                        if(newHoverIndex >= 0) {
                            $(allOptions.get(oldHoverIndex)).removeClass('hover'); // remove the current highlight
                            $(allOptions.get(newHoverIndex)).addClass('hover'); // add the new highlight
                            
                            // Adjust the viewport if necessary
                            oThis.adjustViewPort(multiSelectOptions);
                        }
                        
                        return false;
                    }
    
                    // Enter, Space
                    if( e.keyCode == 13 || e.keyCode == 32 ) {
                        var $selectedCheckbox = multiSelectOptions.find('LABEL.hover INPUT:checkbox');
                        if ($select.triggerHandler("dr-beforeMultiselectChange", [$selectedCheckbox, multiSelectOptions]) === false) {
                            return false;
                        }
                        var isChecked = !$selectedCheckbox.is(":checked"); //must be opposite since this runs before checking/unchecking
                        // Set the checkbox (and label class)
                        $selectedCheckbox.attr('checked', isChecked).parent("LABEL").toggleClass('checked', isChecked);
                        $selectedCheckbox.trigger("dr-multiselectChecked",[e.keyCode]);
                        
                        // if the checkbox was the select all then set all the checkboxes
                        if($selectedCheckbox.hasClass("multiSelectAll")) {
                            oThis.selectAll(multiSelectOptions,isChecked);
                        }
    
                        oThis.updateSelected();
                        if (e.keyCode == 13) {
                            oThis.multiSelectOptionsHide();                       
                        }
                        if (callback) {
                            callback($(this));
                        }
                        return false;
                    }
    
                    // Any other standard keyboard character (try and match the first character of an option)
                    if( (e.keyCode >= 33 && e.keyCode <= 126 || e.keyCode == 8) && $.inArray(e.keyCode, [27,37,39]) == -1) {
                        var opts = $.data(multiSelect[0],"config");
                        clearTimeout(searchTimeout);
                        var localSearchTermInput = $.data(multiSelect[0],"config").searchTermInput;
                        searchTimeout = null;
                        if (e.keyCode == 46 || e.keyCode == 8) {            
                            searchTermChars.pop();
                            e.preventDefault();
                            e.stopPropagation();
                        } else {
                            searchTermChars.push(String.fromCharCode(e.keyCode).toLowerCase());                     
                        }
                        if (searchTermChars.length === 0) {
                            localSearchTermInput.hide();
                        }
                        // find the next matching item after the current hovered item
                        var match = multiSelectOptions.find('LABEL:startsWith(' + searchTermChars.join("") + ')');
                        
                        var currentHoverIndex = match.index(match.filter('LABEL.hover'));
                        
                        // filter the set to any items after the current hovered item
                        var afterHoverMatch = match.filter(function (index) {
                            return index > currentHoverIndex;
                        });
    
                        // if there were no item after the current hovered item then try using the full search results (filtered to the first one)
                        match = (afterHoverMatch.length >= 1 ? afterHoverMatch : match).filter("LABEL:first");
                        var $allLabels = multiSelectOptions.find("LABEL");
                        if(match.length == 1) {
                            // if we found a match then move the hover
                            multiSelectOptions.find('LABEL.hover').removeClass('hover');                                
                            match.addClass('hover');
                            $allLabels.removeAttr("style");
                            if (!$.browser.msie) {
                                $(match).css("font-weight", "bold !important");
                            } else {
                                $(match).attr("style","font-weight:700 !important");
                            }
                            
                            oThis.adjustViewPort(multiSelectOptions);
                        }
                        if (opts.showSearch) {
                            localSearchTermInput.text(searchTermChars.join("")).css({
                                "color": "#444",
                                "font-style":"normal"
                            });                     
    
                        }                                       
                            searchTimeout = setTimeout(function(){
                                searchTermChars = [];
                                if (opts.showSearch) {
                                    localSearchTermInput.text(searchTermDefaulText).css("color", "#888");
                                }
                                $allLabels.removeAttr("style");
                            },1000);
    
                    }
                } else {
                    // Dropdown is not visible
                    if( e.keyCode == 38 || e.keyCode == 40 || e.keyCode == 13 || e.keyCode == 32 ) { //up, down, enter, space - show
                        // Show dropdown
                        $(this).removeClass('focus').trigger('click');
                        multiSelectOptions.find('LABEL:first').addClass('hover');
                        return false;
                    }
                    //  Tab key
                    if( e.keyCode == 9 ) {
                        // Shift focus to next INPUT element on page
                        multiSelectOptions.next(':input').focus();
                        return true;
                    }
                }
                // Prevent enter key from submitting form
                if( e.keyCode === 13 ) {
                    return false;
                }
            });
            var initial_time_between_inserts = (optLength>1?150:0), time_between_inserts = initial_time_between_inserts;
            var overflowOpts = multiSelectOptions.find(".overflowOpts");
            for(var seg=1;seg < optLength;seg++) {
                time_between_inserts = initial_time_between_inserts*(Math.pow(seg,2));
                (function(t,s){
                    setTimeout(function(){
                        //innerHTML here should only be used with a segment length of 1. otherwise use append
                        overflowOpts[0].innerHTML = "<div>"+optionsHtml[s].join("")+"</div>";
                    },t);
                })(time_between_inserts,seg);
            }
            //bind when all are  done
            setTimeout(function(){
                bindOptions(multiSelectOptions,multiSelect,multiSelect.prev("select"));
                oThis.updateSelected(multiSelect);
                updateOptGroupCheckboxes(multiSelectOptions);
                oThis.built = true;
            },time_between_inserts);
        },
        selectAll : function(multiSelectOptions,doSelect) {
            var $allOpts = this.select.find("option");
            var $allMSOpts = multiSelectOptions.find('INPUT');
            var opts = $allMSOpts.attr("checked",doSelect).parent("LABEL").toggleClass('checked', doSelect).end();
            if (doSelect) {
                $allOpts.attr("selected",true);
            } else {
                $allOpts.attr("selected", false).removeAttr("selected");
            }
            this.select.trigger("change");
            this.updateSelected();
            for (var i = 0; i < $allMSOpts.length; i++) {
                this.select.trigger("dr-afterMultiselectChange", [$allMSOpts[i], multiSelectOptions]);
            }
        },
        adjustViewPort: function(multiSelectOptions) {
            // check for and move down
            var selectionBottom = multiSelectOptions.find('LABEL.hover').position().top + multiSelectOptions.find('LABEL.hover').outerHeight();
            
            if(selectionBottom > multiSelectOptions.innerHeight()){     
                multiSelectOptions.scrollTop(multiSelectOptions.scrollTop() + selectionBottom - multiSelectOptions.innerHeight());
            }
            
            // check for and move up                        
            if(multiSelectOptions.find('LABEL.hover').position().top < 0){      
                multiSelectOptions.scrollTop(multiSelectOptions.scrollTop() + multiSelectOptions.find('LABEL.hover').position().top);
            }
        },
        updateOptGroup: function(optGroup) {
            var multiSelect = $(this.multiSelect);
            var o = $.data(multiSelect[0],"config");
            // Determine if the optgroup should be checked
            if(o.optGroupSelectable) {
                var optGroupSelected = true;
                $(optGroup).next().find('INPUT:checkbox').each( function() {
                    if( !$(this).attr('checked') ) {
                        optGroupSelected = false;
                        return false;
                    }
                });
                
                $(optGroup).find('INPUT.optGroup').attr('checked', optGroupSelected).parent("LABEL").toggleClass('checked', optGroupSelected);
            }
        },
        uncheckAllInvisibly: function() {
            var multiSelect = $(this.multiSelect);
            var multiSelectOptions = $.data(multiSelect[0],"config").multiSelectOptions;
            multiSelectOptions.find("input:checked").not(".multiSelectAll").attr("checked",false)
                .parent("label").removeClass("checked");
            /*
             * set the default values to avoid showing up in the beacon change checker. normally this is taken care of in the dr-multiselectChecked event handler
             * but multiSelectOptions will not be bound at this point
            */
            var $select = multiSelect.prev();
            var allInputs = multiSelectOptions.find("input:not(.multiSelectAll)");
            for(var i =0; i < allInputs.length;i++) {
                var opt = allInputs[i];
                if (opt.defaultChecked !== false) {
                    opt.defaultChecked = false;
                    $select.find("option:eq("+ $(opt).index() +")")[0].defaultSelected = false;    
                    $(opt).trigger("dr-multiselectChecked");
                }
            }
        },
        updateSelected: function(clickedCheckbox) {
            var oThis = this;
            var multiSelect = $(this.multiSelect);
            var multiSelectOptions = $.data(multiSelect[0],"config").multiSelectOptions;
            var o = $.data(multiSelect[0],"config");
            var i = 0;
            var selectAll = true;
            var clicked = false;
            var display = '';
            multiSelectOptions.find('INPUT').not('.multiSelectAll, .optGroup').each(function() {
                if ($(this).attr('checked')) {
                    clicked = true;
                    i++;
                    display = display + $(this).parent().text() + ', ';
                } else {
                    selectAll = false;
                }
            });
            if (o.isSearchFilter && !clicked && !selectAll) {
                selectAll = true;
            }
            // trim any end comma and surounding whitespace
            display = display.replace(/\s*\,\s*$/,'');
            var $span = multiSelect.find("span");
            if( i === 0 ) {
                var noneSelected = (o.noneSelected === true) ? o.selectText + " " + multiSelect.prev().attr("title") : (typeof o.noneSelected === "string") ? o.noneSelected : "&nbsp;";
                $span.html(noneSelected);
            } else {
                if( o.oneOrMoreSelected == '*' ) {
                    $span.html( display );
                    multiSelect.attr( "title", display );
                } else {
                    $span.html( o.oneOrMoreSelected.replace('%', i) );
                }
            }
            // Determine if Select All should be checked
            //Handling 3 situations
            //1. normal multiselect functionality
            //2. search filtler is on, when all checkboxes are checked, deselect all and use 'All' as display text, effectively passing "" as the selected values
            //3. same as 2, special case when there are only 2 or less options.
            var setCheckAllBox = function($multiSelectAllBox,doCheck) {
                $multiSelectAllBox.attr("checked",doCheck).parent("LABEL");
                if (doCheck) {
                    $multiSelectAllBox.parent("LABEL").addClass("checked"); 
                }
            };
            if(o.selectAll) {
                var $multiSelectAllBox = multiSelectOptions.find('INPUT.multiSelectAll');
                if (!o.isSearchFilter) {
                    $multiSelectAllBox.attr('checked', selectAll).parent("LABEL").toggleClass('checked', selectAll);
                } else {
                    if (multiSelectOptions.find("LABEL").length > 2) {
                        $multiSelectAllBox.attr("checked", selectAll);
                        $multiSelectAllBox.parent("LABEL").toggleClass("checked", selectAll);
                        $.data(multiSelect[0],"allSelected", selectAll);
                        if (selectAll || !clicked) {
                            oThis.setDisplayText();
                            oThis.uncheckAllInvisibly.call(this);
                        }
                    } else {
                        var $oneCheckbox = multiSelectOptions.find("input:not(.multiSelectAll)");
                        clickedCheckbox = (!clickedCheckbox) ? multiSelectOptions.find("input:not(.multiSelectAll)") : clickedCheckbox;
                        var checked = $(clickedCheckbox).attr("checked");
                        if ($(clickedCheckbox).hasClass("multiSelectAll")) {
                            multiSelectOptions.find("input").attr("checked", false).parent("LABEL").addClass('checked');    
                            setCheckAllBox($multiSelectAllBox,true);                    
                        } else {
                            checked = ($multiSelectAllBox.attr("checked") && !$oneCheckbox.attr("checked"));
                            setCheckAllBox($multiSelectAllBox,((checked) ? checked : !checked));
                        }
                        if ($multiSelectAllBox.attr("checked")) {
                            oThis.setDisplayText();
                        }
                    }               
                }
                $multiSelectAllBox[0].defaultChecked = $multiSelectAllBox.attr("checked");
                
            }
        },
        getOption: function(opt) {
            return this.options[opt];
        },
        setDisplayText: function(opts) {
            opts = opts || [];
            var text = [], textToDisplay = "", optionsLength = 0;
            for (var i = 0; i < opts.length;i++) {
                if (typeof opts[i].optgroup === "string") {
                    for (var j = 0; j < opts[i].options.length; j++) {
                        optionsLength++;
                        if (opts[i].options[j].selected === true) {
                            text.push(opts[i].options[j].text);
                        }               
                    }   
                } else {
                    optionsLength++;
                    if (opts[i].selected === true) {                        
                        text.push(opts[i].text);
                    }               
                }

            }
            var display = this.multiSelect.find("span");
            if (this.getOption("isSearchFilter")) {
                if (optionsLength === text.length || text.length === 0) {
                    textToDisplay = this.options.searchFilterAllText;
                } else {
                    textToDisplay = text.join(", ");                    
                }
            } else {
                textToDisplay = text.join(", ");
            }
            if (textToDisplay.trim() === "" && this.options.noneSelected && typeof this.options.noneSelected === "string") {
                textToDisplay = this.options.noneSelected;
            } else if (this.options.noneSelected === true) {
                textToDisplay = this.options.selectText + " " + this.select.attr("title");
            }
            display.html(textToDisplay || "&nbsp;");
            
        },
        checkWidth: function(multiSelect,multiSelectOptions) {
            if (parseInt(multiSelectOptions.width(),10) === 0) {
                var borderWidth = parseInt(multiSelect.css("borderLeftWidth"),10) + parseInt(multiSelect.css("borderRightWidth"),10);
                multiSelectOptions.width(multiSelect.outerWidth() - (borderWidth || 0) +"px");
            }
        },
        checkMultiSelectOptionsPosition: function(multiSelect, multiSelectOptions){
            if (Math.abs(multiSelect.offset().top - multiSelectOptions.offset().top) !== (multiSelect.height()+1)) {
                this.multiSelectReposition();
            }
        },
        multiSelectOptionsHide: function() {
            var multiSelect = this.multiSelect;
            if (multiSelect.hasClass("active")) {
                var o = $.data(multiSelect[0],"config");
                $(this.select).trigger("dr-beforeClose.multiSelect");
                multiSelect.removeClass('active').removeClass('hover');
                o.multiSelectOptions.hide();
                if (o.showSearch) {
                    o.searchTermInput.hide();
                }
                $(document).unbind(".closeMultiselect");
            }
        },
        multiSelectOptionsUpdate: function(select) {
            this.buildOptions(collectMultiSelectOptions(select));
        },
        multiSelectOptionsShow: function() {
            $(".multiselect").dr.multiselect.close();
            var multiSelect = $(this.multiSelect);
            var multiSelectOptions = $.data(multiSelect[0],"config").multiSelectOptions;
            this.checkWidth(multiSelect,multiSelectOptions);
            // Hide any open option boxes
            multiSelectOptions.show();
            this.multiSelectReposition(function(){
                multiSelect.addClass('active');
            });
            var oThis = this;
            $(document).bind("click.closeMultiselect",function(event) {
                // If somewhere outside of the multiselect was clicked then hide the multiselect
                if(!($(event.target).parents().andSelf().is('.multiSelectOptions, .multiselectSearchTerms'))) {
                   oThis.multiSelectOptionsHide();
                }
            });
            
        },
        multiSelectReposition : function(callback) {
            var multiSelect = $(this.multiSelect);
            var oThis = this;
            var multiSelectOptions = $.data(multiSelect[0],"config").multiSelectOptions;
            $(multiSelectOptions[0]).one("dr-afterPosition",function(){
                if ($.data(multiSelect[0],"config").showSearch) {
                    var searchTermInput = $.data(multiSelect[0],"config").searchTermInput.show();
                    removeIEShadow(searchTermInput);
                    searchTermInput.show();
                    searchTermInput.width(multiSelectOptions.width() - 6);
                        var mso = multiSelectOptions[0];
                        $(searchTermInput[0]).one("dr-afterPosition",function(){ 
                            reapplyIEShadow(multiSelectOptions);
                            reapplyIEShadow(searchTermInput);
                        });
                        $(searchTermInput[0]).dr.snapTo(mso,{
                            position: "t-b",
                            keepInView: false,
                            inline:false
                        });
                }
                if ($.isFunction(callback)) {
                    callback.call(oThis);
                }
            });
            removeIEShadow(multiSelectOptions);
            $(multiSelectOptions[0]).dr.snapTo(this.multiSelect,{
                position: "tl-bl",
                offset: {y:0,x:0},
                inline:false,
                preferredAltPositions:["bl-tl","l-r","r-l"]
            });
        },
        selectedTextString: function() {
            return $(this.select).find("option").map(function(i,e){
                if (this.selected === true) {
                    return $(this).text().trim();
                }
            }).get().join(",");
        },
        selectedValuesString: function() {
            return $(this.select).find("option").map(function(i,e){
                if (this.selected === true) {
                    return $(this).val().trim();
                }
            }).get().join(",");
        }
        
    };
    
    // add a new ":startsWith" search filter
    $.expr[":"].startsWith = function(el, i, m) {
        var search = m[3];        
        if (!search) return false;
        return eval("/^[/s]*" + search + "/i").test($(el).text());
    };


    requestSent = false;
    function collectMultiSelectOptions(select) {
        var options = [], i = 0;
        $(select).children().each( function() {
            if(this.tagName.toUpperCase() == 'OPTGROUP') {
                var suboptions = [];
                options.push({ optgroup: $(this).attr('label'), options: suboptions });
                
                $(this).find('OPTION').each( function() {
                    if( $(this).val() !== '' ) {
                        suboptions.push({ text: $(this).html(), value: $(this).val(), selected: $(this)[0].selected, index:i});
                    }
                    i++;
                });
            } else if(this.tagName.toUpperCase() == 'OPTION') {
                if( $(this).val() !== '' ) {
                    options.push({ text: $(this).html(), value: $(this).val(), selected: $(this)[0].selected,index: i});
                }
                i++;
            }
        });
        return options;
    }
    $.namespace('dr', {
        multiselect: function(opts){
            $(this).each(function(){
               $.data(this,"oldSize",$(this).attr("size"));
                $(this).attr("size",1);
                var data_opts = $(this).attr("data-options");
                if (data_opts && typeof data_opts == "string") {
                    data_opts = $.dr.utils.evalString(data_opts);
                }
                if (!opts) {
                    opts = {};
                }
                var options = $.extend(true, {}, defaults, data_opts, opts);
                options.isSearchFilter = $(this).hasClass("searchFilter");
                // Initialize each multiSelect
                var oThis = this;
                var select = $(this);
                var ms = new multiselect(select,options, options.callback);
    
            });
            $selects = this;
            var inputErrorClass = "inputError";
            $selects.bind("dr-field-removeError",function(evt,errType) {
                if (!$(this).hasClass(inputErrorClass)) {
                    $(this).next().removeClass(inputErrorClass);
                }           
            }).bind("dr-field-throwError",function(evt,errType,errMsg) {
                if (!$(this).hasClass("inputFocus")) {
                    $(this).next().addClass(inputErrorClass);
                }   
            });

            return this;
        }
    }); 
    function getMultiselect() {
        var multiSelect = $(this);
        if (!multiSelect.hasClass("multiSelect")) {
            multiSelect = multiSelect.siblings(".multiSelect:first");
        }
        if (multiSelect.length <= 0 || multiSelect[0].nodeName.search("document") > -1) {
            $.dr.utils.logError("Error: can't find multiSelect element.");
            return multiSelect;
        }
        return multiSelect;     
    }
    function getMultiselectFromData(multiselect) {
        if (typeof(multiselect)!="undefined" && multiselect.length > 0 && typeof($.data(multiselect[0],"ms"))!="undefined" && $.data(multiselect[0],"ms")!=null ) {
            return $.data(multiselect[0],"ms");
        } else {
            return false;
        }
    }
    $.namespace('dr.multiselect', {
        destroy: function(){
            this.each(function(){
                var multiSelect = getMultiselect.call(this);
                var ms = getMultiselectFromData(multiSelect);
                if (ms) {
                    ms.multiSelectOptions.remove();
                    var optLength = multiSelect.prev().find("option").length;
                    var size = $.data(multiSelect.prev()[0],"oldSize") || ((optLength >= 6) ? 6 : optLength);
                    $(ms.select).removeClass("initialized").show().attr("size",size);
                    multiSelect.parent().find(".multiselectSearchTerms").remove();
                    multiSelect.removeData().remove();
                }   
            });
        },
        open: function(){
            this.each(function(){
            var multiSelect = getMultiselect.call(this);
                var ms = getMultiselectFromData(multiSelect);
                if (ms) {
                    ms.multiSelectOptionsShow();
                }           
            });
        },
        close: function(){
            for (var i =0;i<this.length;i++) {
                var multiSelect = getMultiselect.call(this[i]);
                if (multiSelect && multiSelect.length > 0) {
                    $.data(multiSelect[0],"ms").multiSelectOptionsHide();                    
                }
            }
        },
        setOptions: function(opts) {
            this.each(function(){
                var multiSelect = getMultiselect.call(this);
                var ms = getMultiselectFromData(multiSelect);
                if (ms) {
                    var select = multiSelect.prev();
                    $.extend(true,multiSelect.data("config"), opts);
                    var options = collectMultiSelectOptions(select);
                    multiSelect.data("ms").multiSelectOptionsUpdate(options);
                    $(select).trigger("dr-multiSelectUpdate");
                }               
            });
        },
        disable:function(doDisable) {
            this.each(function(){
                var multiSelect = getMultiselect.call(this);
                var ms = getMultiselectFromData(multiSelect);
                if (ms) {
                    ms.setDisabled(doDisable);
                }
            });
        },
        getSelectedValues: function() {
            var multiSelect = getMultiselect.call(this);
            var ms = getMultiselectFromData(multiSelect);
            if (ms) {
                return ms.selectedValuesString();
            }
        },
        getSelectedText: function() {
            var multiSelect = getMultiselect.call(this);
            var ms = getMultiselectFromData(multiSelect);
            if (ms) {
                return ms.selectedTextString();
            }
        },
        update: function() {
            var multiSelect = getMultiselect.call(this);
            var ms = getMultiselectFromData(multiSelect);
            if (ms) {
                ms.multiSelectOptionsUpdate(this);
            }
            return this;
        },
        isAllSelected: function() {
            var multiSelect = getMultiselect.call(this);
            var ms = getMultiselectFromData(multiSelect);
            if (ms) {
                return multiSelect.data("allSelected");
            }
        },
        getDisplayText: function() {
            var multiSelect = getMultiselect.call(this);
            var ms = getMultiselectFromData(multiSelect);
            if (ms) {
                return multiSelect.find("span").text();
            }
        }
    });
    $.dr.addDomReadyEvent(function(){
        //do validate this selector (regardless of whether it is visible or not)
        $.dr.form.addValidationSelector("select[multiple].multiselect");
    });
    
    var addMultiSelects = function($fields){
        var $selects = $fields.filter("form select[multiple].multiselect").not(".initialized");
        if ($selects.length > 0) {
            $selects.each(function(){
                var $select = $(this);
                $select.dr.multiselect();
                $select.data("conditionalValidation", (function(field){
                    //form validation will ignore the multiselect widget if this returns false (ie, whether it's hidden or not)
                    //if the fake multiselect is visible it will be validated
                    return $(field).next("a.multiSelect").is(":visible");
                }));
            });
        }
    };
    $.dr.addPlugin('form', addMultiSelects);    
})(jQuery);
;
/**
 * A standalone widget for handling the paging of datasets.
 * copyright 2012 Digital River, Inc. All rights reserved.
 *
 * @author: Christopher Pryce<cpryce@digitalriver.com>
 */
(function($) {
    var messages = {
        NO_ITEMS_IN_LIST: 'No Items in List'
    }
    /**
     * sets the value of the current page input in the pagination area.
     * 
     * @param {Number} p The current page
     * @param {Number} totalPages The total number of pages
     */
    var setPageInput = function(p, totalPages, enabled) {
        var $pi = $('.pageInput', this);
        if ($pi.length) {
            var $input = $pi.find(':text');
            $input.val(p)[0].disabled = totalPages < 2 ? true : !enabled;
            $input.get(0).defaultValue = p;
            $pi.find('.totalPages').text(totalPages.toString());
        }
    };
    
    /**
     * Sets the classnames on the paging icons and calls setPageInput
     * 
     * @param {Number} p The current page
     * @param {Number} totalPages The number of pages
     * @param {Boolean} enabled A flag to set the controls as disabled or not. undefined === true;
     */
    var setPaginationControls = function(p, totalPages, enabled) {
        if (enabled == null) {
            enabled = true;
        }
        if (enabled) {
            $('.next, .prev, .last, .first', this).removeClass('off');
            if (p === 1) {
                $('.prev, .first', this).addClass('off');
            }
    
            if (totalPages < 2 || p === totalPages) {
                $('.next, .last', this).addClass('off');
            }
            setPageInput.call(this, p, totalPages, enabled);            
        } else {
            $('.next, .prev, .last, .first', this).addClass('off');
            setPageInput.call(this, p, totalPages, enabled);
        }
    };
    
    /**
     * Set the values of the item counts (1-x of x)
     * 
     * @param {String} start
     * @param {String} last
     * @param {String} count
     * @param {String} totalPages
     */
    var setItemCounts = function(start, last, count, totalPages) {
        if (count > 0) {
            $('.noItemCounts', this).hide();
            $('.items', this).show();
            $('.firstItem', this).text(start);
            $('.lastItem', this).text(last);
            $('.totalItems', this).text(count);
            $('.totalPages', this).text(totalPages);
        } else {
            $('.totalPages', this).text(totalPages);
            $('.noItemCounts', this).show();
            $('.items', this).hide();
        }
    };
    var enableControls = function(pager) {
        pager.enabled = true;
        setPaginationControls.call(this, pager.currentPage, pager.getTotalPages(), pager.enabled);
    };
    
    var disableControls = function(pager) {
        pager.enabled = false;
        setPaginationControls.call(this, pager.currentPage, pager.getTotalPages(), pager.enabled);
    };
    /**
     * Insert the HTML elements for the item counts
     * 
     * @param {String} start
     * @param {String} last
     * @param {String} count
     * @param {Boolean | null/undefined} mini
     */
    var insertItemCounts = function(start, last, count, mini) {
        var sb = ['<div class="left">'];
        sb.push('<div class="items"><span class="firstItem">');
        sb.push(start || "");
        sb.push('</span>&nbsp;-&nbsp;<span class="lastItem">');
        sb.push(last || "");
        sb.push('</span>');
        sb.push('&nbsp;of&nbsp;<span class="totalItems">');        
        sb.push(count || "");
        sb.push('</span>');
        if (mini == null) {
            sb.push('&nbsp;items');
        }
        sb.push('</div>');
        sb.push('<div class="noItemCounts" style="display: none">' + messages.NO_ITEMS_IN_LIST + '</div>');
        sb.push('</div>');
         var $left = $(sb.join("")).appendTo(this);
        return $left.get(0);
    };
    /**
     * Inserts the pagination icons and text input.
     *  
     * @param {Boolean} mini optional. If true some elements are not drawn.
     */
    var insertPagination = function(opts) {
        
        var sb = [];
        sb.push('<div class="pagination">');
        
        if (!opts.mini) {
            sb.push('<a onclick="return false;" href="#" title="First Page" class="first off"></a>');
        }
        sb.push('<a onclick="return false;" href="#" title="Previous Page" class="prev off"></a>');
        if (!opts.mini) {
            sb.push('<span>Page</span>');
            sb.push('<span class="pageInput"><input class="currentPage" disabled="disabled" name="page" value="" autocomplete="off" /></span>');
            sb.push('<span>of <strong class="totalPages"></strong></span>');
        }
        sb.push('<a href="#" onclick="return false;" title="Next Page" class="next"></a>');
        
        if (!opts.mini) {
            sb.push('<a href="#" onclick="return false;" title="Last Page" class="last"></a>');
        }
        sb.push('</div>');

        if (opts.insert == 'before') {
            return $(sb.join("")).prependTo(this).get(0);
        }
        return $(sb.join("")).appendTo(this).get(0);
    };
    
    /**
     * Called on set and on each page change. Recalculates item and page counts
     * 
     * @return {Object} The new adjusted item counts as a key-value object. Returns
     *                  undefined if totalItems is not defined.
     */
    var refreshItemCount = function() {
        // get the total item count
        var count = this.getTotalItems();
        var pageSize = this.getTotalItemsPerPage();
        var totalPages = this.getTotalPages();
        var currentPage = this.currentPage;
        var start = this.firstItem;
        var last;
        var returnValue;
        
        if (count != null) {
            if (start == null) {
                start = (pageSize * (currentPage - 1));
                start = (this.options.zeroBasedPaging) ? start : start + 1;
                this.setFirstItem(start);
            }
            
            last = ((this.firstItem + pageSize) - 1);
            if (last > count) {
                last = count;
            }
            this.lastItemOnPage = last;
            returnValue = {
                firstItem: this.firstItem,
                last: last,
                totalItems: count,
                totalPages: totalPages
            };
        } 
        return returnValue;
    };
    /**
     * Calculates and sets the totalItemsPerPage property from totalItems / totalpages
     * 
     * @param {Number} totalPages
     */
    var setPageSizeFromTotalPages = function(totalPages) {
        var count = this.getTotalItems();
        if (count != null && totalPages !== 0) {
            this.setTotalItemsPerPage(Math.ceil(count / totalPages));
        }
    };
    /**
     * Calculates and returns the total number of pages 
     */
    var calculateTotalPages = function() {
        var count = this.getTotalItems(), pageSize = this.getTotalItemsPerPage(), pages;
        if (count != null && pageSize != null && pageSize > 0) {
            pages = Math.floor(count / pageSize);
            if (count % pageSize) {
                pages += 1;
            }
        } else {
            pages = 1;
        }
        return pages;
    };
    /**
     * Sets the firstItemOnPage value by calculating it from currentPage, itemsPerPage and totalItems.
     * 
     * @param {Number} p
     */
    var setStartFromCurrentPage = function(p) {
        var count = this.getTotalItems();
        var pageSize = this.getTotalItemsPerPage();
        var start;
        p = this.options.zeroBasedPaging ? p + 1 : p;
        
        if (p === 1) {
            start = this.options.zeroBasedPaging ? 0 : 1;
        } else {
            if (count != null && pageSize != null) {
                start = (pageSize * (p - 1));
                start = (this.options.zeroBasedPaging) ? start : start + 1;
            }
        }
        
        if (start) {
            this.setFirstItem(start);
        }
    };
    /**
     * Executes the changePageCallback
     * and triggers the dr-changepage-page event.
     * 
     * @param {Number} p The page the new currentPage
     * @param {Number} op The original page
     * @param {Object} pager The pager object
     */
    var triggerCallbacks = function(p, op, pager) {
        $(this).trigger('dr-changepage-pager', [p, op, pager]);
    };
    /**
     * Set as the click handler by the setupContainer function. Responds to user
     * clicks on interface items.
     *
     * @param {jQuery Event} evt The jQuery event object
     * @param {Object} pager The pager object
     */
    var handleClick = function(evt, pager) {
        var className = evt.target.className;
        var pages, p;
        var op = pager.currentPage;    // store the current page
        
        if (evt.target.tagName.toLowerCase() === 'a') {
            // handle clicks only on certain elements
            if (pager[className] !== undefined && $.isFunction(pager[className])) {
                // if the method exists, call the method
                pages = pager[className].apply(pager);
                if (pages && pages.currentPage !== op) {
                    if ($(this).drTriggerEach('dr-beforechange-pager', [evt, pager.currentPage, pager.previousPage, pager]) !== false) {
                        // the current page was updated. Update the UI and trigger callbacks.
                        p = pages.currentPage;
                        op = pages.previousPage;
                        
                        setItemCounts.call(this, pager.firstItem, pager.getLastItem(), pager.getTotalItems(), pager.getTotalPages());
                        setPaginationControls.call(this, pager.currentPage, pager.getTotalPages(), pager.enabled);
                        triggerCallbacks.call(this, p, op, pager);
                    } else {
                        // change was canceled.
                        pager.changePage(op);
                        setPaginationControls.call(this, pager.currentPage, pager.getTotalPages(), pager.enabled);
                    }
                }
            }
        }
    };
    /**
     * Called by the public changePage function. Does bounds checking
     *
     * @param {String|Number} p The new page requested
     * @returns {Number} The number of the new page requested adjusted 
     *                   to be in bounds of the request set. Returns 
     *                   undefined if argument p cannot be parsed as an Integer
     *                   
     * 
     */
    var setPage = function(p) {
        // check the page for bounds. 
        p = parseInt(p, 10);
        if (!isNaN(p)) {
            if (p < 1) {
                p = 1;
            }
            
            if (p > this.getTotalPages()) {
                p = this.getTotalPages();
            }
            this.currentPage = p;
        }
        return (isNaN(p)) ? undefined : p;
    };
    /**
     * Responds to keypress events fron the UI. Set in setupContainer.
     *
     * @param {jQuery Event} evt jQuery  Event object
     * @param {Object} pager The pager object
     */
    var handleInput = function(evt, pager) {
        var p = parseInt(evt.target.value, 10);
        var op = pager.currentPage;
        var changedPages;
        
        if (isNaN(p) || p < 0) {
            $.dr.alert("Please enter a valid number.");
            evt.target.select();
            evt.target.value = op;
        } else {
            var evt = jQuery.Event('dr-beforechange-pager');
            changedPages = pager.changePage(p);
            
            if (typeof changedPages !== 'undefined' && changedPages.currentPage !== op) {
                if ($(this).drTriggerEach('dr-beforechange-pager', [evt, changedPages.curentPage, changedPages.previousPage, pager]) !== false) {
                    setItemCounts.call(this, pager.firstItem, pager.lastItemOnPage, pager.totalItems, pager.getTotalPages());
                    setPaginationControls.call(this, changedPages.currentPage, pager.getTotalPages(), pager.enabled);
                    triggerCallbacks.call(this, changedPages.currentPage, op, pager);
                } else {
                    // Change was canceled. Reset the page 
                    pager.changePage(op);
                }
            } else {
                setPaginationControls.call(this, op, pager.getTotalPages(), pager.enabled);
            }
        }
        // prevent default and cancel propagation
        return false;
    };
    
    /**
     * Called once to set or calculate the initial value of totalItems. If 
     * totalItems can be set, removes the option from the object
     * 
     * @param {Object} o The object passed to the initToolbar constructor holding
     *                   constructor options
     */
    var doSetInitialCount = function(o) {
        // tests for != null is a convenience. matches null or undefined.
        if (o.totalItems != null) {
            this.setTotalItems(o.totalItems);
            delete o.totalItems;
        } else {
            if (o.totalPages && o.totalItemsPerPage) {
                this.setTotalItems(o.totalPages * o.totalItemsPerPage);
            }
        }
        return o;
    };
    /**
     * Called once to set or calculate the initial value for pageSize.
     * 
     * @param {Object} o The object passed to the initToolbar constructor holding
     *                   constructor options
     */
    var doSetInitialPageSize = function(o) {
        var count = this.getTotalItems();
        
        // set the page size. Default is 25
        if (o.totalItemsPerPage != null) {
            // check bounds.. 
            var ti = parseInt(o.totalItemsPerPage);
            if (! isNaN(ti) && count != null) {
                if (ti > count) {
                    ti = count;
                }
            }
            this.setTotalItemsPerPage(ti);
            delete o.totalItemsPerPage;
        } else {
            if (o.totalPages) {
                setPageSizeFromTotalPages.call(this, o.totalPages);
            }
        }
        return o;
    };
    /**
     * Called once to set or calculate the totalPages property.
     * 
     * @param {Object} oThe object passed to the initToolbar constructor holding
     *                   constructor options
     */
    var doSetInitialTotalPages = function(o) {
        var count = this.getTotalItems();
        // set the number of pages
        if (o.totalPages != null) {
            var tp = parseInt(o.totalPages, 10);
            if (! isNaN(tp) && count != null) {
                if (count = 0) {
                    tp = 1;
                }
            }
            this.setTotalPages(tp);
            delete o.totalPages;
        } else {
            this.setTotalPages(calculateTotalPages.call(this));
        }
        return o;
    };
    /**
     * Does the bulk of the initial container setup; inserts
     * HTML elements for paging if they are not present.
     *
     * @param {Object} pager The pager object
     */
    var setupContainer = function(pager) {
        var container = this;
        var $container = $(this);
        
        // insert the html 
        var $pagination = $container.find('.pagination');
        if ($pagination.length === 0) {
            var opts = {
                mini: pager.getOption("mini"),
                insert: pager.getOption("insert")
            };
            insertPagination.call(container, opts);
        }
        
        var $left = $container.find('.left');
        if ($left.length === 0) {
            insertItemCounts.call(container, pager.firstItem, pager.lastItemOnPage, pager.getTotalItems(),  pager.getOption("mini"));
        }
        
        $container.addClass('initialized');
    };
    /**
     * Sets or calculates the initial setting for the first page.
     * 
     * @param {Number} p
     */
    var setInitialPage = function(p) {
        var start = this.getFirstItem();
        var pageSize = this.getTotalItemsPerPage();
        
        if (p == null) {
            if (start === 0) {
                p = 1;
            } else if (start > 0 && pageSize) {
                p = Math.floor(start / pageSize) + 1;
            } else {
                p = 1; // pageSize should always be set
            }
        } else {
            p = this.options.zeroBasedPaging ? p + 1 : p;
        }
        
        this.currentPage = p;
        return this.currentPage;
    };
    /**
     * Called by the constructor and by the reset method. Sets/resets initial
     * counts.
     * if the widget has not been initialized.
     *
     * @param {Object} options
     */
    var initToolbar = function(options) {
        var start;
        var o = $.extend(true, {}, options);
        
        o = doSetInitialCount.call(this, o);
        o = doSetInitialPageSize.call(this, o);
        o = doSetInitialTotalPages.call(this, o);
        
        // set a temporary variable to hold the start until options are set
        if (o.firstItem != null) {
            start = parseInt(o.firstItem, 10);
            if (isNaN(start)) {
                start = undefined;
            }
            delete o.firstItem;
        }
        
        this.setOptions(o);
        
        if (start != null) {
            this.setFirstItem(start);
        } else {
            if (o.currentPage) {
                setStartFromCurrentPage.call(this, o.currentPage);
            }
        }
        
        // set the current page. if the argument is undefined, calculate it from start and pagesize
        setInitialPage.call(this, o.currentPage);
        
        // sets class styles and disables or enables the input field
        return refreshItemCount.call(this);
    };
    /**
     * Called from a blur event on the currentPage input element. Resets the 
     * value to current page on blur.
     * 
     * @param {Object} pager
     */
    var resetInput = function(pager) {
        $(this).val(pager.currentPage);
    };
    /**
     * The Public constructor function. Takes two required arguments, an object to provide
     * optional settings, in key value pairs. Currently totalItemsOnPage is the only required
     * option. The second argument is a DOM Element, the containing element where the the toolbar
     * is inserted. If container is blank, no paging elements will be inserted and no update
     * of paging elements will take place. This can be useful for a paging element that is not displayed.
     *
     * @param {Object} options The constructor options
     */
    $.dr.Pager = function(options) {
        if (typeof options === "undefined") {
            options = {};
        }
        this.options = {
            zeroBasedPaging: false
        };
        this.currentPage = 1;
        this.totalPages = null; // holds the number of pages. Default is to calculate from pageSize and count
        // first item on the page
        this.firstItem = this.options.zeroBasedPaging ? 0 : 1;
        
        // holds the total item count. if it is blank, no math is done.
        this.totalItems = null;
        
        // holds the size of a page. if it is blank, no math is done.
        this.totalItemsPerPage = 25;
        initToolbar.call(this, options || {});
    };
    /**
     * Public methods on the Pager Object.
     */
    $.dr.Pager.prototype = {
        /**
         * Called to reset the paging elements of a Pager, perhaps after a data
         * load. Takes the same arguments as the constructor.
         *
         * @param {Object} options
         * @param {DOMElement} container
         */
        reset: function(options) {
            try {
                return initToolbar.call(this, options);
            } catch (e) {
                return undefined;
            }
        },
        /**
         * Reserved for future development
         */
        destroy: function() {
        
        },
        /**
         * Called in response to a user clicking an interface element.
         */
        first: function() {
            var op = this.currentPage;
            return this.changePage(1, op);
        },
        /**
         * Called in response to a user clicking an interface element.
         */
        last: function() {
            var op = this.currentPage;
            return this.changePage(this.getTotalPages(), op);
        },
        /**
         * Called in response to a user clicking an interface element.
         */
        next: function() {
            var op = this.currentPage;
            return this.changePage(op + 1, op);
        },
        /**
         * Called in response to a user clicking an interface element.
         */
        prev: function() {
            var op = this.currentPage;
            return this.changePage(op - 1, op);
        },
        /**
         * Called to get/set the value of the firstItem on the page. On set, if
         * val cannot be parsed as an Integer, the call fails silently.
         *
         * @param {String|Number} val The value of the first Item.
         */
        setFirstItem: function(val) {
            var v = parseInt(val, 10);
            if (!isNaN(v)) {
                this.firstItem = this.options.zeroBasedPaging ? v + 1 : v;
            }
        },
        
        getFirstItem: function() {
            return this.options.zeroBasedPaging ? this.firstItem - 1 >= 0 ? this.firstItem - 1 : this.firstItem : this.firstItem;
        },
        
        getLastItem: function() {
            return this.lastItemOnPage;
        },
        /**
         * Called to initiate the change of the current page. Any calls to directly
         * change the page (i.e., not from a user click) should use this method.
         * Most often called by the plugin.
         *
         * @param {String|Number} np
         * @param {String|Number} op
         */
        changePage: function(np, op) {
            var p = setPage.call(this, np);
            var pages;
            if (p && p !== op) {
                this.firstItem = null;
                refreshItemCount.call(this);
                pages = {
                    currentPage: p,
                    previousPage: op
                };
            }
            return pages;
        },
        /**
         * Retrieves the value of the current page. If zeroBasedPaging is
         * set true, the current page is one less than the value shown to
         * the user.
         */
        getCurrentPage: function() {
            return (this.options.zeroBasedPaging) ? (this.currentPage - 1 >= 0) ? this.currentPage - 1 : this.currentPage : this.currentPage;
        },
        /**
         * Sets/Gets the total number of items in the data set.
         * If val cannont be parsed as an integer, fails silently
         * @param {String|Number} val
         */
        setTotalItems: function(val) {
            var v = parseInt(val, 10);
            if (!isNaN(v)) {
                this.totalItems = v;
            }
        },
        
        getTotalItems: function() {
            return this.totalItems;
        },
        
        setTotalItemsPerPage: function(val) {
            var v = parseInt(val, 10);
            if (!isNaN(v)) {
                this.totalItemsPerPage = v;
            }
        },
        
        getTotalItemsPerPage: function() {
            return this.totalItemsPerPage;
        },
        
        setTotalPages: function(val) {
            var v = parseInt(val, 10);
            if (!isNaN(v)) {
                this.totalPages = v;
            }
        },
        
        getTotalPages: function() {
            return this.totalPages;
        },
        
        setOptions: function(o) {
            this.options = $.extend(true, {}, this.options, o);
        },
        
        getOptions: function() {
            return this.options;
        },
        
        setOption: function(k, v) {
            this.options[k] = v;
        },
        
        getOption: function(k) {
            return this.options[k];
        }
    };
    /**
     * The plugin definition
     *
     * @param {Object} userOptions
     */
    $.namespace('dr', {
        pager: function(userOptions) {
            return this.each(function() {
                var oThis = this;
                var $this = $(this);
                var pager = $this.data('toolbar');
                
                if (pager == null) { // null or undefined
                    pager = new $.dr.Pager(userOptions, this);
                    $this.data({'options': userOptions, toolbar: pager});
                }
                
                if (!$(this).hasClass('initialized')) {
                    if (userOptions.mini) {
                        $(this).addClass('mini');
                    }

                    if ($.isFunction(userOptions.beforeChangeCallback)) {
                        $(this).dr.bindPluginEvent('dr-beforechange-pager', userOptions.beforeChangeCallback);
                    }

                    if ($.isFunction(userOptions.changePageCallback)) {
                        $(this).dr.bindPluginEvent('dr-changepage-pager', userOptions.changePageCallback);
                    }

                    setupContainer.call(this, pager);

                    // add event handlers
                    $('.pagination', this).bind('click.pager', function(evt) {
                        handleClick.call(oThis, evt, pager);
                    }).bind('keypress.pager', function(evt) {
                        if (evt.keyCode === 13) { // enter key
                            handleInput.call(oThis, evt, pager);
                        }
                    }).delegate('.pageInput > input', 'blur', function(evt) {
                        if (userOptions.changeOnBlur) {
                            handleInput.call(oThis, evt, pager);
                        } else {
                            resetInput.call(this, pager);
                        }
                    });
                }
                
                //return {firstItem: this.firstItem, last: last, totalItems: count, totalPages: totalPages};  
                var itemCounts = refreshItemCount.call(pager);
                if (typeof itemCounts !== "undefined") {
                    setItemCounts.call(this, itemCounts.firstItem, itemCounts.last, itemCounts.totalItems, itemCounts.totalPages);
                }
                setPaginationControls.call(this, pager.currentPage, pager.getTotalPages(), pager.enabled);
            });
        }
    });
    
    $.dr.utils.createPluginEvents('dr.pager', ['dr-beforechange-pager', 'dr-changepage-pager']);
    
    /** 
     * Determines from the arguments if there exists a method
     * tha can be called. Calls the method, setting the appropriate
     * scope.
     */
    var method = function() {
        var args = [].slice.call(arguments);
        var methodReturnValue;
        var command = args.shift();
        
        this.each(function() {
            var tb = $(this).data('toolbar');
            if (tb && tb instanceof $.dr.Pager) {
                if ($.isFunction(tb[command])) {
                    try {
                        methodReturnValue = tb[command].apply(tb, args);
                    } catch (e) {
                        if (typeof console !== "undefined" && $.isFunction(console.error)) {
                            methodReturnValue = undefined;
                            console.error("command:", e);
                        }
                    }
                }
            }
        });
        return methodReturnValue;
    };
    
    /**
     * Public methods on the plugin.
     */
    $.namespace('dr.pager', {
        reset: function(o) {
            var pager = this.data('toolbar');
            var ic = method.call(this, "reset", o);
            if (typeof ic !== 'undefined') {
                setItemCounts.call(this, ic.firstItem, ic.last, ic.totalItems, ic.totalPages);
            }
            setPaginationControls.call(this, pager.currentPage, pager.getTotalPages(), pager.enabled);
        },
        getFirstItem: function() {
            return method.call(this, "getFirstItem");
        },
        getTotalItemsPerPage: function() {
            return method.call(this, "getTotalItemsPerPage");
        },
        getTotalItems: function() {
            return method.call(this, "getTotalItems");
        },
        getCurrentPage: function() {
            return method.call(this, "getCurrentPage");
        },
        getTotalPages: function() {
            return method.call(this, "getTotalPages");
        },
        getPager: function() {
            var tb = this.data('toolbar');
            if (tb instanceof $.dr.Pager) {
                return tb;
            }
            return undefined;
        },
        getOption: function(k) {
            var tb = $(this).dr.pager.getPager();
            if (tb) {
                return tb.getOption(k);
            }
        },
        getOptions: function() {
            var tb = $(this).dr.pager.getPager();
            if (tb) {
                return tb.getOptions();
            }
        },
        first: function() {
            var tb = $(this).dr.pager.getPager();
            if (tb && ! tb.getOption('mini')) {
                $(this).find('.first').click();
            }
        },
        prev: function() {
            $(this).find('.prev').click();
        },
        next: function() {
            $(this).find('.next').click();
        },
        last: function() {
            var tb = $(this).dr.pager.getPager();
            if (tb && ! tb.getOption('mini')) {
                $(this).find('.last').click();
            }        
        },
        enable: function(disable) {
            var tb = $(this).dr.pager.getPager();
            // if a user calls .enable(false) use disable.
            if (disable === false) {
                disableControls.call(this, tb);
                return;
            }
            enableControls.call(this, tb);   
        }, 
        disable: function() {
            var tb = $(this).dr.pager.getPager();
            disableControls.call(this, tb);
        },
        changePage: function(p) {
            var tb = this.data('toolbar');
            var op;
            
            p = parseInt(p, 10);
            if (!isNaN(p) && p > -1) {
                try {
                    op = tb.currentPage;
                    if (p !== op) {
                        pages = tb.changePage(p, op);
                        if ($(this).drTriggerEach('dr-beforechange-pager', [pages.currentPage, pages.previousPage, tb]) !== false) {
                            if (pages !== 'undefined') {
                                triggerCallbacks.call(this.get(0), p, op, tb);
                                setItemCounts.call(this, tb.firstItem, tb.lastItemOnPage, tb.totalItems, tb.getTotalPages());
                                setPaginationControls.call(this, tb.currentPage, tb.getTotalPages(), tb.enabled);
                                
                                return true;
                            }
                        } else {
                            // reset back to the original
                            tb.changePage(op, p);
                            return false;
                        }
                    } else {
                        return false; // requested the current page
                    }
                } catch (e) {
                    return false; // page change throws error
                }
            } else {
                return false; // input was not correct
            }
        }
    });
})(jQuery);

;
(function($){
	
	var imgs = [], $dialog, $span, frameTimeout, open=false, isIE6 = ($.browser.msie && $.browser.version == 6), stopEventDefined=false;

	 var options = {		
		enabled: true,
		showText: true,
		text: '\u6B63\u5728\u5904\u7406...',
		cssClass: 'processingDialog',
		imgSrc: 'sprites/spinner-sprite-36-fff',
		imgExt: 'gif',
		imgPrefix: 'bg',
		frames: 8,
		frameInterval: 90,
		beforeUnloadDelay: 2000,
		shadowVisible: true
	  };

	var position = function(){
		var $this = this;
		var windowScrollTop = $(window).scrollTop();
		var windowHeight = $(window).height();
		var windowWidth = $(window).width();
		var domElHeight = $this.height();
		var domElWidth = $this.width();
				
		var posY = (!isIE6) ? (windowHeight / 2) - (domElHeight / 2) : (windowHeight / 2) - (domElHeight / 2) + windowScrollTop;
		var posX = (windowWidth / 2) - (domElWidth / 2);
		$this.css({
			'top': posY,
			'left': posX
		});
	};
	
	var animate = function(){
		var frameIndex = 0;
		
		var func = function(test){
			if (frameIndex >= options.frames) {
				frameIndex = 0;
			}
			$span.attr('class', options.imgPrefix + frameIndex);
			frameIndex++;
			frameTimeout = setTimeout(func, options.frameInterval);
		};
		func();
	};
	
	var stopAnimate = function(){
		if (typeof(frameTimeout) != "undefined") {
			clearTimeout(frameTimeout);
		}
	};
	
	var bindEvents = function(){
		var $this = this;
		$(window).bind('resize scroll', function(){
			position.call($this);
		});
	};
	
	$.dr.processingDialog = {
		show: function(){
			if (!options.enabled || open) {
				return;
			}
			open=true;
			$dialog.show();
			animate.call($span);
			position.call($dialog);	
			bindEvents.call($dialog);
			if(!stopEventDefined && $.browser.msie && document.attachEvent){
				stopEventDefined=true;
				// IE only event - when user clicks stop button, hide the processing overlay
				document.attachEvent("onstop", $.dr.processingDialog.hide);
			}
		},
		
		hide: function(){
			open=false;
			if($dialog){
				stopAnimate();
				$dialog.hide();
			}
		},
		
		enable: function(){
			options.enabled = true;
		},
		
		disable: function(){
			options.enabled = false;
			$.dr.processingDialog.hide();
		}
	};
	
	// disable the processing dialog from being shown if the form change checker is fired.
	$(document).bind('dr-showchangeswarning', function(){$.dr.processingDialog.disable()});
	

	var init = function(){
		$dialog = $('<div class="' + options.cssClass + ' ' + options.imgPrefix + '"><span>' + options.text + '</span></div>').hide().prependTo('body');
		$span = $('span', $dialog);
		
		if (isIE6) {
			$dialog.css('position', 'absolute');
		}
		
		if (!options.showText) {
			$dialog.find('> span').addClass('hide');
		}
		
		if (options.shadowVisible) {
			$dialog.find('> span').dr.shadows();
		}
		
		// preload the images so they are ready when the page unloads
		var preloadImage = new Image();
			preloadImage.src = $.dr.IMAGE_PATH  + options.imgSrc + '.' + options.imgExt;
		
		var func = function(){
			setTimeout($.dr.processingDialog.show, options.beforeUnloadDelay);
		};
		
		$(window).bind('beforeunload', func);
	};
	
	$.dr.addDomReadyEvent(init, 'domReadyLate');
})(jQuery);

;(function($) {
	
	var defaults = {
		modal: true, //Whether or not the search picker will open in a modal or be embedded on a page
		multiSelect: false, //Whether or not search picker can select more than one option
		showTotalResults: false, //Whether or not to show the total number of results in the search picker
		url: null, //URL to reference in ajax call
		dataSet: null, //Set of items to use when not using ajax call
		paramName: 'item_name', //Parameter name to send to ajax call
		hiddenId: null, //ID attribute of hidden input
		displayValuesId: null, //ID attribute of field that will accept text names of selected items. Only required when modal is set to false 
		iconValuesId: null, //ID attribute of field that will indicate whether selected items should display an icon upon searchPicker open
		maxItems: 500, //Maximum number of items allowed before user has to filter search further
		minChars: 3, //Minimum number of characters that must be typed into search box before search picker begins searching/filtering results
		showAll: false, //Whether or not to show all items when search picker is first opened
		breakLine: false, //Whether or not to show all selected results on one line or on multiple lines in search picker created with a div
		searchEnabled: true, //Whether or not to show the search filter
		sortable: false, //Whether or not the selected items list can be sorted alphabetically
		rowCount: null, //Number of items to display in the search and selected items boxes before scrolling
		showButtons: true, //Whether or not to show the action buttons at the bottom of the searchPicker.
		dynamicUrl:null, // use custom url 
		ajaxDataParser: null, // custom data parser for response
		searchResultRowHover:null, // if present a hover overlay will show up
		dynamicSearchText:null, //if using a custom search UI, this will return the search text
		hoverFilter:null, // to only hover on an element inside each result, use this, example ".warningIcon"
		hoverOptions: {
			inline:true,
			targetMouseInDelay: 700,
			targetMouseOutDelay: 100,
			maxWidth:300,
			offsets:{x:0,y:0},
			position:'l-r',
			showArrow:true,
			arrowLength:10,
			preferredAltPositions:['t-b'],
			customContent: ''
		},
		resultsPaging: {
			enabled:false,
			setup:false,
			totalItems:0,
			currentPage:0,
			options:{
				zeroBasedPaging:true,
				mini:true,
				totalItemsPerPage: 50,
				changePageCallback: function(evt, currentPage, previousPage, pager){ 
					$(evt.target).parents('.searchPicker:first').dr.searchPicker.search();
		        }
			}
		},
		selectAllAcrossPages: false,
		messages: {
			RESULTTITLE: '\u9009\u62E9\u6761\u76EE',
			LOADING: '\u6B63\u5728\u52A0\u8F7D...',
			RESULTS: '\u00A0\u7ED3\u679C',
			NORESULTS: '\u672A\u641C\u7D22\u5230\u4EFB\u4F55\u7ED3\u679C\u3002',
			TOOMANYRESULTS: '\u641C\u7D22\u5230\u7684\u7ED3\u679C\u8FC7\u591A\u3002\u8BF7\u8F93\u5165\u5177\u4F53\u641C\u7D22\u6761\u4EF6\u5E76\u7EE7\u7EED\u3002',
			SEARCHERROR: '\u60A8\u7684\u641C\u7D22\u6761\u4EF6\u6709\u8BEF\u3002\u60A8\u7684\u4F1A\u8BDD\u53EF\u80FD\u4F1A\u8D85\u65F6\u3002',
			CURRENTVALUE: '\u5F53\u524D\u503C\uFF1A',
			TYPEATLEAST: '\u81F3\u5C11\u8F93\u5165\u00A0',
			CHARACTERSTOBEGIN: '\u00A0\u5F00\u59CB\u641C\u7D22\u7684\u5B57\u7B26\u3002',
			TYPETOSEARCH: '\u5F00\u59CB\u8F93\u5165\u8981\u641C\u7D22\u7684\u5185\u5BB9\u3002',
			TYPETOFILTER: '\u5F00\u59CB\u8F93\u5165\u4ECE\u7ED3\u679C\u4E2D\u8FC7\u6EE4\u7684\u5185\u5BB9\u3002',
			SELECTALL: '\u5168\u9009',
			SEARCHFORITEMS: '\u4F7F\u7528\u4E0A\u9762\u7684\u8868\u5355\u641C\u7D22\u6761\u76EE',
			CLEARBUTTON: '\u6E05\u9664',
			APPLYBUTTON: '\u5E94\u7528',
			CANCELBUTTON: '\u53D6\u6D88',
			SEARCHBUTTON: '\u641C\u7D22',
			SINGULARVALUE: '\u641C\u7D22',
			PLURALVALUE: '\u7528\u6237',
			LEFTLABEL: '\u641C\u7D22\u7ED3\u679C',
			RIGHTLABEL: '\u9009\u5B9A\u7684\u6761\u76EE',
			REMOVE_ITEM: 'Remove Item',
			SPLITTEXT: ';',
			UNASSIGNEDVALUE: '',
			UNASSIGNEDHIDDENVALUE: '',
			PLACEHOLDERTEXT: ''
		}
	};
	
	$.dr.searchPicker = {
		setDefaults: function(userOptions){
	        if (userOptions) {
	            $.extend({}, defaults, userOptions);
	        }
	        //inform any listeners to the events
	        $(document).trigger('dr-searchPicker-setDefaults', [defaults]);
	    },
		getDefaults: function(){
			return defaults;
		}
	};
	
	var searchPicker = function(userOptions){
		// hold the list of selectedItems
		this.selectedItems = [];
		this.selectedItemsHash = [];
		// set messages
		this.messages = userOptions.messages;
		// set options
		this.modal = userOptions.modal;
		this.selectedInputId = userOptions.selectedInputId;
		this.multiSelect = userOptions.multiSelect;
		this.showTotalResults = userOptions.showTotalResults;
		this.url = userOptions.url;
		this.dataSet = userOptions.dataSet;
		this.paramName = userOptions.paramName;
		this.hiddenId = userOptions.hiddenId;
		this.displayValuesId = userOptions.displayValuesId;
		this.iconValuesId = userOptions.iconValuesId;
		this.maxItems = userOptions.maxItems;
		this.minChars = userOptions.minChars;
		this.showAll = userOptions.showAll;
		this.breakLine = userOptions.breakLine;
		this.searchEnabled = userOptions.searchEnabled;
		this.sortable = userOptions.sortable;
		this.rowCount = userOptions.rowCount;
		this.showButtons = userOptions.showButtons;
		this.dynamicUrl = userOptions.dynamicUrl;
		this.ajaxDataParser = userOptions.ajaxDataParser;
		this.searchResultRowHover = userOptions.searchResultRowHover;
		this.dynamicSearchText = userOptions.dynamicSearchText;
		this.hoverOptions = userOptions.hoverOptions;
		this.hoverFilter = userOptions.hoverFilter;
		this.resultsPaging = userOptions.resultsPaging;
		this.totalItems = '';
		this.selectAllAcrossPages = userOptions.selectAllAcrossPages;
		if(!this.searchEnabled){
			this.showAll = true;
		}
		this.searchPickerInput = userOptions.searchPickerInput;
		this.inputId = userOptions.inputId;
		this.setup = userOptions.setup;
	}
	
	var enterText = function(oThis, timeout, inputId){
		if (timeout != null) {
            cancelAll();
        }
		if ($(inputId + " .item_name").val().length >= oThis.minChars) {
			timeout = setTimeout(function(){
				oThis.sendRequest();
			}, 500);
		}
	}
	
	var selectItem = function(oThis, evt){
		if (evt.target) {
			var $target = $(evt.target);
			if(!$target.hasClass('listedItem') && !$target.parents('.listedItem').length){
				return false;
			}
			if ($target.parents('.listedItem').length) {
				$target = $target.parents('.listedItem');
			}
			oThis.select($target);
		}
		evt.stopImmediatePropagation();
	}
	
	var removeItem = function(oThis, evt){
		if(evt.target){
			var $target = $(evt.target); 
			if(!$target.hasClass('addedItem') && !$target.parents('.addedItem').length){
				return false;
			}
			if( $target.parents('.addedItem').length){
				$target = $target.parents('.addedItem');
			}
			$('#' + oThis.selectedInputId).dr.searchPicker.remove($target);
		}
	}
	
	function scrollbarWidth() {
	    var inner = document.createElement('p');
		inner.style.width = "100%";
		inner.style.height = "200px";
		
		var outer = document.createElement('div');
		outer.style.position = "absolute";
		outer.style.top = "0px";
		outer.style.left = "0px";
		outer.style.visibility = "hidden";
		outer.style.width = "200px";
		outer.style.height = "150px";
		outer.style.overflow = "hidden";
		outer.appendChild (inner);
		
		document.body.appendChild (outer);
		var w1 = inner.offsetWidth;
		outer.style.overflow = 'scroll';
		var w2 = inner.offsetWidth;
		if (w1 == w2) w2 = outer.clientWidth;
		
		document.body.removeChild (outer);

	    return (w1 - w2);
	}
	
	var requestSuccess = function(oThis, ajaxResp, searchText, inputId){
		// check to see if there is a ajaxDataParser function setup for the response
		// this would be needed if the data is not in standard format
		var resp = ajaxResp;
		
		if(typeof oThis.ajaxDataParser === 'function'){
			
			var parsedData = oThis.ajaxDataParser(ajaxResp);
			resp = parsedData.results; //array of results
			
			if(oThis.resultsPaging.enabled && typeof parsedData.paging !== 'undefined'){
				if($(inputId + " .pagingBar .initialized").length>0){
					$(inputId + " .paging-toolbar").dr.pager.reset({
						firstItem: parsedData.paging.firstItem,
						totalItemsPerPage: parsedData.paging.totalItemsPerPage,
						totalItems: parsedData.paging.totalItems
					});
					oThis.totalItems = parsedData.paging.totalItems;
				}
				if (oThis.showTotalResults) {
					$(inputId + ' .leftBar .resultsCount').text('(' + parsedData.paging.totalItems + ')');
				}
			} else {
				if (oThis.showTotalResults) {
					$(inputId + ' .leftBar .resultsCount').text('(' + resp.length + ')');
				}
			}
			
		} else {
			if (oThis.showTotalResults) {
				$(inputId + ' .leftBar .resultsCount').text('(' + resp.length + ')');
			}
		}
		
		oThis.hideLoading();
		var browserName=navigator.appName;
		if (browserName == "Microsoft Internet Explorer") {
			var itemWidth = $(oThis.inputId + ' .searchResults').width() - scrollbarWidth();
			$(oThis.inputId + ' .resultsBox').eq(0).width(itemWidth);
		}
		var results = [];
		$.each(resp, function(){
			oThis.addItem(this, results, searchText);
		});
		if (results.length > 0 && results.length < oThis.maxItems && oThis.multiSelect){
			$(inputId + ' .selectAll').addClass('clickable');
		}
		if (results.length == 0) {
			results.push('<em class="noresults">' + oThis.messages.NORESULTS + '</em>');
			if (oThis.multiSelect) {
				$(inputId + ' .selectAll').removeClass('clickable');
			}
		}
		if (results.length >= oThis.maxItems) {
			results = [];
			results.push('<em class="error">' + oThis.messages.TOOMANYRESULTS + '</em>');
			if (oThis.multiSelect) {
				$(inputId + ' .selectAll').removeClass('clickable');
			}
		}
		$(inputId + " .itemResults").html(results.join(''));
		
		setTimeout(function(){
			//inform any listeners to the event
			$('#' + oThis.selectedInputId).trigger('dr-searchPicker-resultsLoaded', [oThis]);
			// setup hover
			setHover(oThis);
		},0);
			
	}
	
	var dataSetRequest = function(oThis, searchText, inputId){
		var results = [];
		var searchText = searchText.toLowerCase();
		oThis.hideLoading();
		$.each(oThis.dataSet, function(){
			var name = this.name;
			if (name.toLowerCase().indexOf(searchText) >= 0) {
				oThis.addItem(this, results, searchText);
			}
		});
		if (results.length == 0) {
			results.push('<em class="noresults">' + oThis.messages.NORESULTS + '</em>');
			if (oThis.multiSelect) {
				$(inputId + ' .selectAll').removeClass('clickable');
			}
		} else if (results.length >= oThis.maxItems) {
			results = [];
			results.push('<em class="error">' + oThis.messages.TOOMANYRESULTS + '</em>');
			if (oThis.multiSelect) {
				$(inputId + ' .selectAll').removeClass('clickable');
			}
		} else {
			$(inputId + ' .selectAll').addClass('clickable');
		}
		$(inputId + " .itemResults").html(results.join(''));
		//inform any listeners to the event
		$('#' + oThis.selectedInputId).trigger('dr-searchPicker-resultsLoaded', [oThis]);
		oThis.limitScrolling();
	}
	
	function initPagerBar(){
		var pagingOptions = {
		    totalItems: 80, 
		    totalItemsPerPage: 25
		};
		 
		// create the widget
		$("#paging_toolbar").dr.pager(pagingOptions);
	}
	
	function setHover(picker){
		if(typeof picker.searchResultRowHover === 'function'){
			var selector = (picker.hoverFilter) ?  picker.hoverFilter : "";
			$('#'+picker.selectedInputId + ' div.searchResults div.listedItem' + selector ).each(function(){
				$(this).dr.hover(picker.hoverOptions);
			});
		}
	}
	
	function sortJsonArrayByProp(objArray, prop){
	    if (arguments.length<2){
	        throw new Error("sortJsonArrayByProp requires 2 arguments");
	    }
	    if (objArray && objArray.constructor===Array){
	        var propPath = (prop.constructor===Array) ? prop : prop.split(".");
	        objArray.sort(function(a,b){
	            for (var p in propPath){
	                if (a[propPath[p]] && b[propPath[p]]){
	                    a = a[propPath[p]];
	                    b = b[propPath[p]];
	                }
	            }
	            // convert numeric strings to integers
	            a = a.match(/^\d+$/) ? +a : a;
	            b = b.match(/^\d+$/) ? +b : b;
	            return ( (a < b) ? -1 : ((a > b) ? 1 : 0) );
	        });
	    }
	}
	
	function selectionChange(picker){
		var selectedItems = picker.selectedItems[picker.selectedInputId];
		if(picker.showTotalResults){
			$(picker.inputId + ' .rightBar .resultsCount').text('('+selectedItems.length+')');
		}
		$('#' + picker.selectedInputId).trigger('dr-searchPicker-selectionChange',[selectedItems]);
		
		// hide any hovers
		$('#' + picker.selectedInputId + ' div.drHoverPopup').dr.hover.hide();
	}
	
	function selectAllOnCurrentPage(){
		if ($(this.inputId).is(':visible')) {
			var oThis = this;
			$(this.inputId + ' .listedItem').each(function(){
				$(this).removeAttr('title');
				var rowName = $(this).children('div').children('span').text();
				var rowId = $(this).attr('data-id');
				if (oThis.multiSelect) {
					var rowIcon = $(this).attr('data-icon');
					var rowRightIcon = $(this).attr('data-right-icon');
					if (!$(this).hasClass('selected')) {
						$(this).addClass('selected');
						oThis.addSelectedItem(rowId, rowName, rowIcon, rowRightIcon);
					}
				} else {
					$(this).addClass('selected').removeAttr('title');
					oThis.updateValues(rowName, rowId);
				}
			});
			if (this.multiSelect) {
				var currentPage = $(this.inputId + " .pagingBar div").dr.pager.getCurrentPage();
				if(this.resultsPaging.enabled && (currentPage + 1) * this.resultsPaging.options.totalItemsPerPage < this.totalItems){
					this.refreshSelectedItemsUI();
					$('#' + this.selectedInputId).trigger('currentPageSelected');
				} else {
					$('#' + this.selectedInputId).unbind('dr-searchPicker-resultsLoaded');
					$('#' + this.selectedInputId).unbind('currentPageSelected');
					this.refreshSelectedItemsUI();	
				}
			}
		}
	}
	
	searchPicker.prototype = {
		/**
		 * sets up the events for all clicks and key strokes
		 */
		init: function(){
			var oThis = this;
			var timeout;
		    var cancelAll = function() {
		        clearTimeout(timeout);
		        timeout = null;
		    };
			
			this.initSelectedItems();
			
			$(this.inputId + " .item_name").bind("keyup", function(){
				if (timeout != null) {
		            cancelAll();
		        }
				if ($(oThis.inputId + " .item_name").val().length >= oThis.minChars) {
					timeout = setTimeout(function(){
						oThis.sendRequest();
					}, 500);
				}
			});
			
			$(this.inputId + ' button.cancel').click(function (){
				oThis.cancel();
			});
			
			$(this.inputId + ' .itemResults').click(function (evt){
				selectItem(oThis, evt);
			});
			
			$(this.inputId + ' .selectedItemList').click(function(evt){
				removeItem(oThis, evt);
			});
			
			$(this.inputId + ' button[name="submitItems"]').click(function(evt){
				$('#' + oThis.selectedInputId).dr.searchPicker.apply();
				evt.stopImmediatePropagation();
			});
			
			$(this.inputId + ' button[name="setUnassignedButton"]').click(function(){
				oThis.setUnassigned();
			});
			
			$(this.inputId + ' .selectAll').click(function(){
				oThis.selectAll();
			});
			
			$(this.inputId + ' .clearLink').click(function(){
				if ($(this).hasClass('clickable')) {
					$('#' + oThis.selectedInputId).dr.searchPicker.clearSelected();
				}
			});
			
			if(this.resultsPaging.enabled){
				$(this.inputId + " .pagingBar div").dr.pager(this.resultsPaging.options);
				this.resultsPaging.setup = true;
			}
			
			if (this.sortable) {
				$(this.inputId + ' .selectedItems .resultsHeader').click(function(e){
					if (!$(e.target).is('.clearLink')) {
						if ($(this).hasClass('ascending')) {
							$(this).addClass('descending').removeClass('ascending');
							sortJsonArrayByProp(oThis.selectedItems[oThis.selectedInputId], 'name');
							oThis.selectedItems[oThis.selectedInputId].reverse();
							oThis.refreshSelectedItemsUI();
						}
						else {
							$(this).addClass('ascending').removeClass('descending');
							sortJsonArrayByProp(oThis.selectedItems[oThis.selectedInputId], 'name');
							oThis.refreshSelectedItemsUI();
						}
					}
				});
			}
			
			$('#' + this.selectedInputId).bind('dr-searchPicker-open', function(){
				oThis.limitScrolling();
			});
			
			$(this.searchPicker).addClass('picker_initialized');
		}, 
		
		/**
		 * creates a new div for the search picker modal, gives it the necessary content, and then launches the search picker
		 */
		searchOverlay: function(){
			var oThis = this;
			var currentValue;
			if(this.modal){
				currentValue = (this.searchPickerInput) ? $('#' + this.selectedInputId).val() : $('#' + this.selectedInputId).text();
			}else{
				currentValue = (this.searchPickerInput) ? $('#' + this.displayValuesId).val() : $('#' + this.displayValuesId).text();
			}
			if(currentValue === ''){
				currentValue = 'Unassigned';
			}
			
			var searchPickerExists;
			if (this.modal) {
				searchPickerExists = ($(this.inputId).length === 0) ? false : true;
			}else{
				searchPickerExists = ($(this.inputId + ' .spPop').length === 0) ? false : true;
			}
			
			if(this.setup && searchPickerExists){
				$('#modal_searchPickerOverlay_' + this.selectedInputId).remove();
				searchPickerExists = false;
			}
	
			if (!searchPickerExists) {
				var leftBoxHeight = 0;
				var rightBoxHeight = 0;
				if (this.rowCount) {
					var boxHeight = this.rowCount * 25;
					// subtract the height of the pager bar from the left box if enabled
					leftBoxHeight = (this.resultsPaging.enabled) ? (boxHeight - 24 ) : boxHeight ;
					rightBoxHeight = boxHeight;
				}
				if (this.modal) {
					$('.content').append('<div class="searchPickerOverlay" id="searchPickerOverlay_' + this.selectedInputId + '" style="display:none;"/>');
				}
				var h = [];
				var multiSelectCSS = (this.multiSelect) ? " multipleMode" : "";
				h.push('<div class="spPop" >');
				h.push('<div class="' + multiSelectCSS + ' spContentWrapper">');
				h.push('<input type="hidden" class="searchExpanded" name="searchExpanded" value="true" />');
				h.push('<input type="hidden" class="searchFilters" value="contact_id=&name=&email=&status=&administrator=&state=" />');
				if(!this.multiSelect){
					h.push('<table cellspacing="0" class="currentValTbl"><tr><td class="leftLabel"><strong>' + this.messages.CURRENTVALUE + '</strong></td><td class="rightValue"><div class="currentValue">' + currentValue + '</div></td></tr></table>');
				}
				h.push('<div');
				if (!this.searchEnabled) {
					h.push(' style="display:none;"');
				}
				h.push('><input autocomplete="off" type="text" class="searchPickerInput item_name" name="item_name" value="" style="border:1px solid #999999;"/></div>');
				h.push('<div');
				if (!this.searchEnabled) {
					h.push(' style="display:none;"');
				}
				if (this.minChars > 1) {
					h.push('><span class="hint">' + this.messages.TYPEATLEAST + this.minChars + this.messages.CHARACTERSTOBEGIN + '</span></div>');
				} else if (this.minChars === 1) {
					h.push('><span class="hint">' + this.messages.TYPETOSEARCH + '</span></div>');
				}
				else {
					h.push('><span class="hint">' + this.messages.TYPETOFILTER + '</span></div>');
				}
				h.push('<div class="availableItems" >');
				if (this.multiSelect) {
					if (this.sortable) {
						h.push('<div class="resultsHeader"><div class="resultsHeaderBar leftBar"><span class="leftLabel">' + this.messages.LEFTLABEL + '</span> <span class="resultsCount">&nbsp;</span></div><div class="selectAll resultsHeaderRight">' + this.messages.SELECTALL + '</div></div>');
					}else{
						h.push('<div class="resultsHeader sortable"><div class="resultsHeaderBar leftBar"><span class="leftLabel">' + this.messages.LEFTLABEL + '</span> <span class="resultsCount">&nbsp;</span></div><div class="selectAll resultsHeaderRight">' + this.messages.SELECTALL + '</div></div>');
					}
				}else{
					h.push('<div class="resultsHeader"><div class="resultsHeaderBar leftBar"><span class="leftLabel">' + this.messages.LEFTLABEL + '</span> <span class="resultsCount">&nbsp;</span></div></div>');
				}
				if (this.rowCount) {
					h.push('<div class="resultsWrapper searchResults" style="height:' + leftBoxHeight + 'px;">');
				}else{
					h.push('<div class="resultsWrapper searchResults">');
				}
				h.push('<div class="resultsBox" ><div class="itemResults">');
				h.push('<em class="noresults">' + this.messages.SEARCHFORITEMS + '</em>');
				h.push('</div></div></div>')
				
				if(this.resultsPaging.enabled){
					h.push('<div class="pagingBar"><div class="paging-toolbar">&nbsp;</div></div>')
				}
				
				h.push('</div>');
				
				if (this.multiSelect) {
					h.push('<div class="selectedItems">');
					h.push('<div class="resultsHeader"><div class="resultsHeaderBar rightBar"><span class="rightLabel">' + this.messages.RIGHTLABEL + '</span> <span class="resultsCount">&nbsp;</span></div><div class="clearLink resultsHeaderRight">' + this.messages.CLEARBUTTON + '</div></div>');
					if (this.rowCount) {
						h.push('<div class="resultsWrapper" style="height:' + rightBoxHeight + 'px;">');
					}else{
						h.push('<div class="resultsWrapper">');
					}
					h.push('<div class="resultsBox"><div class="selectedItemList" >&nbsp;</div></div></div></div>');
				}
				h.push('</div>');
				if (this.showButtons) {
					h.push('<table style="width:100%">');
				}else{
					h.push('<table style="width:100%; display:none;">');
				}
				h.push('<tbody>');
				h.push('<tr>');
				if (!this.multiSelect) {
					h.push('<td width="50%"><button class="secondary delete button" type="button" name="setUnassignedButton" style="margin-top:10px; float:left;"><span><span><span>' + this.messages.CLEARBUTTON + '</span></span></span></button></td>');
				}
				h.push('<td width="50%">');
				if (this.multiSelect) {
					h.push('<button class="secondary apply button" type="button" name="submitItems" style="margin:10px 0 0 10px; float:right;"><span><span><span>' + this.messages.APPLYBUTTON + '</span></span></span></button>');
				}
				h.push('<button class="secondary cancel button" type="button"  style="margin-top:10px; float:right;"><span><span><span>' + this.messages.CANCELBUTTON + '</span></span></span></button></td>');
				h.push('</tr>');
				h.push('</tbody>');
				h.push('</table>');
				h.push('</div>');
				
				var modalHtml = h.join('');
				
				if (this.modal) {
					$('#searchPickerOverlay_' + this.selectedInputId).html(modalHtml);
					if (this.searchEnabled) {
						setTimeout(function(){
							$(".item_name", '#searchPickerOverlay_' + oThis.selectedInputId)[0].focus();
						}, 1);
					}
				}else{
					$('#' + this.selectedInputId).html(modalHtml);
					
				}
				
			}
			this.init();
			
			$(this.inputId + ' .currentValue').text(currentValue);
			
		},
		
		/**
		 * takes the search text entered by the user and either sends out an ajax call or loops through a supplied data set
		 */
		sendRequest: function(){
			var oThis = this;
			var searchText = '';
			if(typeof this.dynamicSearchText === 'function'){
				searchText = this.dynamicSearchText();
			}else{
				// get it from the normal input
				searchText = $(this.inputId + " .item_name").val().trim();
			}
			
			if(this.resultsPaging.setup){
				$(this.inputId + " .pagingBar div").dr.pager.disable();
			}
				
			this.showLoading();
			var isDynamicUrl = (typeof this.dynamicUrl === 'function');
			if (this.url || isDynamicUrl ) {
				
				var url = this.url;
				
				// check if the optional dynamic url is present
				if(isDynamicUrl){
					url = this.dynamicUrl(searchText, this);
				}else{
					var separation = (url.indexOf('?') === -1) ? '?' : '&'; 
					url = url + separation + this.paramName + '=' + searchText + '&showAll='+this.showAll;
				}
				var pn_request = null;
				pn_request = $.ajax({
					url: url,
					dataType: 'json',
					success: function(resp){
						requestSuccess(oThis, resp, searchText, oThis.inputId);
					},
					error: function(){
						oThis.hideLoading();
						$(oThis.inputId + " #itemResults").html('<em class="error">' + oThis.messages.SEARCHERROR + '</em>');
					},
					complete: function(){
						oThis.limitScrolling();
						if(oThis.resultsPaging.setup){
							$(oThis.inputId + " .pagingBar div").dr.pager.enable();
						}
						pn_request.abort();
					}
				});
			} else {
				dataSetRequest(oThis, searchText, this.inputId);
			}
		},
		
		open: function(){
			this.searchOverlay();
			this.initSelectedItems();
			if(this.showAll){
				this.sendRequest();
			}
			var inputValue;
			if (this.modal) {
				$(this.inputId).dr.overlay({
					type: 'modeless',
					width: 565,
					height: 400,
					title: this.messages.SINGULARVALUE
				});
				inputValue = (this.searchPickerInput) ? $('#' + this.selectedInputId).val() : $('#' + this.selectedInputId).text();
			}else{
				inputValue = (this.searchPickerInput) ? $('#' + this.displayValuesId).val() : $('#' + this.displayValuesId).text();
			}
			
			if(inputValue === ''){
				inputValue = 'Unassigned';
			}
			$(this.inputId + ' .currentValue').html(inputValue);
			if (this.modal) {
				$(this.inputId + ' .searchPickerInput').focus();
			}
			//inform any listeners to the event
			$('#' + this.selectedInputId).trigger('dr-searchPicker-open');
			this.setup = false;
		},
		select: function(item){
			var $target = $(item, this.inputId);
			$target.removeAttr('title');
			var rowName = $target.text();
			var rowId = $target.attr('data-id');
			if (this.multiSelect) {
				var rowIcon = $target.attr('data-icon');
				var rowRightIcon = $target.attr('data-right-icon');
				if (!$target.hasClass('selected')) {
					$target.addClass('selected');
					this.addSelectedItem(rowId,rowName,rowIcon,rowRightIcon);
					this.refreshSelectedItemsUI();
				}
			} else {
				$(this.inputId + ' .selected').removeClass('selected').attr('title',this.messages.RESULTTITLE);
				$target.addClass('selected').removeAttr('title');
				this.updateValues(rowName, rowId);
			}
		},
		selectAll: function(){
			var oThis = this;
			if (!this.selectAllAcrossPages) {
				selectAllOnCurrentPage.call(this);
			} else {
				var currentPage = $(this.inputId + " .pagingBar div").dr.pager.getCurrentPage();
				function selectAllCallback(){
					$('#' + oThis.selectedInputId).bind('dr-searchPicker-resultsLoaded', function(){
						selectAllOnCurrentPage.call(oThis);
					});
					$('#' + oThis.selectedInputId).bind('currentPageSelected', function(){
						$(oThis.inputId + " .pagingBar div").dr.pager.next();
					});
					selectAllOnCurrentPage.call(oThis);
				}
				if(currentPage > 0){
					$('#' + this.selectedInputId).one('dr-searchPicker-resultsLoaded', function(){
						selectAllCallback();
					});
					$(this.inputId + " .pagingBar div").dr.pager.changePage(0);
				} else {
					selectAllCallback();
				}
			}
		},
		remove: function(item){
			var $target = $(item, this.inputId);
			var itemId = $target.attr('data-id');
			if (itemId) {
				this.deleteSelectedItem(itemId);
				this.refreshSelectedItemsUI();
				$(this.inputId + ' div.id_' + itemId).removeClass('selected').attr('title', this.messages.RESULTTITLE);
			}
		},
		clearSelected: function(){
			this.clearSelectedItems();
			this.refreshSelectedItemsUI();
			$(this.inputId + ' .selected').removeClass('selected').attr('title', this.messages.RESULTTITLE);
		},
		clearResults: function(){
			$(this.inputId + ' .searchPickerInput').val('');
			$(this.inputId + ' .itemResults').empty();
			if (this.showTotalResults) {
				$(this.inputId + ' .leftBar .resultsCount').text('(0)');
			}
		},
		apply: function(){
			var ids = [];
			var names = [];
			if (this.iconValuesId) {
				var icons = [];
			}
			var oThis = this;
			$.each(this.selectedItems[this.selectedInputId], function(){
				ids.push(this.id);
				names.push(this.name);
				if (oThis.iconValuesId) {
					icons.push(this.icons);
				}
			});
			if (this.breakLine) {
				setTimeout(function(){
					if (this.iconValuesId) {
						oThis.updateValues(names.join('<br />'), ids.join(', '), icons.join(', '));
					} else {
						oThis.updateValues(names.join('<br />'), ids.join(', '));
					}
				}, 0);
			} else {
				setTimeout(function(){
					if (this.iconValuesId) {
						oThis.updateValues(names.join(oThis.messages.SPLITTEXT + ' '), ids.join(', '), icons.join(', '));
					} else {
						oThis.updateValues(names.join(oThis.messages.SPLITTEXT + ' '), ids.join(', '));
					}
				}, 0);
			}
		},
		setUnassigned: function(){
			var oThis = this;
			this.clearSelectedItems();
			this.refreshSelectedItemsUI();
			$(this.inputId + ' .selected').removeClass('selected').attr('title',this.messages.RESULTTITLE);
			var clearedIDValue = (this.multiSelect) ? '' : this.messages.UNASSIGNEDHIDDENVALUE;
			var clearedDisplay = (this.multiSelect) ? '' : this.messages.UNASSIGNEDVALUE;
			setTimeout(function(){
				oThis.updateValues(clearedDisplay, clearedIDValue);
			}, 0);
		},
		cancel: function(){
			var oThis = this;
			// reset the selected items
			this.initSelectedItems();
			$(this.inputId + ' .selected').removeClass('selected').attr('title',this.messages.RESULTTITLE);
			$.each(this.selectedItems[this.selectedInputId],function(){
				var id = this.id;
				$(oThis.inputId + ' .listedItem').each(function(){
					var dataId = $(this).attr('data-id');
					if(dataId === id){
						$(this).addClass('selected').removeAttr('title');
					}
				});
			});
			$.dr.overlay.close();
			//inform any listeners to the event
			$('#' + this.selectedInputId).trigger('dr-searchPicker-cancel');
		},
		
		/**
		 * stores the selected item to the necessary arrays so that it can be used later
		 * @param {String} rowId the id of the selected value
		 * @param {String} rowName the name of the selected value
		 */
		addSelectedItem: function(id,name,icon,rightIcon){
			this.selectedItemsHash[this.selectedInputId][id] = name;
			this.selectedItems[this.selectedInputId].push({id:id,name:name,icon:icon,rightIcon:rightIcon});
			selectionChange(this);
		},
		
		/**
		 * removes the selected item from the necessary arrays so that it won't be included in later functions
		 * @param {String} itemId the id of the selected value
		 */
		deleteSelectedItem: function(itemId){
			delete this.selectedItemsHash[this.selectedInputId][itemId];
			var oThis = this;
			$.each(this.selectedItems[this.selectedInputId], function(index){
				if(this.id === itemId){
					oThis.selectedItems[oThis.selectedInputId].splice(index,1);
				}
			});
			selectionChange(this);
		},
		
		/**
		 * removes all items from the necessary arrays
		 */
		clearSelectedItems: function(){
			this.selectedItems[this.selectedInputId] = [];
			this.selectedItemsHash[this.selectedInputId] = [];
			selectionChange(this);
		},
		
		/**
		 * takes the values from the selectedItems array and updates the selected items list in the multiSelect version of searchPicker 
		 */
		refreshSelectedItemsUI: function(){
			var oThis = this;
			var s = [];
			var itemWidth = $(this.inputId + ' .resultsWrapper').eq(1).dr.utils.getHiddenDimensions().width - scrollbarWidth();
			$(oThis.inputId + ' .resultsBox').eq(1).width(itemWidth);
			$.each(this.selectedItems[this.selectedInputId], function(){
				if (this.name !== '' && this.id !== null) {
					var rightIconCSS = (this.rightIcon) ? ' class="' + this.rightIcon + '"' : "";
					s.push('<div class="addedItem" data-id="' + this.id + '" title="'+oThis.messages.REMOVE_ITEM+'"><div class="' + this.icon + '"><span class="actionIcon"><span ' + rightIconCSS + '>' + this.name + '</span></span></div></div>');
				}
			});
			$(this.inputId + " .selectedItemList").html(s.join(''));
			if(s.length > 0){
				$(this.inputId + ' .clearLink').addClass('clickable');
			} else {
				$(this.inputId + ' .clearLink').removeClass('clickable');
			}
			//inform any listeners to the event
			$('#' + this.selectedInputId).trigger('dr-searchPicker-selectedItemsUpdated');
		},
		
		/**
		 * updates the value of your visible search picker input and the corresponding hidden input.
		 * @param {String} rowName the value to be passed to the original searchPicker input/div.
		 * @param {String} rowId the value to be passed to the hidden input.
		 */
		updateValues: function(rowName, rowId, rowIcons){
			var oThis = this;
			var $input = (this.modal) ? $('#' + this.selectedInputId) : $('#' + this.displayValuesId);
			var $hiddenInput = $('#' + this.hiddenId);
			if(this.iconValuesId){
				var $iconsInput = $('#' + this.iconValuesId);
				$iconsInput.val(rowIcons);
			}
			if(this.searchPickerInput){
				$input.val(rowName);
			}else{
				$input.html(rowName);
			}
			$hiddenInput.val(rowId);
			// force the ui to update, then call the change event
			setTimeout(function(){
				$input.change();
				$hiddenInput.change();
				if(oThis.iconValuesId){
					$iconsInput.change();
				}
			}, 0);
			if (this.modal) {
				$.dr.overlay.close();
			}
			//inform any listeners to the event
			$('#' + this.selectedInputId).trigger('dr-searchPicker-apply', [rowId, rowName]);
		},
		
		/**
		 * Updates search picker modal according to the values in the input/div
		 */
		initSelectedItems: function(){
			var inputIds = $('#' + this.hiddenId).val();
			var inputText;
			if (this.modal) {
				inputText = (this.searchPickerInput) ? $('#' + this.selectedInputId).val() : $('#' + this.selectedInputId).html();
			}else{
				inputText = (this.searchPickerInput) ? $('#' + this.displayValuesId).val() : $('#' + this.displayValuesId).html();
			}
			inputText = inputText.replace(/\<BR\>/g,'<br>'); //FOR IE8 AND BELOW
			if(this.iconValuesId){
				var icons = $('#' + this.iconValuesId).val();
			}
			var inputTextArray = (this.breakLine) ? inputText.split('<br>') : inputText.split(this.messages.SPLITTEXT + ' ');
			var inputIdsArray = inputIds.split(', ');
			if (this.iconValuesId) {
				var inputIconsArray = icons.split(', ');
			}
			this.clearSelectedItems();
			if (inputIds !== '') {
				for (var i=0, l=inputTextArray.length; i < l; i++) {
					var name = inputTextArray[i];
					var id = inputIdsArray[i];
					if (this.iconValuesId) {
						var icon = inputIconsArray[i];
					}
					this.selectedItemsHash[this.selectedInputId][id] = name;
					if (this.iconValuesId) {
						this.selectedItems[this.selectedInputId].push({id: id,name: name,icon: icon});
					} else {
						this.selectedItems[this.selectedInputId].push({id: id,name: name});
					}
				}		
			}
			this.refreshSelectedItemsUI();
		},
		
		/**
		 * adds a returned item to the available items list
		 * @param {Object} result the specific result to be added
		 * @param {Object} results the array of available items
		 * @param {String} searchText the search text entered by the user
		 */
		addItem: function(result, results, searchText){
			var id = result.id;
			name = this.highlightWords(result.name, searchText);
			var icon = (result.icon) ? result.icon : "";
			var rightIcon = (result.rightIcon) ? result.rightIcon : "";
			var rightIconCSS = (result.rightIcon) ? ' class="' + result.rightIcon + '"' : "";
			var isMatch = (typeof this.selectedItemsHash[this.selectedInputId][id] !== 'undefined');
			var isSelectedCSS = (isMatch) ? 'selected ' : '';
			var titleText = (isMatch) ? '' : ' title="' + this.messages.RESULTTITLE + '" ';
			results.push('<div class="listedItem ' + isSelectedCSS + ' id_' + id + '" data-id="' + id + '" data-icon="' + icon + '" data-right-icon="' + rightIcon + '" ' + titleText + '><div class="' + icon + '"><span class="actionIcon"><span ' + rightIconCSS + '>' + name + '</span></span></div></div>');
		},
		
		/**
		 * when using the mousewheel to scroll through the results, limitScrolling will stop the parent page from scrolling when you reach the end of the list
		 */
		limitScrolling: function(){
			var resultsWrapper = $(this.inputId + " .resultsWrapper");
			var resultsWrapperHeight = resultsWrapper.height();
			var resultsWrapperScrollHeight = resultsWrapper.get(0).scrollHeight;
			resultsWrapper.unbind('mousewheel');
			resultsWrapper.bind('mousewheel', function(e, d){
				if ((this.scrollTop === (resultsWrapperScrollHeight - resultsWrapperHeight) && d < 0) || (this.scrollTop === 0 && d > 0)) {
					e.preventDefault();
				}
			});
		},
		
		/**
		 * shows a loading message while results are being searched for
		 */
		showLoading: function(){
			var loadingDivHtml = "<div class=\"loading_rows\"><div>" + this.messages.LOADING + "</div></div>";
			$(this.inputId + " .itemResults").html(loadingDivHtml);
		},
		
		/**
		 * hides the loading message once results have been found
		 */
		hideLoading: function(){
			$(this.inputId + " .loading_rows").remove();
		},
		
		/**
		 * highlights the searched for text within the search results
		 * @param {String} line the full text of the search result
		 * @param {String} word the searched for text
		 */
		highlightWords: function(line, word){
			if(!word  || word == ''){
				return line
			}else{
				var regex = new RegExp( '(' + word + '+)', 'gi' );
				return line.replace( regex, '<strong>$1</strong>' );
			}
		}
	}

	$.namespace('dr.searchPicker', function(jsOptions){
		return this.not('.picker_initialized').each(function(){
			var dataOptions = $(this).attr('data-search-options');
			if (dataOptions) {
				dataOptions = $.dr.utils.evalString(dataOptions);
			}
			var jsOptionsVar = (typeof jsOptions === 'undefined') ? {} : jsOptions;
			var options = $.extend(true, {}, defaults, dataOptions, jsOptionsVar);
			options.selectedInputId = $(this).attr('id');
			options.searchPicker = this;
			options.setup = true;
			if (options.modal) {
				options.searchPickerInput = $(this).is("input");
				options.inputId = '#searchPickerOverlay_' + options.selectedInputId;
				if (options.searchPickerInput) {
					$(this).attr('readonly', 'readonly');
					if ($('#' + options.hiddenId).val() === '') {
						$('#' + options.selectedInputId).val(options.messages.PLACEHOLDERTEXT);
					}
				}
				else {
					if ($('div', this).length === 0) {
						$(this).prepend('<div>' + options.messages.PLACEHOLDERTEXT + '</div>');
					}
					if ($('button', this).length === 0) {
						$(this).append('<button class="search secondary button" type="button"><span><span><span>' + options.messages.SEARCHBUTTON + '</span></span></span></button>');
					}
					$('div', this).eq(0).attr('id', options.selectedInputId);
					$(this).removeAttr('id');
					if ($('#' + options.hiddenId).val() === '') {
						$('#' + options.selectedInputId).html(options.messages.PLACEHOLDERTEXT);
					}
				}
				$('#' + options.selectedInputId).data('searchPicker', new searchPicker(options));
				if (options.searchPickerInput) {
					$(this).click(function(){
						$('#' + options.selectedInputId).dr.searchPicker.open();
					});
				}
				else {
					$('button', this).click(function(){
						$('#' + options.selectedInputId).dr.searchPicker.open();
					});
				}
			}else{
				options.searchPickerInput = $('#' + options.displayValuesId).is("input");
				options.inputId = '#' + options.selectedInputId;
				$('#' + options.selectedInputId).data('searchPicker', new searchPicker(options));
				$('#' + options.selectedInputId).dr.searchPicker.open();
			}
		});
	});
	
	$.namespace('dr.searchPicker', {
        clearResults: function(){
			var oSearchPicker = $(this).data('searchPicker');
			if (oSearchPicker) {
				oSearchPicker.clearResults();
			}
        },
		clearSelected: function() {
			var oThis = this;
			setTimeout(function(){
				if ($(oThis).triggerHandler("dr-searchPicker-beforeClearSelected", [oThis]) !== false) {
					var oSearchPicker = $(oThis).data('searchPicker');
					if (oSearchPicker) {
						oSearchPicker.clearSelected();
					}
				}
			}, 0);	
		},
		setUnassigned: function(){
			if ($(this).triggerHandler("dr-searchPicker-beforeSetUnassigned") !== false) {
				var oSearchPicker = $(this).data('searchPicker');
				if (oSearchPicker) {
					oSearchPicker.setUnassigned();
				}
			}
		},
		remove: function(item){
			var oSearchPicker = $(this).data('searchPicker');
			if (oSearchPicker) {
				var selectedItemLength = oSearchPicker.selectedItems[oSearchPicker.selectedInputId].length;	
				if (selectedItemLength === 1) {
					var oThis = this;
					setTimeout(function(){
						if ($(oThis).triggerHandler("dr-searchPicker-beforeRemoveLastItem") !== false) {
							oSearchPicker.remove(item);
						}
					}, 0);
				} else {
					oSearchPicker.remove(item);
				}
			}
		},
		select: function(item){
			var oSearchPicker = $(this).data('searchPicker');
			if(oSearchPicker){
				oSearchPicker.select(item);
			}
		},
		selectAll: function(){
			var oSearchPicker = $(this).data('searchPicker');
			if (oSearchPicker) {
				oSearchPicker.selectAll();
			}
		},
		open: function(){
			if ($(this).triggerHandler("dr-searchPicker-beforeOpen") !== false) {
				var oSearchPicker = $(this).data('searchPicker');
				if (oSearchPicker) {
					oSearchPicker.open();
				}
			}
		},
		search: function(resetPaging){
			var oSearchPicker = $(this).data('searchPicker');
			if (oSearchPicker) {
				if(resetPaging && oSearchPicker.resultsPaging.setup){
					// whenever a new search is called, reset the paging to 0
					$(oSearchPicker.inputId + " .pagingBar div").dr.pager.reset({firstItem:0});
				}
				oSearchPicker.sendRequest();
			}
		},
		apply: function(){
			if ($(this).triggerHandler("dr-searchPicker-beforeApply") !== false) {
				var oSearchPicker = $(this).data('searchPicker');
				if (oSearchPicker) {
					oSearchPicker.apply();
				}
			}
		},
		cancel: function(){
			var oSearchPicker = $(this).data('searchPicker');
			if(oSearchPicker){
				oSearchPicker.cancel();
			}
		},
		getSelectedItems:function(){
			var oSearchPicker = $(this).data('searchPicker');
			var selectedItems = null;
			if(oSearchPicker){
				selectedItems = oSearchPicker.selectedItems[oSearchPicker.selectedInputId];
			}
			return selectedItems;
		},
		getResultsPagingFirstItem: function(){
			var firstItem = 0;
			var oSearchPicker = $(this).data('searchPicker');
			if(oSearchPicker){
				if(oSearchPicker.resultsPaging.setup){
					firstItem = $(oSearchPicker.inputId + " .pagingBar div").dr.pager.getFirstItem();
				}
			}
			return firstItem;
		},
		changeLeftLabelText:function(label){
			var oSearchPicker = $(this).data('searchPicker');
			if(oSearchPicker){
				oSearchPicker.messages.LEFTLABEL = label;
				$(oSearchPicker.inputId + ' .resultsHeader .leftLabel').text(label);
			}
			return this;
		},
		changeRightLabelText:function(label){
			var oSearchPicker = $(this).data('searchPicker');
			if(oSearchPicker){
				oSearchPicker.messages.RIGHTLABEL = label;
				$(oSearchPicker.inputId + ' .resultsHeader .rightLabel').text(label);
			}
			return this;
		}
    });

	var initsearchPicker = function(evt, context){
		$('input.searchPicker, div.searchPicker', context).dr.searchPicker();
    };
	
    $.dr.addUnobtrusiveEvent(initsearchPicker, 'unobtrusiveEventEarly');

})(jQuery);
;(function($){
	$.namespace('dr', {
		shadows: function(){
			$(this).each(function(){
				if (!$.browser.msie || $.browser.msie && $.browser.version > 6) {
					$(this).wrap($('<div class="shadow"><div class="topLeft"><div class="topRight"></div></div></div>').append('<div class="bottomLeft"></div><div class="bottomRight"></div>'));
				}
				else {
					$(this.parentNode).bgiframe();
				}
			});
			return $(this);
		}
	});
})(jQuery);
//TODO posible optimization: try currentPosition first if available, then start over with options.position
;(function($) {
	//For repositioning absolutely positioned snapTo elements
	lastResizeTime = new Date().getTime();
	//used to throttle updates based on resize and scroll events
	var scrollBoundElements = [], resizeBoundElements = [], defaults = {
		//"position of element" - "position of anchor"
		position: "tl-br",
		keepInView: true,
		container: window,
		preferredAltPositions: [],
		offset: {
			x: 0,
			y: 0
		},
		inline: true,
		customClass: "",
		minimumRelcalculationDimension: 20,
		repositionOnScroll: false
	},
	fixPositionString = function(pos) {
		var components = ["t", "tl", "tr", "b", "br", "bl", "l", "r", "c"];
		var defaultPositions = ["tl", "br"];
		var split_pos = pos===null ? [] : pos.split("-");
		if ($.inArray(split_pos[0], components) === -1) {
			split_pos[0] = defaultPositions[0];
			$.dr.utils.logError('Error setting element position: defaulting to "tl"');
		}
		if ($.inArray(split_pos[1], components) === -1) {
			split_pos[1] = defaultPositions[1];
			$.dr.utils.logError('Error setting anchor position: defaulting to "br"');
		}
		return split_pos.join("-");
	},
	getOffset = function($elem) {
		if (this.insideFixedContainer === true) {
			return $elem.position();
		} else {
			return $elem.offset();
		}
	},

	/**
	 * Create list of positions to attempt based on a list of visible points and current position
	 */
	createPositions = function(visiblePoints, elemCoordinates, anchorCoordinates, elem, allAnchorSides, allElemSides, closestSide) {
		var currentPosition = this.currentPosition || this.options["position"];
		var positions = currentPosition.split("-");
		var anchorPosition = positions[1], targetPosition = positions[0];
		var oppositeTargetPosition = this.oppositeBasePositions[targetPosition];
		var customizedPositions = [];
		//special case for center positions, we can try the 4 corner points which (since we want center there is no point that is second best) should give an acceptable position.
		//people are not likely to use center positions on the target so this is an edge case
		if (targetPosition === "c") {
			for (var i in visiblePoints) {
				if (visiblePoints.hasOwnProperty(i)) {
					customizedPositions.push(visiblePoints[i].position + "-" + j);
					var ps = ["tr", "tl", "br", "bl"];
					for (var j in ps) {
						if (ps.hasOwnProperty(j)) {
							customizedPositions.push(j + "-" + visiblePoints[i].position);
						}
					}
				}
			}
		} else {
			var targetSimilarPoints = getSimilarPoints(targetPosition, allAnchorSides, elemCoordinates, anchorCoordinates);
			var OppositeSimilarPoints = getSimilarPoints(oppositeTargetPosition, allAnchorSides, elemCoordinates, anchorCoordinates);
			var centerPoints = {"t":{position:"t"},"b":{position:"b"},"l":{position:"l"},"r":{position:"r"}};
			var centerPointsInverse = {"b":{position:"b"}, "t":{position:"t"}, "r":{position:"r"}, "l":{position:"l"}};
			if (oppositeTargetPosition === anchorPosition) {
				customizedPositions.push(oppositeTargetPosition + "-" + positions[0]);
			}
			customizedPositions.push(oppositeTargetPosition + "-" + anchorPosition);

			//Add positions with target points similar to the original  target and where the anchor points and visible points on the anchor
			customizedPositions = customizedPositions.concat(getPositionsFromPointCollection(targetSimilarPoints, visiblePoints, anchorPosition,null,true,customizedPositions));
			
			//Add positions with target points built from all sides on the target, and where the anchor point is the original anchor position
			customizedPositions = customizedPositions.concat(getPositionsFromPointCollection(allElemSides, allElemSides, anchorPosition,null,true,customizedPositions));
			
			//Add positions with target points which are all the points on the closest side to the anchor points and where the anchor point is the original anchor position
			customizedPositions = customizedPositions.concat(getPositionsFromPointCollection(targetSimilarPoints, targetSimilarPoints, anchorPosition,null,false,customizedPositions));
			
			//Add positions with target points that are similar points to the opposite point of the original target and where the anchor point is the original anchor position
			customizedPositions = customizedPositions.concat(getPositionsFromPointCollection(OppositeSimilarPoints, visiblePoints, anchorPosition,null,true,customizedPositions));
			
			//Add positions with target points that are similar points of the original target and where the anchor points are the visible points on the anchor
			customizedPositions = customizedPositions.concat(getPositionsFromPointCollection(targetSimilarPoints, visiblePoints, null,null,false,customizedPositions));
			
			//Add positions with target points that are similar points to the opposite point of the original target and where the anchor points are the visible points on the anchor
			customizedPositions = customizedPositions.concat(getPositionsFromPointCollection(OppositeSimilarPoints, visiblePoints, null,null,false,customizedPositions));
			
			//Add positions using only center points. These would be more likely to fit in cases where the window very small
			customizedPositions = customizedPositions.concat(getPositionsFromPointCollection(centerPoints,centerPointsInverse , null,null,true,customizedPositions));
			
			//Add positions with the target point as the opposite point of the original target position and where the anchor pionts are the visible points on the anchor
			for (var y in visiblePoints) {
				customizedPositions.push(oppositeTargetPosition + "-" + visiblePoints[y].position);
			}
		}
		return customizedPositions;
	},
	getPositionsFromPointCollection = function(targetCollection, anchorCollection, anchorPositionOverride, targetPositionOverride, checkForDupes, fullCollection) {
		var additionalPositions = [];
		for (var j in anchorCollection) {
			for (var spoint in targetCollection) {
				var anchorPos = anchorPositionOverride || anchorCollection[j].position || j, targetPos = targetPositionOverride || spoint;
				var joinedPosition = targetPos + "-" + anchorPos;
				if (checkForDupes===true) {
					if ($.inArray(joinedPosition, fullCollection) === -1) {
						additionalPositions.push(joinedPosition);
					}
				} else {
					additionalPositions.push(joinedPosition);
				}
			}
		}
		return additionalPositions;
	},
	calculateNewAnchorCoords = function(newAnchorCoords,anchorCoords,$anchor,axis,anchorPos, winPos, dir) {
		var diff = Math.abs(anchorPos - winPos);
		var winComparison = (dir === -1) ? anchorCoords[axis] < winPos : anchorCoords[axis] > winPos;
		if (winComparison && diff > this.options.minimumRelcalculationDimension) {
			newAnchorCoords[axis] = anchorPos + ((diff / 2)*dir);
		}
		return newAnchorCoords[axis];
	},
	/**
	 * Recalculate the visible portion of the anchor
	 * @param {Object} anchorCoords anchor coordinates
	 */
	recalculateAnchorCoordinates = function(anchorCoords) {
		//create properties from only the visible portion of the anchor
		var $win = $(this.options.container), scrollTop = $win.scrollTop(), $anchor = $(this.options.anchor), newAnchorCoords = $.extend(true, {}, anchorCoords);
		var winTop = ($win[0]==window ? 0 : $win.offset().top - scrollTop) + scrollTop;
		var winBottom = ($win[0]==window ? $win.height() : $win.outerHeight()) + winTop;
		var winRight = ($win[0]==window ? $win.width() : $win.offset().left + $win.outerWidth()) + $win.scrollLeft();

		var offs = getOffset.call(this, $anchor);
		var anchorBottom = offs.top + $anchor.outerHeight();
		var anchorTop = offs.top;
		var anchorLeft = offs.left;
		//test top of window
		if (anchorBottom > winTop) {
			newAnchorCoords.top = calculateNewAnchorCoords.call(this,newAnchorCoords,anchorCoords, $anchor, "top",anchorBottom,winTop,-1);
		}
		//test bottom of window
		if (anchorTop < winBottom) {
			newAnchorCoords.top = calculateNewAnchorCoords.call(this,newAnchorCoords,anchorCoords, $anchor, "top",anchorTop,winBottom,1);
		}
		//test right of window
		newAnchorCoords.left = calculateNewAnchorCoords.call(this,newAnchorCoords,anchorCoords, $anchor, "left",anchorLeft,winRight,1);
		return newAnchorCoords;
	},
	/*
	 * Get an array of points closest to the given point (targetPosition)
	 *
	 */
	getSimilarPoints = function(targetPosition, allSides, elemCoordinates, anchorCoordinates) {
		//if a corner point use the side that is closest to the anchorcoordinates (and vice versa)
		var similarPoints = [];
		for (var side in allSides) {
			for (var pointData in allSides[side]) {
				if (targetPosition === pointData) {
					if ($.inArray(pointData, ["tr", "tl", "br", "bl"]) > -1) {
						//use the points on the target side with the fewest number of visible points
						similarPoints = getLeastVisibleSide(allSides, pointData);
						return similarPoints ? allSides[similarPoints.side] : [];
					} else {
						return allSides[side];
					}
				}
			}
		}
	},
	/**
	 *
	 */
	//sort visible points base on distance from anchor point
	sortVisiblePoints = function(points, anchorPoint) {
		var distances = [];
		for (var i in points) {
			if (points.hasOwnProperty(i)) {
				distances.push({
					point: points[i].point,
					position: points[i].position,
					data: getDistance(points[i].point, anchorPoint)
				});
			}
		}
		distances.sort(compareObjects);
		return distances;
	},
	/**
	 *
	 */
	getDistance = function(point1, point2) {
		return Math.sqrt(Math.pow(point2.left - point1.left, 2) + Math.pow(point2.top - point1.top, 2));
	},
	/**
	 *
	 */
	compareObjects = function(a, b) {
		if (a.data < b.data) {
			return -1;
		}
		if (a.data > b.data) {
			return 1;
		}
		return 0;
	},
	/**
	 *
	 */
	isPointInsideViewport = function(point) {
		var $win = $(window);
		if (point.top <= $win.height() + $win.scrollTop() && point.top >= $win.scrollTop() && point.left >= $win.scrollLeft() && point.left <= $win.width() + $win.scrollLeft()) {
			return true;
		}
		return false;
	},
	/**
	 *
	 */
	getAllSides = function(elem, overrideElementOffsets) {
		var positions = getCoordinatesForElement.call(this,elem, true, null, overrideElementOffsets);
		return {
			t: { "tl": positions.tl, "t": positions.t, "tr": positions.tr },
			b: { "bl": positions.bl, "b": positions.b, "br": positions.br },
			r: { "tr": positions.tr, "r": positions.r, "br": positions.br },
			l: { "tl": positions.tl, "l": positions.l, "bl": positions.bl }
		};
	},
	/**
	 * Returns the side of an element (t,b,l,or r) that is the least visible (ie, most offscreen). This used for when the target point is a corner element and we need to determine which side to use (ie, if br, do we use bottom or right)
	 * @param {Object} allSides Collection of points on the element
	 * @param {String} specificPoint The point used for determining which sides to measure
	 */
	getLeastVisibleSide = function(allSides, specificPoint) {
		var visibleSideCounts = [];
		for (var side in allSides) {
			if (allSides.hasOwnProperty(side)) {
				for (var pointData in allSides[side]) {
					if (allSides[side].hasOwnProperty(pointData)) {
						var visiblePoints = 0;
						if (( typeof (specificPoint) != "undefined" && specificPoint == pointData)) {
							if (isPointInsideViewport(allSides[side][pointData]) === true) {
								visibleSideCounts.push({
									data: visiblePoints + 1,
									side: side
								});
							}
						}
					}
				}
			}
		}
		return visibleSideCounts.sort(compareObjects)[visibleSideCounts.length - 1];
	},
	/**
	 * Based on a collection, returns an array of points that are visible within the browser window
	 *  @param {Object} points Collection of points
	 */
	getVisiblePoints = function(points) {
		var visiblePoints = [], addedPositions = [];
		for (var i in points) {
			if (points.hasOwnProperty(i)) {
				for (var j in points[i]) {
					if (points[i].hasOwnProperty(j)) {
						if (isPointInsideViewport(points[i][j]) && $.inArray(j, addedPositions) === -1) {
							addedPositions.push(j);
							visiblePoints.push({
								side: i,
								position: j,
								point: points[i][j]
							});
						}
					}
				}
			}
		}
		return visiblePoints;
	},
	//Test each side's points against the anchorpoint
	/**
	 * Get the side of an element that is closest to a given point
	 * @param {Object} points Collection of points on the element
	 * @param {Object} coords The point we measure against
	 */
	getClosestSide = function(points, coords) {
		//for each of hte side's points, get distance from point, add up. the side wit the shortest distance is the closest to point
		var sides = [];
		for (var i in points) {
			if (points.hasOwnProperty(i)) {
				var totalSideDistance = 0;
				for (var y in points[i]) {
					if (points[i].hasOwnProperty(y)) {
						totalSideDistance = totalSideDistance + getDistance(coords, points[i][y]);
					}
				}
				sides.push({
					side: i,
					data: totalSideDistance
				});
			}
		}
		sides.sort(compareObjects);
		return sides[0];
	},
	/*
	 * Calculate the three points on each side of the element: the two corners and the center point
	 *  @param {Object} element The element to calculate the coordinates
	 *  @param {boolean} is_anchor Whether or not the element is the anchor
	 *  @param {Object} offsets Custom offsets for the target element
	 */
	getCoordinatesForElement = function(el, is_anchor, offsets, overrideElementOffsets) {
		offsets = (is_anchor) ? { x: 0, y: 0 }: offsets;
		var $el = $(el);
		// var wasHidden = ($.browser.msie && parseInt($.browser.version,10)===7) ? $el.is(":hidden") : $.data(el, "_cachedProperties").isHidden;
		// console.log(wasHidden);
		// if (wasHidden) {
			// $el.show();
		// }
		var el_offsets = overrideElementOffsets || getOffset.call(this, $el);
		// if (wasHidden) {
			// $el.hide();
		// }
		var el_props = {"width": $.data($el[0], "_cachedProperties").outerWidth, "height": $.data($el[0], "_cachedProperties").outerHeight};
		var leftEdge_leftPos = el_offsets.left - offsets.x,
			topEdge_topPos = el_offsets.top - offsets.y,
			bottomEdge_topPos = el_offsets.top + el_props.height + (offsets.y),
			rightEdge_leftPos = el_offsets.left + el_props.width + (offsets.x),
			center_topPos = el_offsets.top + Math.round((el_props.height - (offsets.y)) * 0.5),
			center_leftPos = el_offsets.left + Math.round((el_props.width - offsets.x) * 0.5);
		return {
			"r": 	{top: center_topPos,		left: rightEdge_leftPos},
			"tr": 	{top: topEdge_topPos,		left: rightEdge_leftPos},
			"t": 	{top: topEdge_topPos,		left: center_leftPos},
			"tl": 	{top: topEdge_topPos,		left: leftEdge_leftPos},
			"br": 	{top: bottomEdge_topPos,	left: rightEdge_leftPos},
			"b": 	{top: bottomEdge_topPos,	left: center_leftPos},
			"bl": 	{top: bottomEdge_topPos,	left: leftEdge_leftPos},
			"l": 	{top: center_topPos,		left: leftEdge_leftPos},
			"c": 	{top: center_topPos,		left: center_leftPos}
		};
	},
	/*
	 * Whether or not the target element is outside the container element
	 */
	isOffscreen = function(elem) {
		var $container = $(this.options["container"]);
		var container = $container[0];
		var $elem = $(elem);
		var scrollTop = $( ((container === window) ? document : container) ).scrollTop();
		var scrollLeft = $( ((container === window) ? document : container) ).scrollLeft();
		var elemOff = $elem.offset();
		var elemW = $.data(elem, "_cachedProperties").outerWidth, elemH = $.data(elem, "_cachedProperties").outerHeight;
		var winW = (container === window) ? $container.width() : $container.outerWidth(), winH = (container === window) ? $container.height() : $container.outerHeight(), winOff = (container === window) ? {
			left : 0,
			top : 0
		} : $container.offset();
		return (elemOff.top < scrollTop + winOff.top || elemOff.top + elemH > scrollTop + winH + winOff.top || elemOff.left < scrollLeft + winOff.left || elemOff.left + elemW > scrollLeft + winW + winOff.left);
	},
	//Shortcut to null if the container is too small for the target element.
	isContainerTooSmall = function(elem, pos) {
		var tooSmall = false;
		var $container = $(this.options.container);
		var veW = ($container[0] === window) ? $container.width() : $container.outerWidth(),
			veH = ($container[0] === window) ? $container.height() : $container.outerHeight();
		if (veW < $.data(elem, "_cachedProperties").outerWidth || veH < $.data(elem, "_cachedProperties").outerHeight) {
			tooSmall = true;
		}
		return tooSmall;
	},
    /**
     * If a filter was removed, add it back to the element
     * @param{Object} $elem 
     */
    reapplyIEShadow = function($elem) {
		//IE9 supports box-shadow
        if ($.browser.msie) {
            if ($.data($elem[0], "shadowFilter")) {
                $elem[0].style.filter = $.data($elem[0], "shadowFilter") + "";
            }
        }
    },
    /**
     * Remove the shadow filter from the element 
     * @param{Object} $elem 
     */
    removeIEShadow = function($elem) {
        if ($.browser.msie) {
            var filter = $elem[0].currentStyle.filter;
            if (typeof(filter) !== "undefined" && filter !== "") {
                $.data($elem[0], "shadowFilter", filter);
                $elem[0].style.filter = "";
            }
        }
    },
	getOldStyles = function($elem,options) {
		return {
			oldPosition : $elem.css("position"),
			oldLeft : $elem.css("left"),
			oldTop : $elem.css("top"),
			oldParent : $elem.parent()[0],
			oldIndex : $elem.index(),
			anchor : options["anchor"],
			zIndex : $elem.css("z-index")
		};
	},
	//cache all dimensions and other necessary data that are expensive to get that we will be potentially looping over when attempting to position
	gatherDimensions = function($elem) {
		if ($.isPlainObject($.data($elem[0], "_cachedProperties"))) {
			return true;
		}
		var elem = $elem[0];
		var doc = elem && elem.ownerDocument;
		var docElem = doc.documentElement;
		if (elem.getBoundingClientRect) {
			box = elem.getBoundingClientRect();
			box = {left:box.left, right:box.right, width:box.width, height:box.height, top:box.top, bottom:box.bottom, supported:"true"}
		} else {
			box = { top: 0, left: 0, width:0, height:0, "supported":false};
		}
		var outerWidth = box.width || (box.right - box.left) || $elem.outerWidth();
		var outerHeight = box.height  || (box.bottom - box.top) || $elem.outerHeight();
		//setting data first because getAllSides makes looks for _cachedProperties
		$.data(elem, "_cachedProperties", {outerWidth: outerWidth, outerHeight: outerHeight, box:box});
		$.data(elem, "_cachedProperties").allAnchorSides = getAllSides.call(this, elem);
	},
	clearDimensions = function($elem) {
		$elem.removeData("_cachedProperties");
	},
	filterCollectionForFixed = function(jqArray) {
		var isFixed = false;
		for (var i = 0; i < jqArray.length; i++) {
			if($(jqArray[i]).css("position") === "fixed") {
				isFixed = true;
				break;
			}
		};
		return isFixed;
	}
	//Position an element (or elements) according to a range of positions. If using a class and there are multiple elements, one positionable object will control all of them.
	snapTo = function(opts) {
		this.options = {
			element : "",
			anchor : ""
		};
		this.options = $.extend(this.options, defaults, opts);
		this.options.position = fixPositionString(this.options.position);
		this.positions = [];
		this.oppositeBasePositions = {"tl":"br", "br":"tl", "tr":"bl", "bl":"tr", "l":"r", "r":"l", "t":"b", "b":"t"};
		this.currentPosition = null;
		this.init(opts.element);
	};

	snapTo.prototype = {
		init: function($elem) {
			var options = this.options;
			var $anchor = $(this.options.anchor);
			var oThis = this;
			var elem = $elem[0]
            this.insideFixedContainer = filterCollectionForFixed($elem.parents());
            // $elem.parents().filter(function(){ if ($(this).css("position") === "fixed") { return true; } }).first().length === 1;

			if ( ! $.data(elem, "snapTo_oldStyles") ) {
				$.data(elem, "snapTo_oldStyles", getOldStyles($elem,options));
			}
			//shadow filters in IE add to element dimensions, so we will remove them here before the calculations and add them back later
			//no moving if we are unpositioning
			if (options.anchor !== false) {
				if (options.inline === true) {
					//move only if we need to
					if ($elem.siblings().filter($anchor[0]).length === 0) {
						$anchor.after($elem.detach());
					}
				} else {
					//move only if we need to
					if ($elem.parent().is("body") === false) {
						$("body").append($elem.detach());
					}
				}
			}
			if (!$.data(elem, "scrollBound")) {
				$.data(elem, "scrollBound", false);
			}
			if (!$.data(elem, "resizeBound")) {
				$.data(elem, "resizeBound", false);
			}

			$.data(elem, "snapTo_options", this.options);
			$elem.addClass("snapTo snapTo_initialized").addClass(options.customClass);
		},
		setOffsets: function(offsets) {
			//reset
			var options = this.options;
			if ( typeof offsets == "undefined" || offsets.length === 0) {
				options["offset"] = {
					x: 0,
					y: 0
				};
			}
			if (offsets.length == 1) {
				options["offset"] = {
					x: offsets[0],
					y: offsets[0]
				};
			} else {
				options["offset"] = {
					x: offsets[0],
					y: offsets[1]
				};
			}
		},
		getOption: function(key) {
			return this.options[key];
		},
		setOption: function(key, value) {
			this.options[key] = value;
		},
		/*
		 * Returns the target element to its original position in the DOM along with its original styles (if they were removed)
		 */
		unPosition: function() {
			var oThis = this;
			var $elem = $(this.options.element);
			if (!$elem.hasClass("snapTo_initialized")) {
				return false;
			}
			var oldStyles = $.data($elem[0], "snapTo_oldStyles");
			var index = oldStyles.oldIndex;
			var $oldParent = $(oldStyles.oldParent);
			var $children = $oldParent.children();
			//return to previous index
			if (index === 0 || $children.filter(":eq(" + (index - 1) + ")").length === 0) {
				$oldParent.prepend($elem.detach());
			} else {
				var $oldSibling = $children.filter(":eq(" + (index - 1) + ")");
				if ($oldSibling.next()[0] !== ($elem[0])) {
					$oldSibling.after($elem.detach());
				}
			}
			if (!isNaN(oldStyles.zIndex)) {
				$elem.css("z-index", oldStyles.zIndex);
			}
			$elem.css({
				"position": oldStyles.oldPosition,
				"top": (oldStyles.oldTop !== "auto") ? '': oldStyles.oldTop,
				"left": (oldStyles.oldLeft !== "auto") ? '': oldStyles.oldLeft
			}).removeClass("snapTo snapTo_initialized").removeData("oldStyles").removeData("snapTo_options");
		},
		//this is where the magic happens
		snap: function(pos, resetPositions, previousAnchorCoordinates, closestSide) {
			var oThis = this, options = this.options;
			//set up positions on first run
			var $elem = options.element;
			var elem = $elem[0], p = pos.split("-"), anchor = options["anchor"];
			//Shortcut -- detect if container is just too small overall for the popup. if it is we will just display how it is
			var tooSmall = isContainerTooSmall.call(this, elem, pos);
			if ($elem.trigger("dr-beforePosition", [oThis, elem]) === false) {
				reapplyIEShadow($elem);
				return true;
			}
			elem.style.left = "0px";
			elem.style.top = "0px";
			//determine if we need to invert offsets
			var anchorCoordinates = recalculateAnchorCoordinates.call(oThis, getCoordinatesForElement.call(oThis, anchor, true, options.offset)[p[1]]);
			var elemCoordinates = getCoordinatesForElement.call(oThis, elem, false, options.offset, {top:0, left:0})[p[0]];
			var x = anchorCoordinates.left;
			var y = anchorCoordinates.top;
			var elemX = elemCoordinates.left;
			var elemY = elemCoordinates.top;
			var topPos = y - elemY;
			var leftPos = x - elemX;
			elem.style.display = "block";
			elem.style.left = leftPos+"px";
			elem.style.top = topPos+"px";
			closestSide = closestSide || null;
			//TODO optimization: try preferredAltPositions before we even try to calculate these other sides
			if (resetPositions === true) {
				oThis.positions = [];

				var allAnchorSides = $.data(anchor, "_cachedProperties").allAnchorSides
				//var allAnchorSides = getAllSides.call(this, anchor, anchorcoordinates);
				var allElemSides = getAllSides.call(this,elem, {top:topPos, left:leftPos});
				closestSide = getClosestSide(allElemSides, anchorCoordinates);
				oThis.positions = createPositions.call(oThis, sortVisiblePoints(getVisiblePoints(allAnchorSides), anchorCoordinates), elemCoordinates, anchorCoordinates, elem, allAnchorSides, allElemSides, closestSide);
				oThis.positions.unshift.apply(oThis.positions, [pos].concat(options.preferredAltPositions));
				oThis.positions.push(options.position);
			}
			var currentIndex = $.inArray(pos, oThis.positions);
			//If current position is offscreen, try the next position until all have been tried
			if (tooSmall===false && (options["keepInView"] === true) && isOffscreen.call(oThis, elem) && oThis.positions.length - 1 != currentIndex) {
				oThis.positions[currentIndex] = null;
				var nextIndex = p === null ? oThis.positions.length - 1 : currentIndex + 1;
				oThis.snap(oThis.positions[nextIndex], false, anchorCoordinates, closestSide);
			} else {
				oThis.currentPosition = pos;
				$.data($elem[0], "currentPosition", pos);
				$.data(anchor, "snapToData", {
					"anchorCoordinates": anchorCoordinates,
					"finalCoordinates": {"top": topPos, "left": leftPos}
				});
				$.data(anchor, "snapToElem", elem);
				if (oThis.options.repositionOnScroll && $.data($elem[0], "scrollBound") === false) {
					scrollBoundElements.push($elem[0]);
					$.data($elem[0], "scrollBound", true);
				}
				if ($.data($elem[0], "resizeBound") === false) {
					$.data($elem[0], "resizeBound", true);
					resizeBoundElements.push($elem[0]);
				}
				reapplyIEShadow($elem);
				clearDimensions($elem);
				clearDimensions($(anchor));
				$elem.trigger("dr-afterPosition", [oThis, elem]);
				lastResizeTime = new Date().getTime();
			}
		}
	};

	$.namespace('dr', {
		snapTo: function(anchor, opts) {
			var $this = $(this);
			if ($this.is("body")) {
				return false;
			}
			if (!opts && typeof opts !== "string") {
				var inlineOpts = $this.attr("data-options");
				opts = $.dr.utils.evalString(inlineOpts);
			} else if ( typeof opts === "string") {
				opts = {
					position: opts
				};
			}
			if (!anchor && typeof (anchor) !== "boolean") {
				$.dr.utils.logError('Error calling $.dr.snapTo: anchor was not specified');
				return false;
			}
			if ( typeof (anchor) === "string") {
				anchor = $(anchor)[0];
				if (typeof anchor === "undefined") {
					$.dr.utils.logError('Error calling $.dr.snapTo: anchor was not specified');
					return this;
				}
			} else if(anchor instanceof $){
				anchor = anchor[0];
			}
			if ($this.find("*").filter(anchor).length > 0 || this === anchor) {
				$.dr.utils.logError('Error calling $.dr.snapTo: anchor cannot be target element or inside target element.');
				return false;
			}
			opts = opts || {};
			opts.anchor = anchor;
			opts.element = $this;
			var snapto = new snapTo(opts);
			if (anchor === false) {
				snapto.unPosition();
			} else {
				gatherDimensions.call(snapto, $this);
				gatherDimensions.call(snapto, $(anchor));
				snapto.snap(snapto.getOption("position"), true);
			}
			return this;
		}
	});
	$.dr.addDomReadyEvent(function() {
		var $window = $(window);
		$window.bind("resize.snapToReposition", function(e) {
			var currentTime = new Date().getTime();
			if (currentTime - lastResizeTime > 200){
				$.dr.utils.waitForFinalEvent(function() {
					for (var i = 0; i < resizeBoundElements.length; i++) {
						var elem = resizeBoundElements[i], $elem = $(elem);
						if ($elem.is(":visible") === false) {
							return true;
						}
						var wasHidden = $elem.css("display") == "none";
						$elem.dr.snapTo($.data(elem, "snapTo_options").anchor, $elem.data("snapTo_options"));
						if (wasHidden) {
							elem.style.display = "none";
						}
					}
				}, 210, "snapToResizing");
                lastResizeTime = currentTime;
			}
		});
		$window.unbind("scroll.snapToPluginManagement").bind("scroll.snapToPluginManagement", function() {
			$.dr.utils.waitForFinalEvent(function() {
				for (var i = 0; i < scrollBoundElements.length; i++) {
					var elem = scrollBoundElements[i], $elem = $(elem);
					if (elem.style.display == "none") {
						return true;
					}
					var anchor = $.data(elem, "snapTo_options").anchor;
					if ($elem.offset().top < $window.height() + $(window).scrollTop() && $elem.is(":visible")) {
						var opts = $.data(elem, "snapTo_options");
						$(elem).dr.snapTo(anchor, opts);
						$elem.trigger("dr-reposition");
					}
				}
			}, 120, "snapToReposition");
		});
	});

	$.dr.addUnobtrusiveEvent(function(e, context) {
		var updateVisibility = function(evt) {
			var snapToElems = $(".snapTo_initialized:visible");
			if (snapToElems.length === 0) {
				return false;
			}
			for (var i = 0; i < snapToElems.length;i++) {
				var $this = $(snapToElems[i]);
				if ($this.length===0) {
					continue;
				}
				var opts = $.data($this[0], "snapTo_options");
				if (typeof opts != "undefined" && opts.inline || typeof opts === "undefined") {
					continue;
				}
				var anchor = opts.anchor;
				var inside_tabs = $(anchor).parents("dl.tabs").length >= 1;
				if ($(anchor).is(":visible")) {
					(inside_tabs) ? $this.fadeIn(5) : snapToElems[i].style.display = "block";
				} else {
					(inside_tabs) ? $this.fadeOut(5) : snapToElems[i].style.display = "none";
				}
			}
		};

		$("dl.tabs", context).unbind(".snapToPluginManagement").bind("afteranimate.snapToPluginManagement", function(evt) {
			updateVisibility.call(this, evt);
		});
		$("dl.accordion", context).unbind(".snapToPluginManagement").bind("accordionchange.snapToPluginManagement", function(evt) {
			updateVisibility.call(this, evt);
		});
		$("dl.fingertabs", context).unbind(".snapToPluginManagement").bind("afterchange.snapToPluginManagement", function(evt) {
			updateVisibility.call(this, evt);
		});
		$("div.collapsible", context).unbind(".snapToPluginManagement").bind("collapsiblechange.snapToPluginManagement", function(evt) {
			updateVisibility.call(this, evt);
		});

	});
})(jQuery);
(function($){
    /*
     * Bind a callback to 4 of the events in Beacon which can hide elements: tabs, fingertabs, accordions, and collapsible
     * @param context context in which to bind the event selectors
     * @param once whether or not to fire the event once
     * @param fn callback function
     */
    var onVisible = function(context, once, fn){
        context = context || document;
        var _this = $(this);
        var selectors = ["dl.tabs", "dl.accordion", "dl.fingertabs", "div.collapsible"];
        var events = ["afteranimate.onVisible", "accordionchange.onVisible", "afterchange.onVisible", "collapsiblechange.onVisible"];
        //filter the selectors to get parents of the scoped element
        var $filtered = $(this).parents(selectors.join(","));
        var callback = function() {
            if (_this.is(":visible")) {
                fn();
            }
        }
        if (once === true) {
            $($filtered, context).one(events.join(" "), callback);
        } else {
            $($filtered, context).bind(events.join(" "), callback);
        }
    }
    var disabledElements = [];
    var defaults = {
        showCloseButton:true,
        theme:          "orange",
        position:       "l-r",
        content:        null,
        showOnInit:     true,
        customClass:    "stickyPopup"
    };
    var isDefined = function(aVar) {
        return (typeof(aVar) !== "undefined" && aVar !== null);
    };
    /* Set dataSources for the central dataSources collection*/
    var setDataSources = function(sources) {
        if (this.dataSources.length === 0 && typeof(sources) != "undefined" && sources.length > 0) {
            for (var j = sources.length - 1; j >= 0; j--) {
                setupDataSourceContent(sources[j]);
            }
            this.dataSources = sources;
            return;
        }
        var toAddToDataSources = [];
        for (var i = this.dataSources.length - 1; i >= 0; i--) {
            for (var j = sources.length - 1; j >= 0; j--) {
                setupDataSourceContent(sources[j]);
                if (sources[j].element === this.dataSources[i].element) {
                    this.dataSources[i] = sources[j];
                } else {
                    toAddToDataSources.push(sources[j]);
                }
            };
        };
        $.merge(this.dataSources, toAddToDataSources);
    };
    var setupDataSourceContent = function(source) {
        if ($(source.element).hasClass(".stickyInited") === true) {
            delete source;
        }
        var inlineContent = $(source.element).attr("data-stickycontent");
        if (typeof(inlineContent) != "undefined") {
            source.content = inlineContent;
        }
        var inlineURL = $(source.element).attr("data-stickyurl");
        if (typeof(inlineURL) != "undefined") {
            source.url = inlineURL;
        }
    }
    var getDataSource = function(elem) {
        for (var i = this.dataSources.length - 1; i >= 0; i--) {
            if ($(this.dataSources[i].element)[0] == $(elem)[0]) {
                return this.dataSources[i];            
            }
        };
        return null;
    }
    var init = function($elem) {
        var _this = this;
        if ($elem.hasClass("stickyInited")) {
            return false;
        }
        var opts = $.extend(true, {sticky:true, inline:true, showArrow: true, shared:false}, this.options, getDataSource.call(this, $elem), $.dr.utils.evalString($elem.attr("data-options")));
        opts.customContent = opts.content;
        delete opts.content;
        $($elem.not(".stickyInited")).dr.hover(opts);
                
        $elem.each(function(){
            var $this = $(this);
            $this.addClass("stickyInited sticky");
            $.data(this, "Sticky", {StickyInstance: _this, isHidden: true, enabled:true});
            //set the content for the popup before the Hover render step
            $this.bind("dr-beforeRender",function() {
                var data = $.data(this, "Sticky");
                if (data.position) {
                    $(this).dr.hover.setOption("position", data.position, this);
                }
                if (isDefined(data.dataSource)) {
                    if (isDefined(data.dataSource.url)) {
                        $(this).dr.hover.setOption("url", data.dataSource.url, this);
                        return null;
                    } else {
                        return data.dataSource.content;
                    }
                }
            });
        });

        if (opts.showOnInit && $elem.is(":visible")) {
            $($elem).dr.hover.show()
        }
        if (opts.showOnInit && !$elem.is(":visible")){
            //if sticky elem is initially hidden, show when elem is visible
            onVisible.call($elem, document, false, function(){
                if ($elem.data("Sticky").isHidden === true) {
                    $($elem).dr.sticky.show();
                }
            });
        }
    };
    var Sticky = function(ds, opts) {
        var _this = this;
        this.dataSources = [];
        this.options = $.extend(true, {}, defaults, opts);
        var disabledSelectors = $.dr.sticky.getDisabledElements().join(", ");
        if (ds.length > 0) {
            setDataSources.call(this, ds);
        } else {
            $.dr.utils.logError("A data source is required.");
            return false;
        }
        for (var i = ds.length - 1; i >= 0; i--) {
            var $elem = $(ds[i].element);
            if ($elem.not(".stickyInited") && $(disabledSelectors).filter($elem).length === 0) {
                init.call(this, $elem);
            }
        }
    };
    Sticky.prototype = {
        setOption : function(key,value) {
            if (isDefined(key)) {
                this.options[key] = value;
            }
        }
    };

    /* Public Interface */
    $.dr.sticky = {
        setup : function(ds, opts) {
            opts = opts || {};
            ds = ds || [{}];
            return new Sticky(ds, opts);
        },
        setShowAllStickiesText: function(text) {
            showAllStickiesText = text;
        },
        setDisabledElements : function(elems) {
            if (isDefined(elems) && elems != "") {
                disabledElements.push(elems);
            }
        },
        addDisabledElement : function(elem) {
            if (isDefined(elem) && $(elem).length === 1) {
                disabledElements.push(elem);
            }
        },
        getDisabledElements : function() {
            return disabledElements.slice();
        }
    };
    $.namespace('dr', {
        sticky : function (opts) {
            opts = opts || {};
            try {
                var ds = [{"element": this, "content": opts.content}];
                $.dr.sticky.setup(ds, opts);
            } catch(e) {
                return false;
            }
            return this;
        }
    });    
    //add namespace sticky

    $.namespace('dr.sticky', {
        hide : function () {
            $(this).each(function(){
                var $this = $(this);
                if ($this.hasClass("stickyInited")) {
                    $this.data("Sticky").isHidden = true;
                    $this.dr.hover.hide();
                }
            });
        },
        show : function() {
            $(this).each(function() {
                var $this = $(this);
                if ($this.hasClass("stickyInited")) {
                    var data = $this.data("Sticky");
                    if (data.enabled !== false) {
                        $(this).dr.hover.show();
                        $(this).data("Sticky").isHidden = false;
                        $(this).dr.hover.refresh();
                    }
                }
            });
        },
        enable : function() {
            $(this).each(function(){
                if ($(this).hasClass("stickyInited")) {
                    $this.data("Sticky").enabled = true;
                }
            });
        },
        disable : function() {
            $(this).each(function(){
                var $this = $(this);
                if ($this.hasClass("stickyInited")) {
                    $this.data("Sticky").enabled = false;
                    $this.dr.hover.hide();
                }
            });
        },
        refresh : function() {
            $(this).each(function() {
                if ($(this).hasClass("stickyInited")) {
                    $(this).dr.hover.refresh();
                }
            });
        },
        setOption : function(key, value) {
            $(this).each(function(){
                var $this = $(this);
                if ($this.hasClass("stickyInited")) {
                    $.data($this[0],"Sticky").StickyInstance.setOption(key,value);
                }
            });
        }
    });   
    $.dr.addUnobtrusiveEvent(function(){
        $(".sticky:not(.stickyInited)").each(function(){
            var $this = $(this);
            if (typeof($this.attr("data-stickycontent")) !== "undefined" && $this.parents("pre").length === 0) {
                setTimeout(function(){
                    $($this).dr.sticky();
                },1);
            }
        });
    });
})(jQuery);
;(function($){
    var currentPath = '';
    var defaults = {
        deepLink: true,
        activeTab: 0,
        ajaxLoad : false,
        displayEffect: {
            animation: 'fade',
            speed: 'normal'
        },
        tabWidth: "auto", // auto | small | medium | large,
        scrollingTabs: false,
        showNewTabButton:false,
        showDeleteTabButton:false,
        showNewTabOverlay: true,
        showNewTabPrompt: true,
        openNewTabsInBackground: false,
        messages: {
            deleteTabWarning: "Are you sure you want to delete this tab?",
            deleteTabTitle: "Delete Tab",
            duplicateTabTitle: "Duplicate Tab",
            duplicateTabMessage: "The name '{0}' is already used by another tab. Please enter a different name.",
            newTabMessage: "Enter a new tab name:",
            newTabDefaultValue: "New Tab",
            newTabTitle: "New Tab"
        }
    };
    var isIE = $.browser.msie === true && parseInt($.browser.version, 10) <= 9;
    var AUTO_WIDTH = $.browser.msie === true && parseInt($.browser.version, 10) < 9 ? "" : "auto";
    var winWidth = 0;
    var winHeight = 0;
    //padding between rightmost navtab and edge of tab container
    var RIGHT_PADDING = 5;
    var MINIMUM_PADDING_LIMIT = 3;
    var tabPadding = 0;
    var NEW_TAB_TMPL = "<dt class='tab'>{0}</dt>";
    var NEW_TAB_CONTAINER_TMPL = "<dd style='display:none;' class='tabContainer'><div class='tabContent'>{0}</div></dd>";
    var TAB_BACK_TMPL = "<dt class='tabBack navTab' unselectable='on'><div unselectable='on' class='tabBackArrow'><<</div></dt>";
    var TAB_FORWARD_TMPL = "<dt unselectable='on' class='navTab tabForward'><div unselectable='on' class='tabForwardArrow'>>></div></dt>";
    var TAB_OVERFLOW_TAB = "<dt class='navTab overflowButton' unselectable='on'><div unselectable='on'>&#9660;</div></dt>";
    var TAB_CREATE_TAB_TMPL = "<dt class='navTab createNewTab' unselectable='on'><div unselectable='on'>+</div></dt>";
    var HOVERED_BG_POSITION = -535;
    var DEFUALT_BG_POSITION = -500;
    function hoverOver(){
        if ($(this).is(".active")) {
            return true;
        }
        $(this).dr.bgAnimate("y", {"end": HOVERED_BG_POSITION, unit:"px"});
    }
    function hoverOut(){
        if ($(this).is(".active")) {
            return true;
        }
        $(this).dr.bgAnimate("y", {"end": DEFUALT_BG_POSITION, unit:"px"});
    }
    //x and y expected to be string values with the unit
    function setBackgroundPosition(x,y) {
        if ($.browser.msie7 || $.browser.msie8) {
            $(this).css("background-position-x", x);
            $(this).css("background-position-y", y);
        } else {
            $(this).css("backgroundPosition", x+" "+y);
        }
    }
    /* Get the tabs which will fit */
    function sumArray(arr) {
        var total = 0;
        for (var i = 0; i < arr.length;i++) {
            total = total + arr[i];
        }
        return total;
    }
    /* Returns the total padding for the tabset */
    function getCurrentTotalPadding($tabs) {
        var containsTabLinks = false;
        $tabs.each(function(){
            if ($(this).children("a").length === 1) {
                containsTabLinks = true;
                return false;
            }
        });
        if (containsTabLinks === true) {
            sumArray($tabs.map(function(){
                return parseInt($(this).css("paddingLeft"),10)*2;
            }).get());
        }
        return parseInt($tabs.eq(0).css("paddingLeft"), 10);
    }
    /* Returns the total width of all the tabs within the tabset */
    function getTotalWidthOfTabs($tabs) {
        var $tabSet = $tabs.eq(0).parent("dl.tabs");
        var tabSetIsHidden = $tabSet.is(":hidden");
        return sumArray($tabs.map(function(){
            var $this = $(this);
            if (tabSetIsHidden) {
                return $($this).dr.utils.getHiddenDimensions().outerWidth;
                //return getWidthOfTabBasedOnText($(this)) + padding;
            } else {
                return $this.outerWidth();
            }
        }).get());
    }
    function getMaximumWidthForTabSet(includeNavTabs) {
        var tabData = this.data("tabData");
        var $allTabs = this.children("dt");
        var opts = tabData.options;
        var maxWidth = tabData.containerWidth;
        if (maxWidth <= 0) {
            maxWidth = setContainerWidth.call(this);
        }
        if (opts.showNewTabButton === true) {
            maxWidth =  maxWidth - $allTabs.filter("dt.createNewTab").outerWidth();
        }
        if (includeNavTabs === true) {
            maxWidth = maxWidth - getTotalWidthOfTabs(this.children(".tabForward:visible, .tabBack:visible, .overflowButton:visible"));
        }
        return maxWidth;
    }
    function setContainerWidth() {
        var w =  this.outerWidth() - RIGHT_PADDING;
        if (typeof(this.data("tabData")) !== "undefined") {
            this.data("tabData").containerWidth = w;
        } else {
            this.data("containerWidth", w);
        }
        return w;
    }
    function setPerTabPadding($tabs, padding) {
        var p = padding;
        for (var i = 0; i < $tabs.length; i++) {
            var $anchor = $tabs.eq(i).children("a");
            p = (padding === "auto") ? getInternalTabPadding($tabs.eq(i)) : padding;
            p = Math.max(p, 6);
            if ($anchor.length === 1) {
                $anchor.css("paddingLeft", p+"px").css("paddingRight", p+"px");
            } else {
                $tabs.eq(i).css("paddingLeft", p+"px").css("paddingRight", p+"px");
            }
        }
    }
    function getInternalTabPadding($dt) {
        var p = $dt.data("tabPadding");
        if (p <= 0) {
            p = setInternalTabPadding($dt);
        }
        return p;
    }
    function setInternalTabPadding($dt) {
        var p = 0;
        if ($dt.hasClass("tabLink")) {
            p = parseInt($dt.children("a").css("paddingLeft"),10);
        } else {
            p = parseInt($dt.css("paddingLeft"),10);
        }
        $dt.data("tabPadding", p);
        return p;
    }
    /*
    * Returns whether the reducing to the padding of all the tabs to the given padding will make all the tabs fit within the width of the container
    */
    function doesPaddingFit($tabs, maximumWidth, padding, totalTabWidth) {
        var currentTotalPadding = getCurrentTotalPadding($tabs);
        var numOfTabs = $tabs.length;
        //calculate the width of the tabs without any padding. maximumWidth+difference means the width of the container minus the width of the navtabs + how much the tabs overflow
        var withZeroPadding = totalTabWidth - currentTotalPadding
        return (withZeroPadding+((padding*2)*numOfTabs) < maximumWidth)
    }
    /*
    * Set the padding for all the tabs in the tabset. If newPadding is null, it will reduce the padding until the minimum
    */
    function setPadding(totalTabWidth, maximumWidth, newPadding) {
        var $tabs = this.children("dt.tab");
        var currentPadding = parseInt($tabs.eq(0).css("paddingLeft"), 10);
        var totalNumberOfTabs = $tabs.length;
        if (newPadding != null) {
            setPerTabPadding($tabs, newPadding);
            return false;
        }
        while (!doesPaddingFit($tabs, maximumWidth, currentPadding, totalTabWidth) && currentPadding >= MINIMUM_PADDING_LIMIT) {
            currentPadding = currentPadding - 1;
        }
        setPerTabPadding($tabs, currentPadding);
    }
    /*
    * A wrapper around doesPaddingFit(), returns whether the reducing to the padding of all the tabs to the MINIMUM padding will make all the tabs fit within the width of the container
    */
    function willReducingToMinPaddingFit(totalTabWidth, maximumWidth) {
        //will reducing the padding to the minimum overcome the difference?
        return doesPaddingFit(this.children("dt.tab"), maximumWidth, MINIMUM_PADDING_LIMIT, totalTabWidth)
    }
    /* Returns the width based on the text within the tab and a letter width */
    function getWidthOfTabBasedOnText($tab) {
        return $tab.text().length * LETTER_WIDTH;
    }
    /* Set the widths for each tab in the tabset, setting the width either on the tabLink or tab*/
    function setTabWidths(w) {
        if (!isNaN(w) && w !== "") {
            w = w + "px";
        }
        $(this).each(function(){
            if ($(this).hasClass("tabLink")) {
                var firstChild = (this).children(":first-child")[0];
                if (firstChild) {
                    firstChild.style.maxWidth = w;
                    firstChild.style.width = w || "auto";
                    firstChild.style.minWidth = w;
                //$(this).children(":first-child").css({"maxWidth": w, "width": w || "auto", "minWidth": w});
                }
            } else {
                $(this).css("width","");
                $(this).css("minWidth","");
                $(this).css("maxWidth","");
                this.style.maxWidth = w;
                this.style.width = w || "auto";
                this.style.minWidth = w;
                //$(this).css({"maxWidth":w, "width": w || "auto", "minWidth": w});
            }
        });
    }
    /* fits all the tabs within the constraints of the container. Returns whether or not it was able to make all the tabs fit */
    function updateTabWidths() {
        var $tabSet = this;
        var maximumWidth = getMaximumWidthForTabSet.call($tabSet);
        var $tabs = $tabSet.children("dt.tab");
        var options = $tabSet.data("tabData").options;
        var numOfTabs = $tabs.length;
        //reset tabs to standard width and padding
        setTabWidths.call($tabs, AUTO_WIDTH);
        //TODO get the actual padding if tabLink, set to plugin variable during setup tab, store in the data
        setPerTabPadding($tabs, "auto");
        var totalTabWidth = getTotalWidthOfTabs($tabs);
        var tabsDoNotFit = totalTabWidth > maximumWidth;
        var didSqueeze = true;
        if (tabsDoNotFit) {
            //tabs are too big, lets try to squeeze them down!
            if (willReducingToMinPaddingFit.call($tabSet, totalTabWidth, maximumWidth, null)) {
                //PHASE 1 - reduce padding
                setPadding.call($tabSet, totalTabWidth, maximumWidth, null);
                didSqueeze = true;
            } else {
                //PHASE 2 - fixed width based on average width of tabs
                //measuring only the inner width of the tab, ie, width minus padding and margin and border
                maximumWidth = getMaximumWidthForTabSet.call($tabSet,true);
                var tabWidth = {"small":35,"medium":60, "large":100, "auto": parseInt(totalTabWidth / numOfTabs,10)}[options.tabWidth];
                setTabWidths.call($tabs, tabWidth);
                setPerTabPadding($tabs, 6);
                hideOverflowTabs($tabSet);
                var activeTab = $tabSet.data("activeTab") || $tabSet.data("tabData").options.activeTab;
                if ($tabs.eq(activeTab).is(":hidden")) {
                    //$tabs.eq(options.activeTab).show();
                    hideOverflowTabs($tabSet);
                }
                didSqueeze = false;
            }
        }
        $tabSet.trigger("updatedTabWidths", [didSqueeze]); 
        return didSqueeze;
    }
    /* Enable or disable the navigation tabs depending on whether or not there are any hidden tabs to the left or right. */
    function enableDisableNavTabs($tabs) {
        var $firstTab = $tabs.first();
        if ($firstTab.is(":visible")) {
            $firstTab.prev(".tabBack").addClass("disabled");
        } else {
            $firstTab.prev(".tabBack").removeClass("disabled");
        }
        var $lastTab = $tabs.last();
        if ($lastTab.is(":visible")) {
            $lastTab.siblings(".tabForward").addClass("disabled");
        } else {
            $lastTab.siblings(".tabForward").removeClass("disabled");
        }
    }

    /* Depending on the direction the user clicks, hide and show certain tabs to make it appear as if we are scrolling horizontally through the tabset */
    function shiftTabs($allTabs, $shownTab, $button) {
        //only one tab is visible, so we're all fine here, thank you. how are you?
        if ($allTabs.length === 0) {
            return false;
        }
        var maximumWidth = getMaximumWidthForTabSet.call($allTabs.eq(0).parent(), true);
        var indexes = $allTabs.map(function(){ return $(this).index(); }).get(); 
        if ($button.hasClass("tabBack")) {
            $allTabs = $($allTabs.get().reverse());
        }
        var $visibleTabs = $allTabs.filter(":visible");  
        if (getTotalWidthOfTabs($visibleTabs) > maximumWidth) {
            $visibleTabs.each(function() {
                //we need to refilter the tabs since we've hiden one
                if (getTotalWidthOfTabs($allTabs.filter(":visible")) > maximumWidth) {
                    $(this)[0].style.display = "none";
                }
            });
        }
        enableDisableNavTabs(($button.hasClass("tabBack")) ? $($allTabs.get().reverse()) : $allTabs);
    }
    function findCenterTab($startTab, $visibleTabs) {
        if ($startTab.is(":visible")) {
            return $startTab;
        }
        var tabsArray = $visibleTabs.get();
        return $(tabsArray[Math.ceil(tabsArray.length/2)]);
    }
    /* Hide the tabs which will not fit in the tabset, centered around the activeTab */
    function hideOverflowTabs($tabSet) {
        //hide each tab until the width is greater than or equal to the shownTab
        //we can know when to reverse the array if the tab is greater than the middle
        var $allTabs = $tabSet.find(".tab");
        var $visibleTabs = $allTabs.filter(":visible");
        var maximumWidth = getMaximumWidthForTabSet.call($tabSet,true);
        var options = $tabSet.data("tabData").options;
        var $selectedTab = ($allTabs.filter(".active").length === 1) ? $allTabs.filter(".active") : $allTabs.eq(options.activeTab);
        var selectedTabHidden = $selectedTab.is(":hidden");
        var $cTab = $lastTab = $currentlyVisibleTabs = findCenterTab($selectedTab, $visibleTabs);
        $allTabs.hide();
        $cTab.show();
        var $oldTab = null;
        //filter tabs left and right from the selectedTab until we don't fit, then break loop
        var numOfTabs = $allTabs.length;
        for (var i = 0; i < numOfTabs; i++){
            $oldTab = $cTab;
            if ($lastTab.prev(".tab").is(":hidden") && i % 2 === 1) {
                $cTab = $lastTab.prev(".tab");
            }
            if ($lastTab.next(".tab").is(":hidden") && i % 2 === 0) {
                $cTab = $lastTab.next(".tab");
            }
            if ($oldTab[0] === $cTab[0]) {
                $cTab = $lastTab.prev(".tab").length === 0 ? $cTab.next(".tab") : $cTab.prev(".tab"); 
                $oldTab = $lastTab;
            }
                $cTab.show();
            $currentlyVisibleTabs = $currentlyVisibleTabs.add($cTab);
            if (getTotalWidthOfTabs($currentlyVisibleTabs) > maximumWidth) {
                $cTab.hide();
                break;
            }
            $lastTab = $oldTab;
        }
        enableDisableNavTabs($allTabs);
    }
    function setupTabIndexes($tabs) {
        $tabs.each(function(i,e) {
            $(this).attr("data-tabindex",i);
        });
    }
    /*  */
    function activateTab(count, animateFunction, speed, options){
        var $this = $(this);
        activeTab = count;
        var $allTabs = $this.children("dt.tab");
        var $activeTab = $allTabs.eq(count);
        var $tabPanel = $this.find('> dd').hide().eq(count).show().end().find('> div.tabContent').hide().eq(count);
        var $oldActiveTab = $allTabs.filter(".active");
        var selectedTab = $allTabs.removeClass('active').eq(count).addClass('active')[0];
        var customAnimate = $this.add(selectedTab).drTriggerEach('beforeanimate', [$tabPanel[0], count, selectedTab]);
        var afterAnimate = function(){
            $this.add(selectedTab).drTriggerEach('afteranimate', [$tabPanel[0], count]);
        };
        if ($oldActiveTab.length > 0) {
            setBackgroundPosition.call($oldActiveTab,"0px", DEFUALT_BG_POSITION+"px");
        }
        
        if (customAnimate === false || speed===0 ) {
            // If Boolean false was returned from 'beforeanimate', don't do any animation at all, and simply show the panel
            $tabPanel.show();
            if (!options.ajaxLoad) {
                afterAnimate.call($tabPanel[0]);
            }
        } else if ($.isFunction(customAnimate)) {
            // If a custom animate function was returned from the 'beforeanimate' event, use it instead of the default
            customAnimate.call($tabPanel[0], afterAnimate);
        } else {
            animateFunction.call($tabPanel, speed, afterAnimate);
        }

        if (options.ajaxLoad) {
            var anchor = $activeTab.find("a");
            var ajaxParam = $(anchor).attr("data-ajax-param");
            var ajaxUrl = $(anchor).attr("href");
        
            $tabPanel.show();
            if (ajaxUrl !== null && !$($tabPanel).dr.ajaxpanel.loaded()) {
                $($tabPanel).dr.ajaxpanel(
                {url:ajaxUrl,
                params:ajaxParam,
                loadsuccess: function(event, data, textStatus, XMLHttpRequest){
                        afterAnimate.call($tabPanel[0]);
                        return true;
                    }
                });
            }
        }

        $this.data("activeTab", activeTab);
    }
    function tabEventIsValid(count, success){
        var allowTab = true;
        var $this = $(this);
        // Do some checking if we have an existing activeTab to check against
        var activeTab = $this.data("activeTab");
        if (!isNaN(activeTab)) {
            if (count === activeTab) {
                allowTab = false;
            } else {
                // Fire off a custom event to give someone the ability to keep the tab from switching
                var currentTabPanel = $this.find('> dd:eq('+activeTab+') > div.tabContent')[0];
                allowTab = $this.find('> dt.tab').eq(activeTab).add($this).drTriggerEach('beforechange', [currentTabPanel, activeTab, count]);
            }
        }
        return (allowTab !== false);
    }
    function setupTab($tab, count, options, animation, useDeepLink) {
        var $dt = $tab;
        var $this = $(this);
        // Look for any missing classes
        var dtClass = '';
        if (!$dt.hasClass('tab')) {
            dtClass = 'tab ';
        }
        if ((count === 0) && !$dt.hasClass('first')) {
            dtClass += 'first ';
        }
        if ($dt.hasClass('active')) {
            defaultTab = count;
            $this.data('defaultTab', defaultTab);
        }
        if ($('a', $dt[0]).length) {
            dtClass += 'tabLink';
            // if there is an <a> tag inside the DT, then turn off the deep linking
            useDeepLink = false;
        }
        else if (!useDeepLink && !$dt.hasClass('preventClick')) {
            $dt.bind('click show', function(){
                if (tabEventIsValid.call(this, count)) {
                    if (count != $(this).attr("data-tabIndex")) {
                        count = $(this).attr("data-tabIndex");
                    }
                    activateTab.call($this[0], count, animation.show, animation.speed, options);
                }
                return false;
            });
        }

        $dt.find("> a").bind("click",function(e) {
            if (tabEventIsValid.call(this, count) && true) {
                if (count != $(this).parent("dt").attr("data-tabIndex")) {
                    count = $(this).parent("dt").attr("data-tabIndex");
                }
                activateTab.call($this[0], count, animation.show, animation.speed, options);
            }
            if (options.ajaxLoad) {
                e.preventDefault();
            }
        });
        // Add any missing classes to this DT
        if (dtClass.length) {
            $dt.addClass($.trim(dtClass));
        }
        setInternalTabPadding($dt);
        if (isIE) {
            $dt.attr("unselectable", "on");
        }
        return useDeepLink;
    }
    function setTabIdArray(tabIDArray) {
        this.data("tabIDArray", tabIDArray);
    }
    /* This will only get called when deepLinking is turned on. Otherwise, activeTab will called directly */
    function initAddress(options, animation){
        var tabIDArray = [];
        var $this = $(this);
        $this.find('> dt.tab').each(function(count){
            var $dt = $(this);
            var label = encodeURI((count === 0) ? '/' : '/' + $.trim($dt.text()).replace(/\s+/g, "-"));
            $dt.unbind("click.initAddress");
            $dt.data('label', label).data('count', count).bind("click.initAddress", function(){
                if (tabEventIsValid.call($this[0], count)) {
                    $.address.value($(this).data('label'));
                }
                return false;
            });
            tabIDArray.push(label.toLowerCase());
        });
        setTabIdArray.call($this, tabIDArray);
        $.address.change(function(event){
            var eventValue = encodeURI($.trim(event.value)).toLowerCase();
            var count = $this.find('> dt.tab').filter(function(){
                var _label = $(this).data('label');
                return (_label) ? (_label.toLowerCase() == eventValue) : false;
            }).data('count');
            //If a tab does not exist, default to options.activeTab
            if (typeof(count) === "undefined" || count <= 0) {
                activateTab.call($this[0], options.activeTab || 0, animation.show, animation.speed, options);
            }
            var activeTab = $this.data("activeTab");
            var defaultTab = $this.data('defaultTab');
            if (activeTab != count && currentPath != event.path) {
                if (typeof activeTab === 'undefined' && typeof defaultTab !== 'undefined' && event.path == '/') {
                    count = defaultTab;
                }
                var matchedId = false;
                var tabIDArray = $this.data("tabIDArray");
                for (var i = 0; i < tabIDArray.length; i++) {
                    if (tabIDArray[i] == eventValue) {
                        activateTab.call($this[0], count, animation.show, animation.speed, options);
                        matchedId = true;
                        break;
                    }
                }
                if (matchedId === false) {
                    if (eventValue === "/" || $("#"+eventValue).length < 1) {
                        activateTab.call($this[0], 0,animation.show,animation.speed, options);
                    }
                }
                //Don't attempt to hide overflow tabs if the selected tab is already visible
                if ($this.children("dt.tab").eq(count).is(":hidden")) {
                    hideOverflowTabs($this);
                }
            }
            currentPath = event.path;

        });
    }
    function setupDeepLinking(useDeepLink, options, animation, updatingDeepLink) {
        var $this = $(this);
        if (useDeepLink) {
            if ($.address.ready()) {
                initAddress.call(this, options, animation);
            } else {
                $(document).bind("onAddressActivated",function(){
                    initAddress.call($this[0], options, animation);
                });
                $.address.activate();
            }
        } else {
            if (updatingDeepLink !== true) {
                    activateTab.call($this[0], $this.data('defaultTab') || options.activeTab, animation.show, 0, options);                
            }
        }
    }
    function addCreateNewTab($tabSet) {
        var $insertionTab = $tabSet.children(".tabForward");
        if ($insertionTab.length === 0) {
            $insertionTab = $tabSet.children("dt.tab:last");
        }
        return $insertionTab.after(TAB_CREATE_TAB_TMPL).next(".navTab");
    }
    function createRemoveButton() {
        var $button = $(document.createElement("div")).attr("unselectable","on").addClass("removeTab").append("x");
        $(this).data("tabData").removeButton = $button;
        return $button;
    }
    function addNavigationTabs($tabSet, options) {
        //change tabs left border color
        var $tabs = $tabSet.children("dt.tab");
        $tabs.first().css("border-left","1px solid white");
        var $lastTab = $tabs.first().before(TAB_BACK_TMPL).end().last();
        $lastTab.after(TAB_FORWARD_TMPL + TAB_OVERFLOW_TAB);
        //events needed because IE7 is confused about :active
        var $navTabs = $tabSet.children("dt.navTab");
        bindOverflowFlyoutHandler.call($tabSet, $navTabs.filter(".overflowButton"), $tabSet.data("tabData").options);
        return $navTabs;
    }
    function hideNavigationTabs($tabSet) {
        var $tabs = $tabSet.children("dt");
        $tabs.filter(".tab").first().css("border-left","1px solid #ccc");
        var $navTabs = $tabs.filter("dt.tabForward, dt.tabBack, dt.overflowButton");
        var $navTabsWereVisible = $navTabs.filter(".tabForward,.tabBack").is(":visible");
        $navTabs.hide();
        return $navTabsWereVisible;
    }
    function showNavigationTabs($tabSet) {
        var $tabs = $tabSet.children("dt");
        var $backAndForwardButtons = $tabs.filter(".tabForward, .tabBack, .overflowButton");
        if ($backAndForwardButtons.length === 0) {
            var $backAndForwardButtons = addNavigationTabs($tabSet, $tabSet.data("tabData").options);
            bindBackAndForwardHandler.call($tabSet, $tabs, $backAndForwardButtons.filter(".tabForward, .tabBack"));
        }
        $tabs.filter(".tab:first").css("border-left","1px solid white");
        $backAndForwardButtons.show();

    }
    function removeTab($currentTab) {
        var $this = $(this);
        var tabData = $this.data("tabData");
        var $nextTab = $currentTab.prev(".tab");
        if ($nextTab.length === 0) {
            $nextTab = $currentTab.next(".tab");
        }
        var $removedTab = $currentTab.clone();
        $currentTab.siblings("dd.tabContainer").eq($currentTab.attr("data-tabIndex")).remove().end().end().remove();
        $this.find(".tab").unbind("click.initAddress");
        var $tabs = $nextTab.siblings("dt.tab");
        if (tabData.useDeepLink) {
            initAddress.call($this, tabData.options, tabData.animation);
        }
        if ($currentTab.hasClass("active")) {
            //setting the new tab will 
            if ($nextTab.prev(".tab").length === 0) {
                $nextTab.addClass("active");
                $this.find('> dd.tabContainer:eq(0)').children(":eq(0)").addBack().show()
            } else{
                $nextTab.trigger("click");
            }
        }
        var $shownTab = $tabs.filter(".tab:visible").last().next(".tab").show();
        shiftTabs($tabs, $shownTab, $(this));
        setupTabIndexes($tabs.add($nextTab));
        updateTabWidths.call($this);

        $this.trigger("afterRemoveTab", [$removedTab]);
        return $nextTab;
    }
    function bindRemoveButtonHandler($tabs, $removeButton) {
        var $this = $(this);
        var options = $this.data("tabData").options;
        $this
            .delegate("dt.tab", "mouseover", function(){
                if ($(this).hasClass("staticTab") === false) {
                    $removeButton.show();
                    $($removeButton).dr.snapTo(this, {position:"r-r", inline:false, offset:{x:1,y:-18}});
                    $removeButton.data("currentTab",this);
                }
            })
            .delegate("dt.tab", "mouseleave", function(e){
                if (!$(e.relatedTarget).hasClass("removeTab")) {
                    $removeButton.hide();            
                }
        });
        $removeButton
            .bind("mouseleave", function(){
                $(this).hide();
            })
            .bind("click.removeTab", function(){
                if ($this.triggerHandler("beforeRemoveTab",[$($removeButton.data().currentTab)]) === false && $.dr.confirm()) {
                    return  false;
                }
                $.dr.confirm(options.messages.deleteTabWarning, function(ok){
                    if (ok) {
                        $removeButton.data("currentTab", removeTab.call($this, $($removeButton.hide().data().currentTab)));
                    }
                },{title:options.messages.deleteTabTitle});
            });
    }
    /* Returns whether the given title is a duplicate name of another tab */
    function isTitleDuplicate(title, $tabSet) {
        var $tabs = $tabSet.children(".tab");
        for (var i = 0; i < $tabs.length; i++) {
            if ($tabs.eq(i).text().trim() === title.trim()) {
                return true;
            }
        }
        return false;
    }
    /* Creates and binds the overflow tab menu elements and event handler */
    function bindOverflowFlyoutHandler($overflowButton, options) {
        var $this = $(this);
        var $overflowDiv = $(document.createElement("div")).append("<ul></ul>");
        $overflowDiv.delegate("li div", "click", function(){
            var index = $(this).parent().attr("data-tabIndex");
            $this.children("dt.tab").filter("[data-tabIndex='"+index+"']").trigger("click").show();
            hideOverflowTabs($this);
            $(".overflowButton", $this).dr.hover.hide();
        });
        $($overflowButton)
            .dr.hover({position:"t-b", preferredAltPositions: ["b-t"], customContent:$overflowDiv, useClickEvent:true, theme:"grey", showArrow:true, customClass:"overflowFlyout"})
            .bind("dr-beforeRender",function(e,target,popup){
                if ($(this).hasClass("disabled")) {
                    return false; 
                }
                var $list = $overflowDiv.find("ul").empty();
                var overflowArray = [];
                var $lastTab = null;
                $this.children("dt.tab").each(function(){
                    var $this = $(this);
                    //check if the current tab's prev is equal to lastTab, if its not, set the bordertop to be thick!
                    var topBorderClass = "";
                    if ($lastTab != null && $this.prev()[0] !== $lastTab[0]) {
                        topBorderClass = "doubleBorder";
                    }
                    if ($this.is(":hidden")) {
                        overflowArray.push("<li data-tabIndex='"+$this.attr('data-tabIndex')+"' class='overflowTabItem "+topBorderClass+"'><div>"+$this.text() + "</div></li>");
                        $lastTab = $this;
                    }
                });
                $list.append(overflowArray.join(""));
                return $overflowDiv;
        });
    }
    function bindBackAndForwardHandler($dts, $tabBackAndForward) {
        var $tabSet = $(this);
        $($tabBackAndForward)
        .bind("mousedown", function(){
            clearInterval($tabSet.data("tabData").timeout);
            var $this = $(this);
            $this.dr.hover.cancelTargetMouseIn();
            $tabSet.data("tabData").timeout = setInterval(function(){
                $this.trigger("click");
                $.data(this, "fastNavigate", true);
            },290);
        })
        .bind("mouseup mouseleave", function(){
            clearInterval($tabSet.data("tabData").timeout);
            if ($.data(this, "fastNavigate") === true) {
                $.data(this, "fastNavigate", false);
            }
        })
        .bind("click",function(){
            var $dts = $tabSet.children("dt.tab");
            if ($.data(this, "fastNavigate") === false) {
                $.data(this, "fastNavigate", null);
                return false;
            }
            var $visibleTabs = $dts.filter(":visible");
            if ($(this).hasClass("tabForward")) {
                var $shownTab = $visibleTabs.last().next();
            } else {
                var $shownTab = $visibleTabs.first().prev();
            }
            if ($shownTab.length > 0 && $shownTab[0].style.display == "none") {
                $shownTab.show();
                shiftTabs($dts, $shownTab, $(this));
            }
        });
    }
    /*
     * 
     */
    function bindCreateNewTabHandler($createNewTabButton) {
        var $this = $(this);
        $createNewTabButton.bind("click", function(){
            if ($this.triggerHandler("beforeCreateNewTab") !== false) {
                var options = $this.data("tabData").options;
                var _add = function(title, content) {
                    var $newTab = $($this).dr.tabs.addTab(title, content);
                    if (typeof $newTab !== "undefined") {
                        //passing the new tab DT and DD elements
                        $this.trigger("afterCreateNewTab", [$newTab, $this.find('> dd').eq($.inArray($newTab[0], $this.children("dt.tab").get())).find('> div.tabContent')]);
                    }
                }
                if (options.showNewTabOverlay === true) {
                    $.dr.prompt(options.messages.newTabMessage, options.messages.newTabDefaultValue, function(ok){
                        if (ok !== null) {
                            _add(ok, "");
                        }
                        
                    }, {title: options.messages.newTabTitle});
                } else {
                    _add(options.messages.newTabDefaultValue, "");
                }
            }
        });
    }
    
    var windowEventsBound = false;
    function bindWindowResizeEvent(){
        if(windowEventsBound){
            return;
        }
        //throws error unless using a setTimeout
        setTimeout(function(){
            winWidth = $(window).width();
            winHeight = $(window).height();
            $(window).bind("resize.tabUpdates", function(){
                $.dr.utils.waitForFinalEvent(function() {
                    var winNewWidth = $(window).width();
                    var winNewHeight = $(window).height();            
                    if ((winWidth!=winNewWidth || winHeight!=winNewHeight)) {
                        lastResizeTime = new Date().getTime();
                        winWidth = winNewWidth;
                        winHeight = winNewHeight;
                        $("dl.tabs:visible").each(function(){
                            $(this).dr.tabs.updateTabWidths();
                        });
                    }
                }, 50, "tabResizing");
            });
        },0);
        windowEventsBound = true;
    }
    
    $.namespace('dr', {
        tabs: function(tabOptions){
            if ($(this).hasClass("initialized")) {
                return false;
            }
            var timeout = null;
            var options = $.extend(true, {}, defaults, tabOptions);
            var effectType = options.displayEffect.animation.toLowerCase(), animation = {
                show: $.fn.show,
                hide: $.fn.hide,
                speed: options.displayEffect.speed
            };
            // turn off animation in IE, because they are slow
            if (isIE) {
                effectType = 'none';
            }
            switch (effectType) {
                case 'fade':
                    animation = $.extend(animation, {
                        show: $.fn.fadeIn,
                        hide: $.fn.fadeOut
                    });
                    break;
                case 'slide':
                    animation = $.extend(animation, {
                        show: $.fn.slideDown,
                        hide: $.fn.slideUp
                    });
                    break;
                case 'none':
                    animation.speed = 0;
                    animation = $.extend(animation, {
                        show: $.fn.show,
                        hide: $.fn.hide
                    });
                    break;
            }
            
            $(this).addClass("initialized");
            
            bindWindowResizeEvent();
            
            return this.dr.bindPluginEvents({
                    'beforechange': options.beforechange,
                    'beforeanimate': options.beforeanimate,
                    'afteranimate': options.afteranimate
                }).each(function(){
                    var $this = $(this), defaultTab = 0;
                    $this.data('activeTab', null);
                    $this.data('defaultTab', defaultTab);
                    var useDeepLink = (options.deepLink && !$this.parents('dl.tabs').length && !$('body').hasClass('modalPage'));
                    var $dts = $this.find('> dt');
                    var dtCount = $dts.find('script').remove().end().prependTo(this).each(function(count){
                        useDeepLink = setupTab.call($this, $(this), count, options, animation, useDeepLink);
                    }).length;
                    $dts.hover(hoverOver, hoverOut);
                    
                    var ddCount = $this.find('> dd').each(function(){
                        var $dd = $(this);
                        if (!$dd.hasClass('tabContainer')) {
                            $dd.addClass('tabContainer');
                        }
                        if (!$dd.find('> div.tabContent').length) {
                            $dd.wrapInner('<div class="tabContent">');
                        }
                    }).length;
                    var containerWidth = setContainerWidth.call($this);
                    // Create any missing DD tags (this should be rare)
                    var extraDD = '';
                    for (var i = ddCount; i < dtCount; i++) {
                        extraDD += '<dd class="tabContainer"><div class="tabContent"/></dd>';
                    }
                    if (extraDD.length) {
                        $this.append(extraDD);
                    }
                    
                    setupDeepLinking.call($this[0], useDeepLink, options, animation);
                    //pack options and deeplink to dl.tabs data
                    $this.data("tabData", {"options":options, "useDeepLink":useDeepLink, "animation":animation, "containerWidth":containerWidth, "timeout":timeout});
                    if (options.showDeleteTabButton) {
                        bindRemoveButtonHandler.call($this, $dts, createRemoveButton.call($this, $dts));
                    }
                    var tabsDidFit = true;
                    if (options.scrollingTabs === true && containerWidth > 0) {
                        var tabsDidFit = updateTabWidths.call($this);
                    }
                    $this.bind("updatedTabWidths", function(e, doesFit){
                        var $this = $(this);
                        if (doesFit) {
                            $this.children("dt.tab").each(function(){
                                $(this).removeAttr("title").css("text-overflow","clip");
                            });
                            if (hideNavigationTabs($this)) {
                                hideOverflowTabs($this);
                            }
                            //reenable the tab wrapping
                        } else if (doesFit === false && $this.children(".tabBack:visible, .tabForward:visible").length === 0 && $this.is(":visible")) {
                            showNavigationTabs($this);
                            enableDisableNavTabs($this.children("dt.tab"));
                            updateTabWidths.call($this);
                            $this.children("dt.tab").each(function(){
                                $(this).attr("title",$(this).text().trim());
                            });
                        }
                    });
                    //Order of navTabs: BACK | FORWARD | NEWTAB | OVERFLOW
                    if (tabsDidFit === false) {
                        var $backAndForwardButtons = $this.find(".tabBack, .tabForward");
                        bindBackAndForwardHandler.call($this, $dts, $backAndForwardButtons);
                    }
                    if (options.showNewTabButton) {
                        var $createNewTabButton = addCreateNewTab($this);
                        bindCreateNewTabHandler.call($this,$createNewTabButton);
                    }
                    if (tabsDidFit === false || (tabsDidFit === true && options.showNewTabButton && containerWidth > 0)) {
                        updateTabWidths.call($this);
                    }
                    $this.find(".navTab")
                        .bind("mousedown",function(){
                            if ($(this).hasClass("disabled") === false) {
                                setBackgroundPosition.call($(this),"0px", HOVERED_BG_POSITION+"px");
                            }
                        })
                        .bind("mouseup mouseleave",function(){
                            setBackgroundPosition.call($(this),"0px", DEFUALT_BG_POSITION+"px");
                    });
                    setupTabIndexes($dts);
                    $this.trigger("aftersetupcomplete");
                });
        }
    });

    /*Create 'beforechange' and 'afterchange' plugin events*/
    $.dr.utils.createPluginEvents('dr.tabs', ['beforechange', 'beforeanimate', 'afteranimate']);

    /*Tab can be an index or the title name, or the actual tab*/
    var getIndividualTab = function(tab) {
        if (isNaN(tab)) {
            return this.children().filter(function(){
                if ($(this).text().trim() == tab.trim()) {
                    return this;
                }  
            });
        }
        if (typeof($dt) === "undefined") {
            return this.children("dt.tab").eq(tab);
        }
        if (jQuery.contains(document.documentElement, $(tab)[0]) === true) {
            return $(tab);
        }
        return null;
    };
    $.namespace('dr.tabs', {
        addTab: function (tabTitle, tabContent, doShowNewTabImmediatelyOverride) {
            var $tabSet = $(this);
            var useDeepLink = $tabSet.data("tabData").useDeepLink;
            if (useDeepLink && isTitleDuplicate(tabTitle, $tabSet)) {
                $.dr.alert(options.messages.duplicateTabMessage.replaceTokens(tabTitle), {title: options.messages.duplicateTabTitle});
                return false;
            }
            var $allTabs = $tabSet.children("dt.tab");
            var tabHTML = NEW_TAB_TMPL.replaceTokens(tabTitle);
            tabContent = $.isFunction(tabContent) ? tabContent() || "" : tabContent;
            var tabContainerHTML = NEW_TAB_CONTAINER_TMPL.replaceTokens(tabContent);
            //Add the tab DT and DD
            if ($tabSet.children("dt.tab").length === 0) {
                var $newestTab = $tabSet.prepend(tabHTML).children(":first-child");
                $tabSet.append(tabContainerHTML);
            } else {
                var $newestTab = $allTabs.last().after(tabHTML).last().next();
                $tabSet.find("dd.tabContainer:last").after(tabContainerHTML);
            }
            $allTabs = $allTabs.add($newestTab.hover(hoverOver,hoverOut))
            var options = $tabSet.data("tabData").options;
            var animation = $tabSet.data("tabData").animation;
            setupTab.call($tabSet, $newestTab, $allTabs.length, options, animation, useDeepLink);
            //update tab indexes
            setupTabIndexes($allTabs);
            //reinit address plugin
            setupDeepLinking.call($tabSet, useDeepLink, options, animation, true);
            setContainerWidth.call(this);
            if (doShowNewTabImmediatelyOverride === true || (typeof(doShowNewTabImmediatelyOverride) === "undefined" && options.openNewTabsInBackground !== true)) {
                $newestTab.trigger("click").show();
            }
            if (options.scrollingTabs === true) {
                updateTabWidths.call($tabSet);
            }
            return $newestTab;
        },
        setTitleText: function(tab, text) {
            var $this = $(this);
            var $tab = getIndividualTab.call(this, tab);
            if ($tab != null) {
                var $textElement = $tab.children("a").length > 0 ? $tab.children("a") : $tab;
                $textElement.text(text);
                if ($textElement.attr("title").length > 0) {
                    $textElement.attr("title", text.trim());
                }
                //update the tab tab widths
                if ($this.data("tabData").options.scrollingTabs === true) {
                    updateTabWidths.call($(this));
                }
            }
            return this;
        },
        /* tab parameter can be either index or tab title */
        removeTab: function(tab) {
            var $tab = getIndividualTab.call(this, tab);
            if ($tab != null) {
                setContainerWidth.call(this);
                removeTab.call(this, $tab);
            }
            return this;
        },
        updateTabWidths: function() {
            var $this = $(this);
            if ($this.length === 0 || $this.is(":hidden") || $this.data("tabData").options.scrollingTabs !== true) {
                return this;
            }
            setContainerWidth.call(this);
            updateTabWidths.call(this);
            return this;
        },
        setOptions: function(key, value) {
            if (typeof(key) != "undefined" && typeof(value) != "undefined" && typeof($(this).data("tabData")) != "undefined") {
                if (key === "messages") {
                    var existingOpts = $(this).data("tabData").options;
                    $(this).data("tabData").options[key] = $.extend(true, {}, existingOpts.messages, value || {});
                } else {
                    $(this).data("tabData").options[key] = value;
                }
            }
        }
    });        
    /*
     * Tabs Public API for static methods
     */
    $.dr.tabs = {
        /*
         * Gets defaults, localized strings
         */
        getDefaults: function(){
            return defaults;
        },
        /*
         * Sets defaults
         * Example of options being passed:
         * $.dr.tabs.setDefaults( {displayEffect: {
         animation: 'fade',
         speed: 'normal'
         }} );
         */
        setDefaults: function(options){
            if (options) {
                $.extend(true, defaults, options);
            }
            //inform any listeners to the event
            $(document).trigger('afterTabSetDefaults', [options]);
        }
    }
    
    $.dr.addUnobtrusiveEvent(function(evt, context){
        var tabs = $('dl.tabs', context);
        tabs.each(function() {
            if (!$(this).hasClass("initialized")) {
                var opts = $(this).attr("data-options");
                if (opts) {
                    opts = $.dr.utils.evalString(opts);
                } else {
                    opts = {};
                }
                if ($(this).hasClass("ajaxLoad")) {
                    opts["ajaxLoad"] = true;
                }
                if (opts && opts.ajaxLoad === true) {
                    if (context === document && tabs.length > 1) {
                        return true;
                    }
                }               
                $(this).dr.tabs(opts);              
            }
        });

       
    }, 'unobtrusiveEventEarly');
    
})(jQuery);
(function($){

	var defaults = {
		activeTab: 0,
		bottomPad: 20,
		autoClick: true
	};
	
	var appendParam = function(url, param){
		var delim = (/\?/.test(url)) ? '&' : '?'
		return url + param.replace(/^\?|&?/, delim);
	};

	// Determine the DL wrapper structure, based on the browser (IE6 has to use a table)
	var ie6 = $.browser.msie && ($.browser.version <= 6);
	var mainWrapper = '<div class="tabFingers"><div class="fingerRightWrapper"></div></div>';
	var parentSelector = 'div.tabFingers:first';
	var dtActivator = '> dl > dt';
	var ddActivator = '> dl > dd';
	if (ie6) {
		mainWrapper = '<table class="tabFingers"><tbody><tr><td class="fingerRight"></td></tr></tbody></table>';
		parentSelector = 'table.tabFingers:first > tbody > tr';
		dtActivator = '> td.fingerLeft ' + dtActivator;
		ddActivator = '> td.fingerRight ' + ddActivator;
	} else {
		ddActivator = '> div ' + ddActivator;
	}

	$.namespace('dr.fingertabs', function(tabOptions){
		var options = $.extend(defaults, tabOptions);

		return this.dr.bindPluginEvents({
				'beforechange': options.beforechange,
				'afterchange': options.afterchange
			}).each(function(){
			if ($(this).hasClass("initialized")) {
				return false;
			}
			// Keep track of the current tab
			var currentTab = undefined;
				
			// Remove the DTs from the DOM, then wrap the DTs in a new DL
			var $dlOfDT = $('> dt', this).remove().addClass('fingerLeft').each(function(count){
				// If the 'active' class was manually added, it will override options.activeTab
				if ($(this).hasClass('active')) {
					options.activeTab = count;
					$(this).removeClass('active');
				}
			}).wrapAll('<dl class="fingertabs fingerLeft"></dl>').parent();

			// Hide the non-active DDs, then wrap the DL in a new HTML structure
			var $ancestor = $(this).find('> dd').not(':eq('+options.activeTab+')').hide().end().find('script').remove().end().addClass('fingerRight').end().addClass('fingerRight').wrap(mainWrapper).parent().parent();

			// Insert the offline DL-of-DTs back into the new wrapper structure
			if (ie6) {
				$ancestor.prepend('<td class="fingerLeft"></td>').find('> td.fingerLeft').append($dlOfDT);
			} else {
				// Set a min-height on the DDs to make sure the bottom border stays down around the entire DL structure
				var dtHeight = $ancestor.append($dlOfDT).find('> dl').height() + options.bottomPad;
				$ancestor.find(ddActivator).css('min-height', dtHeight+'px');
			}

			// Finally hook up the click event
			var $dtList = $ancestor.find(dtActivator).each(function(count){
				// Look for a link to use for an AJAX source
				var ajaxInfo = {};
				var dtLink = $('a[href]', this).get(0);
				if (dtLink && (dtLink.target !== '_self') && ((dtLink.protocol === location.protocol) && (dtLink.hostname === location.hostname))) {
					ajaxInfo.url = dtLink.href;
					ajaxInfo.ajaxParam = $(dtLink).attr('data-ajax-param');
				}
				
				// Assign the click to display the tab
				$(this).click(function(e, skipEvent, callback){
					if (count !== currentTab) {
						// Go up the DOM to find the wrapper that will get to the related DT/DD
						var $thisTab = $(this);
						var $grandParent = $thisTab.parents(parentSelector);
						var $tabFingers = $grandParent.find(dtActivator);
						var $tabPanels = $grandParent.find(ddActivator);
						var $leftAndRightDL = $tabPanels.eq(currentTab).parent().add($thisTab.parent());
						// Fire off the 'beforechange' event on the current tab to give someone the ability to keep the tab from switching
						if (skipEvent || ($leftAndRightDL.add($tabFingers[currentTab]).drTriggerEach('beforechange', [$tabPanels[currentTab], currentTab, count, $tabFingers[currentTab], $thisTab[0]]) !== false)) {
							// Show the tab
							$tabFingers.eq(currentTab).removeClass('active').end().eq(count).addClass('active');
							$tabPanels.eq(currentTab).hide().end().eq(count).show();
							currentTab = count;

							// Run these after the tab is shown, making sure to wait until after AJAX has loaded
							var afterTabDisplay = function(clickedTabFinger, clickedTabIndex){
								// Run a custom callback for the newly-shown tab
								if ($.isFunction(callback)) {
									callback.call(this);
								}
								// Fire off the 'afterchange' event on the tab that was just displayed
								$leftAndRightDL.add(clickedTabFinger).drTriggerEach('afterchange', [this, clickedTabIndex, clickedTabIndex, clickedTabFinger]);
							};

							if (dtLink) {
								// If this event bubbled up from the link, keep it from going anywhere
								if ($(e.target).is('a[href]')) {
									e.preventDefault();
								}
								// Pull the content via AJAX
								if (ajaxInfo.url) {
									var panelData = $tabPanels.eq(count).data('ajaxpanel');
									if (!panelData) {
										$tabPanels.eq(count).dr.ajaxpanel({
											url:ajaxInfo.url,
											params: ajaxInfo.ajaxParam,
											title:$thisTab.text(),
											showSuccessMessage:false,
											afterrender:function(){
												afterTabDisplay.call($tabPanels[count], $thisTab[0], count);
											}
										});
									} else if (panelData.loaded) {
										afterTabDisplay.call($tabPanels[count], $thisTab[0], count);
									}
								} else if ($(e.target).is('dt')) {
									location = dtLink.href;
								}
							} else {
								afterTabDisplay.call($tabPanels[count], $thisTab[0], count);
							}
						} else {
							// If the beforechange event returns false, keep the link from going anywhere
							return false;
						}
					} else {
						// If the link on the current tab is clicked, keep it from going anywhere!
						return false;
					}
				});
				
				// IE6 doesn't respond to the :hover pseudo-class, so a hover event has to be added
				if (ie6) {
					$(this).hover(function(){
						$(this).toggleClass('fingerLeftHover');
					});
				}

			});
			
			// Set the active tab in the general data of the dl
			$(this).data('fingertabs-activeTab', options.activeTab);
			
			// Show the activeTab right away, by default
			if (options.autoClick) {
				$dtList.eq(options.activeTab).triggerHandler('click');
			}

		});
		$(this).addClass("initialized");
	});
	
	// Create 'beforechange' and 'afterchange' plugin events
	$.dr.utils.createPluginEvents('dr.fingertabs', ['beforechange','afterchange']);
	
	// Create a plugin to show any tab
	$.namespace('dr.fingertabs.show', function(tabIndex, callback){
		return this.each(function(){
			var element = this;
			// If a DL was selected and a tabIndex was passed, find the correct DT
			if ($(this).is('dl.fingertabs') && (tabIndex >= 0)) {
				// Have to go up to the parents to find the DT, since this DL may be the original one that now only contains DDs
				element = $(this).parents(parentSelector).find(dtActivator).get(tabIndex);
			} else {
				callback = tabIndex;
			}
			// Now make sure the element is really a DT
			if ($(element).is('dt.fingerLeft')) {
				$(element).triggerHandler('click', [true, callback]);
			}
		});
	});
	
	// Set up the fingertags structure, without triggering the first tab click
	$.dr.addUnobtrusiveEvent(function(evt, context){
		$('dl.fingertabs', context).dr.fingertabs({
			autoClick: false
		});
	}, 'unobtrusiveEventEarly');
	
	// Hook up the initial tab click later
	$.dr.addUnobtrusiveEvent(function(evt, context){
		$('dl.fingertabs', context).each(function(){
			var activeTab = $(this).data('fingertabs-activeTab');
			$(this).dr.fingertabs.show(activeTab);
		});
	}, 'unobtrusiveEventLate');

})(jQuery);
;(function($) {
	var objectDetect = $.support.style,
		hOffset = ($.browser.msie) ? -5 : -5,
		spanOffset = ($.browser.msie) ? 0 : 3,
		wOffset = ($.browser.msie) ? 2 : ($.browser.safari) ? -1 : 1;

	$.namespace('dr', {
		taskbar: function(){
	     	return this.not('.inited').addClass('.inited').each(function(){
	     		
		        var $tasks = $("button", this);
				var tallestTaskHeight = 0;
		        $tasks.each(function(){
					var span = $("span.icon span", this)
		            var textWidth = span.width();
					var btnWidth = (textWidth < 50) ? 70 : (textWidth >= 300) ? 300 : textWidth + 17 ;
				  
					$(this).css('max-width','none').width(btnWidth);
					span.width(btnWidth-17);
					
					if($.browser.msie) {
						$("span.icon", this).width(btnWidth - 17 + wOffset);
					}
					var h = $(this).height();
					 if (h > tallestTaskHeight) {
		                tallestTaskHeight = h ;
		            }
					if($.browser.msie6){
						$(this).hover( function(){
							if(!$(this).hasClass('selected')){
								$(this).addClass('hover')
							}
						},
						function(){$(this).removeClass('hover')});	
					}
		        });	
				tallestTaskHeight = Math.min(Math.max(tallestTaskHeight,67),117);
				
				$tasks.each(function(){
		           $(this).height(tallestTaskHeight-hOffset);
		           $("span.icon",this).height(tallestTaskHeight-hOffset-spanOffset);
		        });
				
				$("ul, div.related", this).css('visibility','visible');
			});
		}
	});
	
	
	var initTaskBar = function(){ 
		$("div.taskbar", document).dr.taskbar();
	};
	
	$.dr.addDomReadyEvent(initTaskBar,'domReadyEarly');
	
})(jQuery);
;
(function($){
    var TS_RETRIES = 10;
	var TS_ANIMATE_RETRIES = 20;
	var TS_TOGGLEWIDTH = 72;
	var TS_MIDDLEWIDTH = 47;
	var TS_IE6WIDTH = 55;
	var TS_PADDINGWIDTH = 14;
	var TS_DISABLEDCLASS = 'toggleswitchDisabled';
	
	var defaults = {
        leftColor: '#ec8a0b',
        rightColor: '#548dca'
    };
    $.dr.toggleswitch = {
        setDefaults: function(userOptions){
            if (userOptions) {
                $.extend({}, defaults, userOptions);
            }
            //inform any listeners to the events
            $(document).trigger('dr-toggleswitch-setDefaults', [defaults]);
        },
		getDefaults: function(){
			return defaults;
		}
    };
	
	/**
	 * Determines which radio button is checked
	 */
	var getCheckedIndex = function(){
        var radios = $('input[type="radio"]', this);
		var index = radios.index(radios.filter(function(){
			return this.checked === true;
		}).get(0));
		var temp;
		switch(index){
			case 0:
				temp = true;
				break;
			case 1:
				temp = false;
				break;
			default:
				temp = -1;
				break;
		}
		return temp;
    };
	
	/**
	 * Animates the toggleswitch
	 * @param {String} direction Requires either += (to slide right) or -= (to slide left) 
	 */
	function animateToggle(direction){
		var labelWidth = $('.leftLabel', this).dr.utils.getHiddenDimensions().width;
		state = getCheckedIndex.call(this);
		if (state) {
			var checkedRadio = 1;
		}
		else {
			var checkedRadio = 0;
		}
		if ((direction === '+=' && !state) || (direction === '-=' && state)) {
			$('input[type="radio"]', this).eq(checkedRadio)[0].checked = true;
			$('input[type="radio"]', this).eq(1 - checkedRadio)[0].checked = false;
			$('.toggle', this).animate({
				left: direction + (labelWidth + TS_PADDINGWIDTH)
			}, function(){
				//inform any listeners to the event
				$(this).trigger('dr-toggleswitch-change', [!state, this]);
				$(this).trigger('toggleswitchChange', [state, this]); //deprecated event name
			});
		}
	}
	
	/**
	 * Starts the action to animate the toggleswitch from one side to the other
	 * @param {Boolean} state Receives true to slide right and false to slide left. If no value is sent for state it will slide automatically.
	 */
	function toggleswitches(state){
        if (typeof state === "undefined") {
			// undefined == toggle the current settings.
			state = getCheckedIndex.call(this);
			if (state === -1) {
				state = true; // this should never happen
			}
			state = !state;
		}
        if (state) {
            animateToggle.call(this,'+='); //SLIDE RIGHT
        } else {
            animateToggle.call(this,'-='); //SLIDE LEFT
        }
    }
	
	/**
	 * Adds the necessary CSS to the toggleswitch elements.
	 * @param {Number} leftLabelWidth The width of the left label.
	 * @param {Number} rightLabelWidth The width of the right label. 
	 * @param {String} largeSide Which label is longer. Values can be left or right.
	 */
	function setupWidths(leftLabelWidth, rightLabelWidth,largeSide){
		if(largeSide === 'left'){
			var smallLabel = $('.rightLabel', this);
			var labelWidth = leftLabelWidth;
		}else{
			var smallLabel = $('.leftLabel', this);
			var labelWidth = rightLabelWidth;
		}
		$('.toggle', this).css('width', (2 * labelWidth + TS_TOGGLEWIDTH)).css('left','0'); // left:0 must be added in case user copies and pastes toggleswitch from source or firebug
		smallLabel.css('width', labelWidth);
		$('.backMiddle', this).css('width', (labelWidth + TS_MIDDLEWIDTH));
		$(this).css('width', (labelWidth + TS_IE6WIDTH)); // FOR IE6
		var state = getCheckedIndex.call(this);
		if (!state) {
			$('.toggle', this).css('left', -(labelWidth + TS_PADDINGWIDTH));
		}
	}
	
	var toggleswitchWidthErrors = 0;
	
	/**
	 * Gets the widths of the labels and sets necessary variables for setupWidths function. 
	 * If widths can't be found (e.g. when an iframe modal hasn't finished loading yet) the function will start over every 50 milliseconds
	 * up to the number of times specified in the TS_RETRIES variable above.
	 */
	function setWidths(){
		if (toggleswitchWidthErrors <= TS_RETRIES) {
			var leftLabelWidth = $('.leftLabel', this).dr.utils.getHiddenDimensions().width;
			var rightLabelWidth = $('.rightLabel', this).dr.utils.getHiddenDimensions().width;
			if (leftLabelWidth !== 0 && rightLabelWidth !== 0) {
				if (leftLabelWidth > rightLabelWidth) {
					var largeSide = 'left';
				}else{
					var largeSide = 'right';
				}
				toggleswitchWidthErrors = 0;
				setupWidths.call(this,leftLabelWidth,rightLabelWidth,largeSide);
			}else{
				toggleswitchWidthErrors += 1;
				var oThis = this;
				setTimeout(function(){
					setWidths.call(oThis);
				}, 50);
			}
		}
	}

    $.namespace('dr.toggleswitch', function(userOptions){
		var options = $.extend({}, defaults, userOptions);
        return this.each(function(){
			var radios = $('input', this).filter(':radio').hide();
			// make sure there are only two radios
			if (radios.length === 2) {
				// make sure one radio is checked by default
				var state = getCheckedIndex.call(this);
				if (state === -1) {
					state = true;
				}
				// ADD NECESSARY CODE FOR MINIMIZED VERSION
				if (!$(this).data('toggleswitch')) {
					if ($('div', this).length < 8) { //TOGGLESWITCH SHOULD CONTAIN EIGHT DIVS. THIS MAKES SURE IT IS SET UP CORRECTLY.
						var label = $('label', this);
						$('label, input', this).addClass('toggleElement');
						$('.toggleElement', this).wrapAll('<div class="toggle backElement" />');
						label.eq(0).after('<div class="front toggleElement" />').wrap('<div class="leftLabel toggleElement" />');
						label.eq(1).wrap('<div class="rightLabel toggleElement" />');
						$('.toggle', this).before('<div class="backLeft backElement"></div><div class="backMiddle backElement"></div><div class="backRight backElement"></div>');
						$('.backElement', this).wrapAll('<div class="back" />');
						//TO SUPPORT IE
						$('.front, label', this).attr("unselectable", 'on');
						if (!$(this).hasClass('toggleswitch')) {
							$(this).addClass('toggleswitch');
						}
					}
					$(this).data('toggleswitch', 'true');
				}
				toggleswitchWidthErrors = 0;
				setWidths.call(this);
				
				// SET LEFT AND RIGHT COLOR
				var dataOptions = $(this).attr('data-options');
				if (dataOptions) {
					cOptions = $.dr.utils.evalString(dataOptions);
					options = $.extend(true, {}, defaults, cOptions);
					$('label', this).eq(0).css('color', options.leftColor);
					$('label', this).eq(1).css('color', options.rightColor);
				}
				
				if (!$(this).data('inited')) {
					$(this).data('inited', 'true');
					$(this).click(function(evt){
						evt.preventDefault();
						if (!$(this).hasClass(TS_DISABLEDCLASS)) {
							if($(evt.target).is('input')){
								var newIndex = $('input',this).index(evt.target);
								newIndex = (newIndex === 0) ? true : false;
								$(this).dr.toggleswitch.toggle(newIndex);
							}else{
								var currentIndex = getCheckedIndex.call(this);
								if($(this).attr('onclick')){
									currentIndex = (currentIndex === true) ? false : true;
									$(this).dr.toggleswitch.toggle(currentIndex);
								}else{
									currentIndex = (currentIndex === true) ? 1 : 0;
									$('input',this).eq(currentIndex).click();	
								}
							}
						}
					});
				}
			}
        });
    });
    $.namespace('dr.toggleswitch', {
        toggle: function(index){
        	this.each(function(){
				if ($(this).triggerHandler("dr-toggleswitch-beforeChange", [getCheckedIndex.call(this), this]) !== false) {
					toggleswitches.call(this, index);
				}
			});
        },
		getValue: function() {
			var values = [];
			this.each(function(){ 
				values.push(getCheckedIndex.call(this));
			});
			return values.length === 1 ? values[0] : values;
		},
		readOnly: function(trueFalse){
			if (typeof trueFalse === "undefined") {
				if (this.length > 1) {
					var states = [];
					this.filter(function(index){
						return $(this).hasClass(TS_DISABLEDCLASS);
					}).each(function(){
						states.push($('input', this).attr('name'));
					})
					return states.length === 0 ? false : states;
				}else{
					if($(this).hasClass(TS_DISABLEDCLASS)){
						var state = true;
					}else{
						var state = false;
					}
					return state;
				}
			}else{
				this.each(function(){
					if (trueFalse === false) {
						$(this).removeClass(TS_DISABLEDCLASS);
					}
					else {
						if (!$(this).hasClass(TS_DISABLEDCLASS)) {
							$(this).addClass(TS_DISABLEDCLASS);
						}
					}
				});
			}
		},
        /**
         * @author Christopher Pryce<cpryce@digitalriver.com>
         * Usage: 
         *    $('.toggleswitch').dr.toggleswitch.reset();
         *    Resets the toggle to its original position. Triggers a change event if the 
         *    reset changed the current value of the switch.
         */
        reset: function() {
            var oSelf = this;
            var radios = $('input', oSelf).filter(':radio');
            
            if (radios.length) {
                // compare the default state to the current value.
                var defaultState = radios.get(0).defaultChecked;
                var v = $(oSelf).dr.toggleswitch.getValue();
                
                // avoid calling animate if we don't need to. Only triggers change event if 
                // the value changes.
                if (defaultState !== v) {
                    $(oSelf).dr.toggleswitch.toggle(defaultState);
                }
            }
        }
    });
	
	var inittoggleswitch = function(evt, context){
		$('div.toggleswitch', context).dr.toggleswitch();
    };
	
    $.dr.addUnobtrusiveEvent(inittoggleswitch, 'unobtrusiveEventEarly');
	
	
})(jQuery);

;(function($){	
	/*
	 * Private variables
	 */
	
	// The name of the file will be loaded on demand when a wysiwyg is needed.
	var SCRIPT_NAME = 'fckeditor.js',
	
	// To make sure we don't load the script more than once, we track if its still loading
	SCRIPT_LOADING = false,
	
	// Interval in milliseconds that the hidden textarea is synchronized
	REFRESH_INTERVAL=100000000,
	
	//List of references to editor objects
	EDITORS=[],
	
	// Array of custom toolbar sets
	CUSTOM_TOOLBAR_SETS = [],
	
	// Default settings for the editor
	DEFAULT_CONFIG = {
		BasePath: 	$.dr.FRAMEWORK_PATH + 'external/fckeditor/',
		Width: '700',
		Height: '300',
		ToolbarSet: 'default'
	};
	
	/*
	 * Private functions
	 */
	
	
	/*
	 * Tests to see if the FCKeditor object has been loaded.
	 * We do this by checking for the last object in the fckeditor.js file
	 */
	var checkReady = function(){
		return ( typeof FCKeditor_IsCompatibleBrowser == 'function'   ) ? true : false;
	}
	
	/*
	 * Tests to see if the FCKeditorAPI is ready
	 */
	var checkAPIReady = function(){
		// test to see if the FCKeditor API is ready
		return (typeof FCKeditorAPI == 'undefined'  ) ? false : true;
	}
	
	/*
	 * FCKeditor specific call that allows manipulation of the editor
	 * through javascript code.
	 */
	var getInstance = function(id){
		return FCKeditorAPI.GetInstance(id);
	}
	
	/*
	 * Replaces legacy tags with modern equivalents
	 */
	var cleanHTML = function(html){
		var h = html.replace(/\<b\>/g,'<strong>');
		h = h.replace(/\<\/b>/g,'</strong>');
		h = h.replace(/\<i>/g,'<em>');
		h = h.replace(/\<\/i>/g,'</em>');
		return h;
	}
	
	/******************************************************************************
	* Creates a Rich Text Editor (wysiwyg) and binds it to a textarea.
	* @param {HTMLTextArea} textareaObj Reference to the textarea to be converted
	* @param {String} id The id or name of the textarea
 	* @param {Object} config Optional argument to override default settings
	* @return wysiwyg
	* @private
	*****************************************************************************/
	var wysiwyg = function(textareaObj,id,config){
		this.textareaObj = textareaObj;
		this.id = id;
		this.editorObj = null;
		var c = $.extend(true, {}, DEFAULT_CONFIG);
		this.config = (config) ? $.extend(true, c, config) : c;
		this.refreshTimer=null;
		this.init();
	};
	
	wysiwyg.prototype = {
		/******************************************************************************
		* Loads the FCKeditor script if it has not already been attached to the page.
		* If the script is loaded and available in the runtime, we bind an editor to
		* the textarea.
		* @return VOID
		* @private
		*****************************************************************************/
		init: function(){
			if(checkReady()){
				// The FCKeditor scripts have been loaded, so create a new instance of an editor
				this.bindEditor();
			}else{
				if(!SCRIPT_LOADING){
					this.loadScript();
				}else{
					this.checkScriptReady();
				}
			}
		},

		/******************************************************************************
		* Loads the FCKeditor script on demand, so the user doesn't always have to
		* download the 250K+ file that contains all the main editor functionality.
		* @return VOID
		* @private
		*****************************************************************************/
		loadScript: function(){
			var oSelf = this;
			// Use jquery to load the script and execute it
			SCRIPT_LOADING=true;
			$.getScript(
				this.config.BasePath + SCRIPT_NAME,
				function(){ SCRIPT_LOADING=false;oSelf.checkScriptReady();}
			);
		},
		
		/******************************************************************************
		* Tests to see if the FCKeditor object is initialized and ready
		* the textarea.
		* @return VOID
		* @private
		*****************************************************************************/
		checkScriptReady: function(){
			var oSelf = this;
			var func = function(){
				if(checkReady()){
					oSelf.bindEditor();
				}else{
					oSelf.checkScriptReady();
				}
			}
			window.setTimeout(func,100);
		},
		
		/******************************************************************************
		* Creates a new instance of a FCKeditor and binds it to the textarea.
		* @return VOID
		* @private
		*****************************************************************************/
		bindEditor: function(){
			// Create a new editor
			var editor = new FCKeditor(this.id);
			
			// Override the default settings found in fckconfig.js
			$.extend(true, editor, this.config);
			
			// Hide the original textarea and show the FCK editor
			editor.ReplaceTextarea();
			
			// Create a reference to the editor object
			this.editorObj = editor;
			
			// The FCK javascript API loads after the first editor is instantiated, so we need
			// to test that it is ready before we bind the textarea synchronize event 
			this.checkAPIReady();
		},
		
		/******************************************************************************
		* Test to see if the FCKeditor javascript API is ready.
		* @return VOID
		* @private
		*****************************************************************************/
		checkAPIReady: function(){
			var oSelf = this;
			var func = function(){
				if(checkAPIReady()){
					var editorInstance = getInstance(oSelf.id);
					if(typeof editorInstance == 'undefined'){
						oSelf.checkAPIReady();
					}
					else if(typeof editorInstance.EditorDocument == 'undefined'){
						oSelf.checkAPIReady();
					}else{
						oSelf.synchronize();
					}
				}else{
					oSelf.checkAPIReady();
				}
			}
			window.setTimeout(func,10);
		},
		
		/******************************************************************************
		* When the editor has loaded and is ready, we update the textarea's value
		* from the editor on an interval set in the REFRESH_INTERVAL variable.
		* @return VOID
		* @private
		*****************************************************************************/
		synchronize: function(){
			
			var oSelf=this;
			var refreshFunc = function(){
				oSelf.updateTextarea();
				oSelf.synchronize(); 
			}
			this.refreshTimer = window.setTimeout(refreshFunc, REFRESH_INTERVAL);
		},
		
		/******************************************************************************
		* Updates the value of the textarea from the current value of the editor.
		* @return VOID
		* @private
		*****************************************************************************/
		updateTextarea: function(a){
			this.textareaObj.value = this.getHTML();
		},

		/******************************************************************************
		* Overwrites the html in the editor with a new string.
		* @param {String} html HTML string that will be set into the editor.
		* @return VOID
		* @public
		*****************************************************************************/
		setHTML:function(html){
			
			var editor = getInstance(this.id);
			
			if (!editor) {
				//FCKEditor instance could not be found
				return undefined;
			}else{
				html = cleanHTML(html);
				editor.SetHTML(html);
			}
		},
		
		/******************************************************************************
		* Retrieves the current html value in the editor.
		* @return String
		* @public
		*****************************************************************************/

		getHTML:function(){
			var editor = getInstance(this.id);
			if(typeof editor != 'undefined'){
				return editor.GetXHTML(true);
			}
			return undefined;
		}
	};


	/*
	 * Public jQuery plugins
	 */
	
	
	/*
	 * jQuery plugin that sets up a wysiwyg for textareas 
	 */
	$.namespace('dr',{
		wysiwyg: function(config){
			this.each(function(){
				if(this.tagName.toLowerCase()=='textarea'){
					if(!this.wysiwyg){
						var id = this.id || this.name;
						if(EDITORS[id]){
							clearTimeout(EDITORS[id].refreshTimer)
							EDITORS[id]=null;
						}
						this.value = cleanHTML(this.value)
						var editor = new wysiwyg(this,id, config);
						EDITORS[id] = editor;
						this.wysiwyg = editor;
	
					}
				}
		  	});
			return this;
		}
	});
	
	$.namespace('dr.wysiwyg',{
	
		/*
		 * jQuery plugin that sets HTML into textareas with an wysiwyg setup
		 */
		setHTML: function(html){
			this.each(function(){
				if(this.wysiwyg){
					this.wysiwyg.setHTML(html);
				}
		  	});
			return this;	
		},
		
		/*
		 * jQuery plugin that sets HTML into textareas with an wysiwyg setup
		 */
		getHTML: function(html){
			if ( this.length ) {
				var elem = this[0];
				var h = "";
				if(elem.wysiwyg){
					h = elem.wysiwyg.getHTML();
				} 
				return h;
			}
			return undefined;
		}
	});
	

	$.dr.wysiwyg = {
		/*
		 * jQuery utility that overrides the default configuration options
		 * Example of config being passed:
		 * $.dr.wysiwyg.setDefaultConfig( {BasePath:'/yourapp/ui_framework/editor/'} );
		 */
		setDefaultConfig: function(config){
			if(typeof config == 'object'){
				$.extend(true, DEFAULT_CONFIG, config);
			}
		},
		
		addToolbarSet: function(toolbarset){
			if(typeof toolbarset == 'object'){
				if(toolbarset.name && toolbarset.settings){
					CUSTOM_TOOLBAR_SETS.push(toolbarset);
				}
			}
		},
		
		getCustomToolbarSets: function(){
			return 	CUSTOM_TOOLBAR_SETS;
		}
	};
	
	var initWYSIWYGs = function($fields){
		$fields.filter('textarea.basic_wysiwyg, textarea.wysiwyg').each(function(){
			var $obj = $(this);
			if($obj.hasClass('basic_wysiwyg')){
				// hookup a "basic" editor
				$obj.dr.wysiwyg({ToolbarSet: 'basic'});	
			}else{
				
				var dataOptions = $obj.attr('data-options');
				var options;
				if (dataOptions) {
 					options = $.dr.utils.evalString(dataOptions, 'Error parsing data-options for wysiwyg ('+this.id+')');
				}
				
				// hookup as rich text editor using default toolbar, which is the full editor
				$obj.dr.wysiwyg(options);
			} 
		});
	};
	
	$.dr.addPlugin('form',initWYSIWYGs);
	
})(jQuery);
;(function($){
	//wrapping values in self executing fns so values only get calculated once
	var originalMsie = $.browser.msie;
	$.extend($.browser,{
		unsupported: (function() {
			return ($.browser.msie === true && parseInt($.browser.version.slice(0,1),10) <= 6);
		})(),
		msie6: (function() {
			return msieVersionChecker(6);
		})(),
		msie7: (function() {
			return msieVersionChecker(7);
		})(),
		msie8: (function() {
			return msieVersionChecker(8);
		})(),
		msie9: (function() {
			return msieVersionChecker(9);
		})(),
		msie: (function(){
			if (typeof originalMsie === "undefined" && navigator.userAgent.search("Trident") > -1) {
				return true;
			}
			return originalMsie;
		})(),		
		msieVersion: function(v) {
			return msieVersionChecker(v);
		},
		checkStandardsMode: document.compatMode == "CSS1Compat"
	});
	function msieVersionChecker(v) {
		return ($.browser.msie === true && parseInt($.browser.version.slice(0,1),10) == v);
	}
})(jQuery);
;(function($){
	$.extend(DR.Utils.FormUtils, {
		checkAllowFocus: function(fldObj,$allHiddenFields) {
			var isHidden = false;
			var $fldObj = $(fldObj);
			if ($allHiddenFields != null && typeof($allHiddenFields) != "undefined") {
				isHidden = $allHiddenFields.filter(fldObj).length > 0;
			} else {
				isHidden = $fldObj.is(":hidden");
			}
			if (isHidden || $fldObj[0].disabled == "disabled") {
				return false;
			} else {
				return true;
			}
		}
	});
})(jQuery);

	/******************************************************************************
	 * Utility function that replaces a css class with another for an element<br />
	 * Example: <code>DR.Utils.replaceCSSClass()</code><br />
	 * @param {Object/String} elem Object or id string of object you would like to replace a class on<br />
	 * @param {String} oldClassName Class name you would like to replace<br />
	 * @param {String} newClassName Class name you would like to be the replacement<br />
	 * @return VOID
	 * 
	 *****************************************************************************/
	DR.Utils.replaceCSSClass = function(elem, oldClassName, newClassName)
	{
		elem = (typeof elem == "object") ? elem : document.getElementById(elem);
		if(elem)
		{
			elem.className = elem.className.replace( oldClassName, newClassName ).trim();
		}
	};
	
	/******************************************************************************
	 * Utility function that checks if a element has a css class applied <br />
	 * Example: <code>DR.Utils.hasCSSClass('myclassname')</code><br />
	 * @param {Object/String} elem Object or id string of object you would like to check for the existence of a class <br />
	 * @param {String} className Class name to check<br />
	 * @return BOOLEAN
	 * 
	 *****************************************************************************/
	DR.Utils.hasCSSClass = function(elem,cssClassName)
	{
		elem = (typeof elem == "object") ? elem : document.getElementById(elem);
		if(elem)
		{
			if(elem.className.indexOf(cssClassName)>-1){
				return true;
			}
		}
		return false;
	}
	

		
	/******************************************************************************
	 * Utility function that removes a css class from an element, if present<br />
	 * Example: <code>DR.Utils.removeCSSClass()</code><br />
	 * @param {Object/String} elem Object or id string of object you would like to remove a class on<br />
	 * @param {String} className Class name you would like to remove<br />
	 * @return VOID
	 * 
	 *****************************************************************************/
	DR.Utils.removeCSSClass = function(elem, className)
	{
		elem = (typeof elem == "object") ? elem : document.getElementById(elem);
		if(elem)
		{
			elem.className = elem.className.replace( className, "" ).trim();
		}
	};
	
	/******************************************************************************
	 * Utility function that adds a css class to an element<br />
	 * Example: <code>DR.Utils.addCSSClass()</code><br />
	 * @param {Object|String} elem Object or id string of object you would like to add a class on<br />
	 * @param {String} className Class name you would like to add<br />
	 * @return VOID
	 * 
	 *****************************************************************************/
	DR.Utils.addCSSClass = function(elem, className)
	{
		elem = (typeof elem == "object") ? elem : document.getElementById(elem);
		if(elem)
		{
			DR.Utils.removeCSSClass( elem, className );
			elem.className = (className + " " + elem.className ).trim();
		}
	};
	
	/******************************************************************************
	 * Utility function that sets a css class to an element -- overriding any other previously set class names<br />
	 * Example: <code>DR.Utils.setCSSClass()</code><br />
	 * @param {Object|String} elem Object or id string of object you would like to add a class on<br />
	 * @param {String} className Class name you would like to add<br />
	 * @return VOID
	 * 
	 *****************************************************************************/
	DR.Utils.setCSSClass = function(elem, className)
	{
		elem = (typeof elem == "object") ? elem : document.getElementById(elem);
		if(elem)
		{
			elem.className = className;
		}
	};

	/******************************************************************************
	 * Utility function that returns the computed style. Styles apply via a style sheet
	 * do not show up with javascript through the normal style property. Use this
	 * function to get access one.
	 * Example: <code>DR.Utils.getStyle(id, propName)</code>
	 * @param {String} id Id string or object for the element to get the property from
	 * @param {String} propName String camelCased javascript equivalent to the css property
	 * @return VOID
	 *****************************************************************************/
	DR.Utils.getStyle = function(id, propName) {
		var obj = (typeof id == 'object') ?  id : document.getElementById(id);
		var curStyle = "";
			
		if (document.defaultView && document.defaultView.getComputedStyle) 
		{
			DR.Utils.styleObj = document.defaultView.getComputedStyle(obj, null);
			curStyle = DR.Utils.styleObj ? eval("DR.Utils.styleObj." + propName) : null;
		} 
		else if (obj.currentStyle) 
		{
			curStyle = obj.currentStyle[propName];
		}
		      
		return curStyle;
	};

	/******************************************************************************
	 * Utility function that makes a <code><li></code> link disabled<br />
	 * Example: <code>DR.Utils.disableListLink()</code><br />
	 * @param {Object/String} id Object or id string of <code><li></code> to disable<br />
	 * @param {Function} onclickFunc<br />
	 * @return VOID
	 * 
	 *****************************************************************************/
	DR.Utils.disableListLink = function(id, onclickFunc)
	{
		var li = (typeof id == 'object') ?  id : document.getElementById(id);

		DR.Utils.addCSSClass(li,'disabled');

		var a = li.getElementsByTagName('a');

		if(a.length==1)
		{
			var link = a[0];
			link.removeAttribute('href');

			if(typeof(link.onclick)=='function')
			{
				link.onclick_disabled = link.onclick;
			}
			if(typeof(onclickFunc)=='function')
			{
				link.onclick = onclickFunc;
			}
		}
	};

	/******************************************************************************
	 * Utility function that makes a <code><li></code> link enabled<br />
	 * Example: <code>DR.Utils.enableListLink()</code><br />
	 * @param {Object/String} id Object or id string of <code><li></code> to enable<br />
	 * @return VOID
	 * 
	 *****************************************************************************/
	DR.Utils.enableListLink = function(id)
	{
		var li = (typeof id == 'object') ?  id : document.getElementById(id);
		DR.Utils.removeCSSClass(li,'disabled');
		var a = li.getElementsByTagName('a');

		if(a.length==1)
		{
			var link = a[0];
			link.setAttribute('href','#');
			var od = link.getAttribute('onclick_disabled');

			if(typeof(od)=='function')
			{
				link.onclick = link.onclick_disabled;
			}
			else if(typeof(od)=='object')
			{
				link.onclick = eval(link.onclick_disabled);
			}
			link.removeAttribute('onclick_disabled');
		}			
	};
					
	/******************************************************************************
	 * Utility function that inserts a DOM element above another<br />
	 * Example: <code>DR.Utils.insertBefore()</code><br />
	 * @param {String} parentNode<br />
	 * @param {String} newNode<br />
	 * @param {String} siblingNode<br />
	 * @return VOID
	 * 
	 *****************************************************************************/
	DR.Utils.insertBefore = function(parentObj, newNode, siblingNode)
	{
		var nodeName = parentObj.tagName.toLowerCase();
		if(document.all && nodeName=="td")
		{
			var n = parentNode.appendChild(newNode,siblingNode);
			parentObj.appendChild(siblingNode,n);
		}
		else
		{
			parentObj.insertBefore(newNode,siblingNode);
		}
	};
	
	DR.Utils.insertAfter = function(parentObj, nodeToAdd, referenceNode) {
	  return parentObj.insertBefore(nodeToAdd, referenceNode.nextSibling);
	}

	/******************************************************************************
	 * Attach a new HTML element to the body, specifically, we insert before the first node in the body node.<br />
	 * Example: <code>DR.Utils.addToBody()</code><br />
	 * @param {String} el<br />
	 * @return el
	 * 
	 *****************************************************************************/
	DR.Utils.addToBody = function (el)
	{
		var bodyObj = document.getElementsByTagName("BODY")[0];
		var firstNode = bodyObj.firstChild;
		bodyObj.insertBefore(el,firstNode);
		bodyObj=null;
		firstNode = null;
		return  el;
	};

	/******************************************************************************
	 * Utility function that attaches a CSS stylesheet
	 * Example: <code>DR.Utils.attachCssStyleSheet(url)</code>
	 * @param {String} url Url of css stylesheet to be attached
	 * @return VOID
	 *****************************************************************************/
	DR.Utils.attachCssStyleSheet = function(url) {
		var headID = document.getElementsByTagName("head")[0];         
		var cssNode = document.createElement('link');
			cssNode.type = 'text/css';
			cssNode.rel = 'stylesheet';
			cssNode.href = url;
			//cssNode.media = 'print';
		headID.appendChild(cssNode);
	};

	/******************************************************************************
	 * Utility function that attaches a CSS stylesheet
	 * Example: <code>DR.Utils.getStyle(id, propName)</code>
	 * @param {String} url Url of css stylesheet to be attached
	 * @return VOID
	 *****************************************************************************/
	DR.Utils.getElem = function(id)
	{
		var o = document.getElementById(id);
		if (o)
		{
			return o;
		}
		else
		{
			window.status = 'Html element not found: '+id;
			return null;
		}
	};
	
	/******************************************************************************
	 * Utility function that gets a collection of elements that match a css selector
	 * Scope can be passed in 
	 * Example: <code>DR.Utils.getElementsByClassName(className, myDiv)</code>
	 * @param {String} cssClass CSS Class Name
	 * @param {Object} scope Object reference or a string ID of an element
	 * @return Array
	 *****************************************************************************/
	DR.Utils.getElementsByClassName = function(cssClass,scope){
		if(cssClass.indexOf('.')== -1){
			cssClass = "." + cssClass;
		}
		if( typeof scope == "object"){
			return jQuery(cssClass,scope);
		}
		else if (typeof scope == "string" && scope!==""){
			if(scope.indexOf('#')== -1){
				scope = "#" + scope;
			}
			return jQuery( scope + " " + cssClass);
		}else{
			return jQuery(cssClass);
		}
	};
	
	/******************************************************************************
	 * Utility function that gets first match of elements that match a css selector
	 * Scope can be passed in 
	 * Example: <code>DR.Utils.getFirstElementByClassName(className, myDiv)</code>
	 * @param {String} cssClass CSS Class Name
	 * @param {Object} scope Object reference or a string ID of an element
	 * @return Object
	 *****************************************************************************/
	DR.Utils.getFirstElementByClassName = function(cssClass,scope){
		var collection = DR.Utils.getElementsByClassName(cssClass,scope);
		if(collection.length>0)
		{
			return collection[0];
		}
		return null;
	};
	
	/******************************************************************************
	 * Utility function that gets a collection of elements that match a css selector
	 * Scope can be passed in to limit the query to children of a dom node
	 * Example: <code>DR.Utils.getElementsBySelectorPath("UL#menu LI A", myDiv)</code>
	 * @param {String} path CSS Selector rule
	 * @param {Object} scope Object reference or a string ID of an element
	 * @return Array
	 *****************************************************************************/
	DR.Utils.getElementsBySelectorPath = function(path,scope){
		if(path.indexOf('.')== -1){
			path = "." + path;
		}
		if( typeof scope == "object"){
			return jQuery(path,scope);
		}
		else if (typeof scope == "string" && scope!==""){
			if(scope.indexOf('#')== -1){
				scope = "#" + scope;
			}
			return jQuery( scope + " " + path);
		}else{
			return jQuery(path);
		}
	};
	
	/******************************************************************************
	 * Utility function that gets first match of elements that match a css selector
	 * Scope can be passed in 
	 * Example: <code>DR.Utils.getFirstElementBySelectorPath("UL#menu LI A", myDiv)</code>
	 * @param {String} path CSS Selector rule
	 * @param {Object} scope Object reference or a string ID of an element
	 * @return Object
	 *****************************************************************************/
	DR.Utils.getFirstElementBySelectorPath = function(path,scope){
		var collection = DR.Utils.getElementsBySelectorPath(path,scope);
		if(collection.length>0)
		{
			return collection[0];
		}
		return null;
	};
	
	/******************************************************************************
	 * Utility function that attaches DR stylesheets based on browser.
	 * 
	 * This function should be placed in the head section of the html
	 * Example: <code>DR.Utils.attachDRFrameworkCSS()</code>
	 * @return VOID
	 *****************************************************************************/
	DR.Utils.attachDRFrameworkCSS = function(){
		var appName = navigator.appName;
		var isIE = (appName.indexOf("Explorer") > -1);
		var isIE7 = (navigator.appVersion.indexOf("MSIE 7") > -1);
		var isSafari = (navigator.userAgent.indexOf("AppleWebKit") > -1);
		
		var cssFile 	 = 'dr-stylesheet-ff-compressed.css';
		
		if (isIE7)
		{
			cssFile 	 = 'dr-stylesheet-ie7-compressed.css';
		}else if(isIE){
			cssFile 	 = 'dr-stylesheet-ie6-compressed.css';
		}
		
		var url = $.dr.FRAMEWORK_PATH + 'css/' + cssFile ;
		DR.Utils.attachCssStyleSheet(url);
	};
	
	/******************************************************************************
	 * Utility function that replaces a div's contents
	 * 
	 * Example: <code>DR.Utils.replaceHtml(el,html)</code>
	 * @return VOID
	 *****************************************************************************/
	DR.Utils.replaceHtml = function(el, html) {
		var div = typeof el === "string" ? document.getElementById(el) : el;
		return jQuery(div).html(html);
	}
	
	
	 /******************************************************************************
	 * @constructor
	 *
	 * DR.Utils.DragObject()
	 * 
	 * The DragObject is a UI utility oject that allows an element such as a DIV 
	 * to be dragged around the screen.
	 *
	 * @TO-DO - Implement functions for a type of PanelSet "TwoRow"
	 *
	 * Example code to create a  DragObject:
	 *
	 * 	var dragObj = new DragObject(document.getElementById('myDiv'));
	 * 
	 * Arguments:
	 * 
	 * @param {Object} dragObj 	==> Object to add dragging function to
	 *
	 * Internal Properties:
	 * 
	 * type			 	==> Either Absolute or PanelSet
	 * dragObj 			==> HtmlElement that is dragged by mouse move
	 * parentObj 		==> Optional element used in the PanelSet to constrain
	 *						the dragging to a rectangle region of the screen
	 * moveCallback 	==> Boolean that lets the object know if it should call
	 *						moveDrag on the parentObj
	 * stopCallback 	==> Boolean that lets the object know if it should call
	 *						stopDrag on the parentObj
	 * isInitialized 	==> Whether the object has been inited
	 * cursorX 			==> Original mouse X position when drag started
	 * cursorY 			==> Original mouse X position when drag started
	 * dragObjLeft 		==> Distance in pixels from left of dragObj
	 * dragObjTop 		==> Distance in pixels from top of dragObj
	 * moveDragFunc 	==> Reference to moveDrag function
	 * stopDragFunc 	==> Reference to stopDrag function
	 *
	 * @return DragObject
	 *
	 *****************************************************************************/
	DR.Utils.DragObject = function(dragObj){
		if (typeof dragObj == 'object')
		{
			this.type = "Absolute";
			this.dragObj = dragObj;
			this.parentObj = null;
			this.moveCallback = null;
			this.stopCallback = null;
			this.isDragging = false;
			this.isInitialized = false;
			this.cursorX = 0;
			this.cursorY = 0;
			this.dragObjLeft = 0;
			this.dragObjTop = 0;
			this.mouseXOffest=14;
			this.mouseYOffest=19;
			this.moveDragFunc = null;
			this.stopDragFunc = null;
			this.snapToMouse = false;
		}else{
			return null;
		}
	};
	
	DR.Utils.DragObject.prototype = {

		/******************************************************************************
		 * @public
		 *
		 * obj.setType()
		 *
		 * Sets the type and parentObj
		 * 
		 * @param {String} type 
		 * @param {Object} parentObj
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setType: function(type,parentObj)
		{
			if (typeof type == 'string' )
			{
				this.type = type;
			}
			if (typeof parentObj == 'object' )
			{
				this.parentObj = parentObj;
			}
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.setSnapToMouse()
		 *
		 * Sets if the drag object should be stuck to the mouse.
		 * 
		 * @param {Boolean} flag 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setSnapToMouse: function(flag)
		{
			this.snapToMouse = Boolean(flag);
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.setMoveDragCallback()
		 *
		 * Sets the moveCallback flag to be enabled/disabled
		 * 
		 * @param {Boolean} flag 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setMoveDragCallback: function(flag)
		{
			this.moveCallback = Boolean(flag);
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.setStopDragCallback()
		 *
		 * Sets the stopCallback flag to be enabled/disabled
		 * 
		 * @param {Boolean} flag 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setStopDragCallback: function(flag)
		{
			this.stopCallback = Boolean(flag);
		},
		
		/******************************************************************************
		 * @public
		 * 
		 * obj.initDrag()
		 *
		 * Initilizes mouse and element properties and attaches functions
		 * to the mousemove and mousedown events
		 * 
		 * @return VOID
		 *****************************************************************************/
		initDrag: function(event)
		{
			this.isDragging = false;
			this.isInitialized = true;
				
			var x,y;
	
			if (window.event) {
				x = window.event.clientX + document.documentElement.scrollLeft + document.body.scrollLeft;
				y = window.event.clientY + document.documentElement.scrollTop + document.body.scrollTop;
			}else {
				x = event.clientX + window.scrollX;
				y = event.clientY + window.scrollY;
			}
		  
			this.cursorX = x;
			this.cursorY = y;
			if (this.type=="Absolute")
			{
				this.dragObjLeft  = parseInt(this.dragObj.style.left, 10);
				this.dragObjTop   = parseInt(this.dragObj.style.top,  10);
			}
			else if (this.type=="PanelSet")
			{
				if (this.parentObj.container!==null){
					this.dragObjLeft  = x - parseInt(this.parentObj.container.offsetLeft, 10) - parseInt(this.parentObj.staticHandle.style.left, 10);
					this.dragObjTop   = y - parseInt(this.parentObj.container.offsetTop, 10);
				}
			}
			
			if (isNaN(this.dragObjLeft)){
				this.dragObjLeft = 0;
			}
			if (isNaN(this.dragObjTop)){
				this.dragObjTop  = 0;
			}
			
			var myObj = this;
			if(this.moveDragFunc===null)
			{
				this.moveDragFunc = function(event){myObj.moveDrag(event);};
				this.stopDragFunc = function(event){myObj.stopDrag(event);};
			}
			
			this.attachEvents();
			if(!this.snapToMouse)
			{
				this.cancelEventPropagation(event);
			}
		},
		
		/******************************************************************************
		 * @private
		 * 
		 * obj.moveDrag()
		 *
		 * Fires once the user starts dragging the window around. It also cancels 
		 * any events like selecting text, that might normally happen
		 * 
		 * @return VOID
		 *****************************************************************************/
		moveDrag: function(event)
		{
			if (this.isInitialized)
			{
				var x, y;
				if (!this.isDragging)
				{
					this.isDragging=true;
					if (this.moveCallback)
					{
						if (typeof this.parentObj.moveDrag == 'function')
						{
							this.parentObj.moveDrag();
						}
					}
				}
				
				// Get the current mouse position
				if (window.event) {
					x = window.event.clientX + document.documentElement.scrollLeft + document.body.scrollLeft;
					y = window.event.clientY + document.documentElement.scrollTop + document.body.scrollTop;
				}else{
					x = event.clientX + window.scrollX;
					y = event.clientY + window.scrollY;
				}
				
				if (this.type=="Absolute")
				{
					if(this.snapToMouse)
					{
						this.dragObj.style.left = (x + this.mouseXOffest) + "px";
						this.dragObj.style.top  = (y + this.mouseYOffest) + "px";  
						
					}else{
						this.dragObj.style.left = (this.dragObjLeft + x - this.cursorX) + "px";
						this.dragObj.style.top  = (this.dragObjTop  + y - this.cursorY) + "px";  					
					}
				}
				else if (this.type=="PanelSet")
				{
					if (this.parentObj.layout=='TwoColumn')
					{
						
						var newX 	 = Math.max( x - parseInt(this.parentObj.container.offsetLeft, 10) - this.dragObjLeft  , this.parentObj.column1MinWidth);
						var finalX	 = Math.min(newX,  this.parentObj.panelWidth - this.parentObj.column2MinWidth -  this.parentObj.leftPadding);
						this.dragObj.style.left = finalX + "px";
					}
					else if (this.parentObj.layout=='TwoRow')
					{
						this.dragObj.style.top  = (this.dragObjTop + y - parseInt(this.parentObj.container.offsetTop, 10)) + "px";
					}
				}
						
				this.cancelEventPropagation(event);
			}
		},
		
		/******************************************************************************
		 * @private
		 * 
		 * obj.stopDrag()
		 *
		 * Once the user "drops" the dialog by the onmouseup event, we mark the 
		 * dragging flag to be false and remove the mousemove and mouseup events
		 * 
		 * @return VOID
		 *****************************************************************************/
		stopDrag: function()
		{
			this.detachEvents();
			if (this.stopCallback)
			{	
				if (typeof this.parentObj.stopDrag == 'function')
				{
					this.parentObj.stopDrag();
				}
			}
		},
		
		/******************************************************************************
		 * @private
		 * 
		 * obj.attachEvents()
		 *
		 * When the user has clicked down on the draggable element, we attach events
		 * to start watching the mouse movement.
		 * 
		 * @return VOID
		 *****************************************************************************/
		attachEvents: function()
		{
			if (document.attachEvent) {
				document.attachEvent("onmousemove", this.moveDragFunc );
				if(!this.snapToMouse)
				{		
					document.attachEvent("onmouseup",   this.stopDragFunc);
				}
			}else{
				document.addEventListener("mousemove", this.moveDragFunc ,   true);
				if(!this.snapToMouse)
				{
					document.addEventListener("mouseup",   this.stopDragFunc, true);
				}
			}
		},
	
		/******************************************************************************
		 * @private
		 * 
		 * obj.detachEvents()
		 *
		 * Once the user "drops" the dialog by the onmouseup event, we kill the 
		 * onmousemove and onmouseup event watching
		 * 
		 * @return VOID
		 *****************************************************************************/
		detachEvents: function()
		{
			if (document.detachEvent) {
				document.detachEvent("onmousemove", this.moveDragFunc );
				if(!this.snapToMouse)
				{
					document.detachEvent("onmouseup",   this.stopDragFunc);
				}
			}else{
				document.removeEventListener("mousemove", this.moveDragFunc , true);
				if(!this.snapToMouse)
				{
					document.removeEventListener("mouseup",   this.stopDragFunc, true);
				}
			}		
		},
	
		/******************************************************************************
		 * @private
		 * 
		 * obj.cancelEventPropagation()
		 *
		 * Prevents text on the screen from being selected while a drag operation 
		 * is currently active
		 * 
		 * @return VOID
		 *****************************************************************************/
		cancelEventPropagation: function(event)
		{
			if (window.event) {
				window.event.cancelBubble = true;
				window.event.returnValue = false;
			}else{
				event.preventDefault();
			}
		}
	};

		
	DR.Utils.customOnload = function() {
	  //EMPTY implementation DO NOT add implementation here.
	  //Add customOnload() method to your page to provide an page specific onload implementation
	};
	
	/******************************************************************************
	 * Utility function that attaches an event to an element - cross browser<br />
	 * Example: <code>DR.Utils.addEvent()</code><br />
	 * @param {Object} obj Object to add an event to<br />
	 * @param {Event} evt Event you would like to add<br />
	 * @param {Function} fn<br />
	 * @param {Boolean} useCapture<br />
	 * @return Boolean
	 * 
	 *****************************************************************************/
	DR.Utils.addEvent = function(obj, evt, fn, useCapture)
	{
		if (obj.addEventListener)
		{
			obj.addEventListener(evt, fn, Boolean( useCapture ));
			return true;
		}
		else if (obj.attachEvent)
		{
			var r = obj.attachEvent("on"+evt, fn);
			return r;
		}
		else
		{
			return false;
		}
	};

	/******************************************************************************
	 * Utility function that detaches an event from an element - cross browser<br />
	 * Example: <code>DR.Utils.removeEvent()</code><br />
	 * @param {Object} obj Object to remove an event to<br />
	 * @param {Event} evt Event you would like to remove<br />
	 * @param {Function} fn<br />
	 * @param {Boolean} useCapture<br />
	 * @return Boolean
	 * 
	 *****************************************************************************/
	DR.Utils.removeEvent = function(obj, evt, fn, useCapture)
	{
		if (obj.removeEventListener)
		{
			obj.removeEventListener(evt, fn, Boolean( useCapture ));
			return true;
		}
		else if (obj.detachEvent)
		{
			var r = obj.detachEvent("on"+evt, fn);
			return r;
		}
		else
		{
			return false;
		}
	};

	/******************************************************************************
	 * Utility to cancel a key click event, currently only used in topMenu
	 * Example: <code>DR.Utils.voidClick()</code>
	 * @return {Boolean} Boolean
	 *****************************************************************************/
	DR.Utils.voidClick =  function()
	{
	
		if($.browser.msie && parseInt($.browser.version, 10) < 7)
		{		
			// IE6 would pass this test
			return true;
		}
		else{
			return false;
		}
	};

	/******************************************************************************
	 * Utility to cancel a key press event
	 * Example: <code>DR.Utils.suppressKeypress(event)</code>
	 * @param {Event} evt event obejct
	 * @return {Boolean} Boolean
	 *****************************************************************************/
	DR.Utils.suppressKeypress = function (evt)
	{
		if (window.event)
		{
			window.event.cancelBubble = true;
			return false;
		}
		if (evt && evt.preventDefault)
		{
			evt.preventDefault();
		}
	};
	
	/******************************************************************************
	 * Utility function to stop a mouse click. 
	 * Example: <code>DR.Utils.stopMouseClick(event)</code>
	 * @param {Event} evt event obejct
	 * @return {Boolean} Boolean
	 *****************************************************************************/
	DR.Utils.stopMouseClick = function (evt)
	{
		if(window.event)
		{
			event.cancelBubble=true;
			return false;
		} 
		else if (evt && evt.preventDefault) 
		{
			evt.preventDefault();
			evt.stopPropagation();
		}
	};
		
;(function($){
    $.extend(DR.Utils.FormUtils, {
         /******************************************************************************
         * Returns the Element object for the requested for. Null is returned if not found.<br />
         * Example: DR.Utils.FormUtils.getField(fldName, frm)
         * @param {String} fldName The name of the form field. A name attribute must be
         * already specified on the form element.
         * @param {String|Integer|Object} frm can either be a string of the formName or
         * an integer representing the form's indexed position or an object.
         * @return HTMLInputElement|HTMLButtonElement|HTMLSelectElement|HTMLTextAreaElement
         *****************************************************************************/
         getField: function (fldName, frm) {
            var formObj = (typeof frm == "object") ? frm : document.forms[frm];
            return formObj.elements[fldName];
         }
    });
})(jQuery);
;(function($){
    $.extend(DR.Utils.FormUtils, {
         /******************************************************************************
         * Return the desired form requested by the "frm" argument.<br />
         * Example: DR.Utils.FormUtils.getForm(frm)
         * @param {String|Integer} frm can either be a string of the formName or an integer representing the form's indexed position.
         * @return HTMLFormElement
         *****************************************************************************/
         getForm: function (frm) {
            return document.forms[frm];
         }
    });
})(jQuery);
;(function($){
    $.extend(DR.Utils.FormUtils, {
        /******************************************************************************
         * Gets the value for a select option<br />
         * Example: DR.Utils.FormUtils.getMultiSelectTextValue(fldObj)
         * @param {HTMLSelectElement} fldObj
         * @return String
         *****************************************************************************/
        getMultiSelectTextValue: function(fldObj) {
            if(fldObj) {
                var a = [];
                for (var i = 0; i < fldObj.options.length; i++) {
                    if (fldObj.options[i].selected) {
                        a.push(fldObj.options[i].text);
                    }
                }
                return a.join(', ');
            }
        }
    });
})(jQuery);
;(function($){
    $.extend(DR.Utils.FormUtils, {
        /******************************************************************************
         * Gets the value for a select option<br />
         * Example: DR.Utils.FormUtils.getOptionValue(o)
         * @param {Object} o
         * @return Boolean
         *****************************************************************************/
        getSelectOptionValue: function(o) {
            if(o) {
                var val = "";
                //Normalize value for IE && FF to match what will get posted. 
                //IE does not return the "text" if the value attribute is 
                //not specified.
                if (o.text !== "" && o.outerHTML && o.outerHTML.toLowerCase().indexOf("value=") == -1) {
                    val = o.text;
                } else {
                    val = o.value;
                }
                return val;
            }
        }
    });
})(jQuery);
;(function($){
	$.extend(DR.Utils.FormUtils, {
		getUTF8Bytes: function(val){
			var rawLength = val.length;
			var escapedStr = encodeURI(val);
			var escapedArray;
			var count;
			if (escapedStr.indexOf("%") != -1) {
				escapedArray = escapedStr.split("%");
				count = escapedArray.length - 1;
				if (count === 0){
					//can't happen with real UTF-8
					count++;
				}
				var tmp = escapedStr.length - (count * 3);
				count = count + tmp;
			}else{
				count = rawLength;
			}
			if (!$.browser.msie)
			{
				// Firefox/mozilla do not count line breaks as 2 characters, which is incorrect
				// So we replace them with a two char string to get the correct length
				var ffLength = val.replace(/\n/g,'..').length;
				var numLineBreaks = ffLength - rawLength;
				count = count + numLineBreaks;
			}
			return {bytes:escapedStr,byteCount:count};
		}
	});
})(jQuery);
;(function($){
	$.extend(DR.Utils.FormUtils, {
		getValue: function (fld, frm) {
			var frmObj = null;
			if (frm !==undefined && typeof fld != "object") {
				frmObj = (typeof frm == "object") ? frm : document.forms[frm];
			}
			if(!frmObj) {
				return null;
			}
			var fldObj = (typeof fld == "object") ? fld: frmObj.elements[fld];
			if(!fldObj) {
				return null;
			}
			var fieldType = (!fldObj.type && !!fldObj[0]) ? fldObj[0].type: fldObj.type;
			if(!fieldType) {
				return null;
			}
			var type = (fieldType.substring(0,6) == "select") ? "select": fieldType;
			var value = [];
			var isArray = false;
			if( typeof fldObj.type == "undefined" ) {
				isArray = true;
			}
			if( type == "select") {
				if (isArray) {
					for( var i=0; i < fldObj.length; i++ ){
						value.push(DR.Utils.FormUtils.getSelectOptionValue(fldObj[i]));
					}
				} else {
					if (fldObj.multiple) {
						for (var j = 0; j < fldObj.options.length; j++) {
							if (fldObj.options[j].selected) {
								value.push(DR.Utils.FormUtils.getSelectOptionValue(fldObj.options[j]));
							}
						}
					} else {
						try{value.push(DR.Utils.FormUtils.getSelectOptionValue(fldObj.options[fldObj.selectedIndex]));}
						catch(err){}
					}
				}
			} else if( (type == "checkbox") || (type == "radio") ) {
				if (isArray) {
					for( var k=0; k < fldObj.length; k++ ) {
						if( fldObj[k].checked ) {
							value.push(fldObj[k].value);
						}
					}
				} else {
					if(fldObj.checked) {
						value.push(fldObj.value);
					}
				}
			} else {
				// Text input, hidden input, or textarea would fall through to this case
				if (isArray) {
					for(var m=0; m < fldObj.length; m++) {
						value.push(fldObj[m].value);
					}
				} else {
					value.push(fldObj.value);
				}
			}
			return value.join(",");
		}
	});
})(jQuery);
	DR.Utils.Logger = function(id){
		this.id = id;
		this.items = null;
		this.inited = false;
		this.disabled=false;
	};
	
	DR.Utils.Logger.prototype = {
		
		init: function(str){
	
			if(this.overlay===undefined)
			{

				var d = document.createElement('div');
					d.id = this.id+'_logger';
				var c = document.createElement('div');
					c.className = 'modalScrollerMediumHeight';
					c.style.width = '300px';
					c.style.height = '300px';
				this.overlayContent = c;
					
				var b = document.createElement('div');
					b.className = 'pageButtons';
					b.innerHTML = '<button onclick="'+this.id+'.clear();" >Clear</button><button onclick="overlayStack.hideCurrent();" style="margin-right:0;">Close</button>';
				d.appendChild(c);
				d.appendChild(b);
				var parentObj = $('div.content:first') || $('body');
				parentObj.append(d);
				
				this.overlay = new DR.Widgets.InlineModelessOverlay(this.id+'_logger');
			    this.overlay.setTitle("Logger");
			    this.overlay.setSize(350,350);
				this.overlay.show();
				this.inited = true;
			}
	
		},
	
		hide: function(str){
			if(this.inited)
			{
				overlayStack.hideCurrent();
			}
		},
		
		clear: function(str){
			if(this.inited)
			{
				this.items = null;
				this.overlayContent.innerHTML = "";
			}
	
		},
		
		disable: function(){
			this.disabled = true;
	
		},
		
		log: function(str,refresh){
			if(this.disabled)
			{
				return;
			}
			
			if(!this.inited)
			{
				this.init();
				overlayStack.disableCurrent();
			}
			
			// Force the str var to be a string
			str = str + "";
			if(this.items===null)
			{
				this.items = [str];
			}else{
				this.items.push(str);
			}
			if(refresh!==false)
			{
				this.refresh();
			}
		},
		
		refresh: function(str){
			var h = '<table cellpadding="0" cellspacing="0" class="dataTable" style="border:1px solid #666;">';
				h+= '<thead><th style="width:20px;">ID</th><th>Value</th></thead>';
				h+= '<tbody>';
			var items = this.items;
			for(var i=0; i<items.length; i++)
			{
				h+= '<tr><td>'+(i+1)+'</td><td>'+items[i]+'</td></tr>';
			}
			h+='</tbody></table>';
			this.overlayContent.innerHTML = h;
			this.refreshScroll();
			var oSelf = this;
			var func = function(){
				oSelf.refreshScroll();
			};
			window.setTimeout(func,1000);
		},
	
		refreshScroll: function(str){
			this.overlayContent.scrollTop = parseInt(this.overlayContent.offsetHeight,10);
		}
	};
	
	var DR_Utils_Logger = new DR.Utils.Logger('DR_Utils_Logger');
	
	
	function log(_item){
		DR_Utils_Logger.log(_item);
	}
	DR.Utils.PageSizer = function()
	{
		this.pageWidth = 0;
		this.pageHeight = 0;
		this.windowWidth = 0;
		this.windowHeight = 0;
	};
	
	DR.Utils.PageSizer.prototype = {
		
		initModalScroller: function ()
		{
			this.attachModalOnresize();
			this.refreshModalScroller();
		},
		
		attachModalOnresize: function ()
		{
			var self = this;
			var fnOnresize = window.onresize;
			var winOnresize = function(){self.refreshModalScroller();};
			window.onresize  = function(){winOnresize(); if(typeof(fnOnresize)=='function'){fnOnresize();}};
			
			function cleanupEvents(){
				// The following lines prevent a memory leak in Internet Explorer from the closure type of leak
				// We need to detach all the functions that were dynamically assigned to any DOM elements		
				window.detachEvent("onresize",winOnresize);
			}
			
			if($.browser.msie){
				if (window.attachEvent){
					window.attachEvent("onunload",cleanupEvents);
				}
			}
		},
		
		refresh: function ()
		{
	
			var xScroll, yScroll,pageHeight,pageWidth;
	
			var obj = {};
	
			if (window.innerHeight && window.scrollMaxY) {
				xScroll = document.body.scrollWidth;
				yScroll = window.innerHeight + window.scrollMaxY;
			} else if (document.body.scrollHeight > document.body.offsetHeight){ // all but Explorer Mac
				xScroll = document.body.scrollWidth;
				yScroll = document.body.scrollHeight;
			} else { // Explorer Mac...would also work in Explorer 6 Strict, Mozilla and Safari
				xScroll = document.body.offsetWidth;
				yScroll = document.body.offsetHeight;
			}
			var windowWidth, windowHeight;
			if (self.innerHeight) {	// all except Explorer
				windowWidth = self.innerWidth;
				windowHeight = self.innerHeight;
			} else if (document.documentElement && document.documentElement.clientHeight) { // Explorer 6 Strict Mode
				windowWidth = document.documentElement.clientWidth;
				windowHeight = document.documentElement.clientHeight;
			} else if (document.body) { // other Explorers
				windowWidth = document.body.clientWidth;
				windowHeight = document.body.clientHeight;
			}
	
			// for small pages with total height less then height of the viewport
			if(yScroll < windowHeight){
				pageHeight = windowHeight;
			} else {
				pageHeight = yScroll;
			}
	
			// for small pages with total width less then width of the viewport
			if(xScroll < windowWidth){
				pageWidth = windowWidth;
			} else {
				pageWidth = xScroll;
			}
			if(this.doc===undefined)
			{
				this.doc = {};
			}
			this.pageWidth = pageWidth;
			this.pageHeight = pageHeight;
			this.windowWidth = windowWidth;
			this.windowHeight = windowHeight;
		},
	
		refreshModalScroller: function()
		{
			var d = $('.modalScroller');
			if(d.length==0){
				 d = $('#modalScroller');
			}
			if(d.length>0)
			{
				d=d[0];
				this.refresh();
				var viewPortHeight = this.windowHeight;
				var viewPortWidth = this.windowWidth;
			
		
				var contentOffset = d.offsetTop;
				var pageButtons = $('.pageButtons');
				var buttonRowHeight = (pageButtons.length>0) ? pageButtons[0].offsetHeight : 0;
				buttonRowHeight = buttonRowHeight+32;
				var availableHeight = viewPortHeight;
				
			
				if(viewPortWidth<790)
				{
					// we need to subtract the height of the horizontal scrollbars because the user
					// is browsing with thier window smaller than the min width of the interface
					//availableHeight = availableHeight - 20;
				}
				
			
				//v ar boxWidth = viewPortWidth - (958-720);
				var boxHeight = availableHeight - d.offsetTop - buttonRowHeight;
				
				//alert("boxHeight:"+boxHeight+" - availableHeight: "+availableHeight + " - d.offsetTop: " + d.offsetTop);
				
				
				if(boxHeight>0)
				{
					d.style.height = boxHeight + "px";
					//boxWidth = boxWidth + 20;
				}
				//d.style.width = Math.max(boxWidth-20, 720) + "px";
				//s.style.width = Math.max(boxWidth-20, 720) + "px";
				//window.status = viewPortHeight + " " + d.offsetTop + " " + boxHeight;
			}
		}
	};
	
	DR.Utils.Position = function(toBePositioned) {
		this.obj = (typeof toBePositioned == "object") ? toBePositioned : document.getElementById(toBePositioned);
		this.x = this.getX();
		this.y = this.getY();
		this.width = this.getWidth();
		this.height = this.getHeight();
		//Calc the rest so the above properties can be referenced.
		this.top = this.getTop();
		this.right = this.getRight();
		this.left = this.getLeft();
		this.bottom = this.getBottom();
		
	
		//DR_Utils_Logger.log("id=" + this.obj.id + " x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + 
		//		" top=" + this.top + " right=" + this.right + " bottom=" + this.bottom + " left=" + this.left);
	};
	
	DR.Utils.Position.ON_TOP = 0;
	DR.Utils.Position.ON_MIDDLE = 1;
	DR.Utils.Position.ON_BOTTOM = 2;
	DR.Utils.Position.ON_LEFT = 4;
	DR.Utils.Position.ON_CENTER = 8;
	DR.Utils.Position.ON_RIGHT = 16;
	DR.Utils.Position.DRAW_LEFT = 32;
	DR.Utils.Position.DRAW_CENTERED = 64;
	DR.Utils.Position.DRAW_RIGHT = 128;
	DR.Utils.Position.DRAW_UP = 256;
	DR.Utils.Position.DRAW_DOWN = 1024;
	
	DR.Utils.Position.prototype = {
		
		setPosition: function(top, left) {
			//@TODO should detect if unit is present and append one if it is not;
			this.obj.style.top = top;
			this.obj.style.left = left;	
		},
		
		setRelativePosition: function(fromID, fromXEdge, drawingXDirection, fromYEdge, drawingYDirection, offsetX, offsetY, forceLoc) {
			this.setRelativeXPosition(fromID, fromXEdge, drawingXDirection, offsetX, forceLoc);
			this.setRelativeYPosition(fromID, fromYEdge, drawingYDirection, offsetY, forceLoc);
		},
		
		setRelativeXPosition: function(fromID, fromEdge, drawingDirection, offset, forceLoc) {
			//@TODO make sure directions are valid or default populate
			//@TODO consider adding a min distance from browser edge. Visually may look better
			var fromObj = new DR.Utils.Position(fromID);
			var startingX = fromObj.left;
			var availContentWidth = $(document).width();
			if (fromEdge == DR.Utils.Position.ON_CENTER) {
				startingX = fromObj.left + (Math.floor(fromObj.width/2));
			} else if (fromEdge == DR.Utils.Position.ON_RIGHT) {
				startingX = fromObj.right;
			}
			
			//DR_Utils_Logger.log('fromObj.left: ' + fromObj.left);
			
			if (drawingDirection == DR.Utils.Position.DRAW_LEFT) {
				
				if (forceLoc ||(startingX - this.width - offset) >= 0) {
					/* Adjust StratingX to Draw Object to the left if screen realestate permits */
					/* if forceLoc is true then draw offscreen if needed */
					startingX = startingX - this.width - offset;
				} else if ((startingX + this.width + offset) < availContentWidth) {
					/* Adjust StratingX to Draw Object to the right if screen realestate permits */
					startingX = startingX + this.width + offset;
				} else {
					/* Adjust StratingX to Draw Object as closest to the left as possible */
					startingX = 0;
				}
			} else if (drawingDirection == DR.Utils.Position.DRAW_RIGHT) {
				
				//DR_Utils_Logger.log('this.width: '+this.width);
				//DR_Utils_Logger.log('availContentWidth: '+availContentWidth);
				//DR_Utils_Logger.log('startingX + this.width + offset: '+(startingX + this.width + offset));
				
				
				if (forceLoc ||(startingX + this.width + offset) < availContentWidth) {
					/* Adjust StratingX to Draw Object to the right if screen realestate permits */
					/* if forceLoc is true then draw offscreen if needed */
					startingX = startingX  + offset;
					//DR_Utils_Logger.log('1');
				} else if ((startingX - this.width - offset) > 0) {
					/* Adjust StratingX to Draw Object to the left if screen realestate permits */
					startingX = startingX - this.width + fromObj.width;
					//DR_Utils_Logger.log('2');
				} else {
					/* Adjust StratingX to Draw Object as closest to the left as possible */
					startingX = availContentWidth;
					//DR_Utils_Logger.log('3');
				}
			} else if (drawingDirection == DR.Utils.Position.DRAW_CENTERED) {
				if (forceLoc ||(startingX - Math.floor((this.width - offset)/2)) > 0) {
					/* Adjust StratingX to Draw Object to the left if screen realestate permits */
					/* if forceLoc is true then draw offscreen if needed */
					startingX = startingX - Math.floor((this.width - offset)/2);
				} else {
					/* Adjust StratingX to Draw Object as closest to the left as possible */
					startingX = 0;
				}
			}
			//DR_Utils_Logger.log('startingX-final: ' + startingX);
			this.setX(startingX);
			
		},
		
		setRelativeYPosition: function(fromID, fromEdge, drawingDirection, offset, forceLoc) {
			//@TODO make sure directions are valid or default populate
			//@TODO consider adding a min distance from browser edge. Visually may look better
			var fromObj = new DR.Utils.Position(fromID);
			var startingY = fromObj.top;
			var availContentHeight = $(document).height();
			
			if (fromEdge == DR.Utils.Position.ON_MIDDLE) {
				startingY = fromObj.top + (Math.floor(fromObj.height/2));
			} else if (fromEdge == DR.Utils.Position.ON_BOTTOM) {
				startingY = fromObj.bottom;
			}
			
			if (drawingDirection == DR.Utils.Position.DRAW_UP) {
				//DR_Utils_Logger.log('startingY: '+startingY);
				//DR_Utils_Logger.log('this.height: '+this.height);
				//DR_Utils_Logger.log('startingY - this.height - offset:' + (startingY - this.height - offset));
				if (forceLoc ||(startingY - this.height - offset) > 0) {
					/* Adjust startingY to Draw Object to the left if screen realestate permits */
					/* if forceLoc is true then draw offscreen if needed */
					startingY = startingY - this.height - offset;
					//DR_Utils_Logger.log('1');
				} else if ((startingY + fromObj.height + this.height + offset) < availContentHeight) {
					/* Adjust startingY to Draw Object to the right if screen realestate permits */
					startingY = startingY + fromObj.height + offset;
					//DR_Utils_Logger.log('2');
				} else {
					/* Adjust startingY to Draw Object as closest to the left as possible */
					startingY = 0;
				}
			} else if (drawingDirection == DR.Utils.Position.DRAW_DOWN) {
				
				var tempHeight = startingY + this.height  + offset;
		
				//DR_Utils_Logger.log('availContentHeight: '+availContentHeight);
				//DR_Utils_Logger.log('tempHeight: '+tempHeight);
				
				if (forceLoc ||(tempHeight) < availContentHeight) {
					/* Adjust startingY to Draw Object to the bottom if screen realestate permits */
					/* if forceLoc is true then draw offscreen if needed */
					startingY = startingY + fromObj.height  + offset;
					//DR_Utils_Logger.log('1');
				} else if ((startingY - this.height - offset) > 0) {
					/* Adjust startingY to Draw Object above the from object if screen realestate permits */
					startingY = startingY - this.height - offset;
					//DR_Utils_Logger.log('2');
				} else {
					/* Adjust startingY to Draw Object as closest to the left as possible */
					startingY = availContentHeight;
				}
			} else if (drawingDirection == DR.Utils.Position.DRAW_CENTERED) {
				if (forceLoc ||(startingY - Math.floor((this.height - offset)/2)) > 0) {
					/* Adjust startingY to Draw Object to the left if screen realestate permits */
					/* if forceLoc is true then draw offscreen if needed */
					startingY = startingY - Math.floor((this.height - offset)/2);
				} else {
					/* Adjust startingY to Draw Object as closest to the left as possible */
					startingY = 0;
				}
			} 
		
			this.setY(startingY);
		},
		
		setX: function(left) {
			this.obj.style.left = left + "px";
		},
		
		setY: function(top) {
			this.obj.style.top = top + "px";
		},
		
		getX: function() {
			var curX = 0;
			var tempObj = this.obj;
			//alert(tempObj);
			if (tempObj.offsetParent)
			{
				while (tempObj.offsetParent)
				{
					curX += tempObj.offsetLeft;
					
					//add in td borders for IE
					if(tempObj.clientLeft && (tempObj.tagName == "TD") || (tempObj.tagName == "TH") )
			        {                             // if parent a table cell, then...
			           curX += tempObj.clientLeft; // append cell border width to calcs
			        }
					tempObj = tempObj.offsetParent;
				}
			}
			
			//add body margin in for IE
			//alert(document.compatMode);
			if (document.compatMode == "CSS1Compat" && !window.getComputedStyle) {
				curX += (isNaN(parseInt(document.body.currentStyle.marginLeft,10))) ? 0 : parseInt(document.body.currentStyle.marginLeft,10);
			} 
			
			return curX;
		
		},
		
		getY: function() {
			var curY = 0;
			var tempObj = this.obj;
			
			if (tempObj.offsetParent)
			{
				while (tempObj.offsetParent)
				{
					curY += tempObj.offsetTop;
					
					//add in td borders for IE
					if(tempObj.clientTop && (tempObj.tagName == "TD") || (tempObj.tagName == "TH") )
			        {                             // if parent a table cell, then...
			           curY += tempObj.clientTop; // append cell border width to calcs
			        }
					tempObj = tempObj.offsetParent;
				}
			}
			
			//add body margin in for IE
			if (document.compatMode == "CSS1Compat" && !window.getComputedStyle) {
				curY += (isNaN(parseInt(document.body.currentStyle.marginTop,10))) ? 0 : parseInt(document.body.currentStyle.marginTop,10);
			} 
				
			return curY;
		},
		
		getWidth: function() {
			return this.obj.offsetWidth;
		},
		
		getHeight: function() {
			return this.obj.offsetHeight;
		},
		
		getTop: function() {
			return this.y;
		},
		
		getRight: function() {
			return this.x + this.width;
		},
		
		getBottom: function() {
			return this.y + this.height;
		},
		
		getLeft: function() {
			return this.x;
		}
	};

	DR.Utils.Position.snapTo = function(sourceId, targetId, _offsetX, _offsetY, edgeX, edgeY, drawDirectionX, drawDirectionY, keepInView) {
		sourceObj = (typeof sourceId == "object") ? sourceId : document.getElementById(sourceId);
		targetObj = (typeof targetId == "object") ? targetId : document.getElementById(targetId);

		_offsetX = (_offsetX!==undefined) ? _offsetX : 0;
		_offsetY = (_offsetY!==undefined) ? _offsetY : 0;
		edgeX = (edgeX!==undefined) ? edgeX : 'Right';
		edgeY = (edgeY!==undefined) ? edgeY : 'Top';
		drawDirectionX = (drawDirectionX!==undefined) ? drawDirectionX : 'Right';
		drawDirectionY = (drawDirectionY!==undefined) ? drawDirectionY : 'Down';
		keepInView = (keepInView==false) ? false : true;
		
		var sourceX = sourceY = 0 , _width, _height;
	
		var obj = sourceObj;
		/*
		 * Loop through parents to find all offsets
		 */
		while (obj.offsetParent){
			sourceX += obj.offsetLeft;
			if(obj.scrollLeft){
				sourceX -= obj.scrollLeft;
			}
			
			sourceY += obj.offsetTop;

			if(obj.scrollTop){
				sourceY -= obj.scrollTop;
			}
			obj = obj.offsetParent;
		}
		/*
		 * Loop through parents to find any elements that are scrollable
		 */
		obj = sourceObj;
		while (obj.offsetParent){
			if(obj.scrollLeft){
				sourceX -= obj.scrollLeft;
			}
			if(obj.scrollTop){
				sourceY -= obj.scrollTop;
			}
			
			if($.browser.msie){
				// if parent a table cell, then add in td borders for IE
				 // append cell border width to calcs
				if( (obj.tagName == "TD") || (obj.tagName == "TH") ){ 
				   	if(obj.clientTop){
						sourceY += obj.clientTop; 
					}
					if(obj.clientLeft){
		           		sourceX += obj.clientLeft;
				   }
		        }
				if($(obj).hasClass('searchBody')){
					/*
					 * @TODO - figure out why IE6 and IE7 have the wrong offset
					 * when inside the left search panel
					 */
					sourceX-=11;
				}
			}
			
			obj = obj.parentNode;
		}
		
		sourceWidth = sourceObj.offsetWidth;
		sourceHeight = sourceObj.offsetHeight;
		
		targetX = sourceX;
		targetY = sourceY;
		
		
		if(edgeX=="Right"){
			targetX = sourceX + sourceWidth;
		}
		
		if(edgeY=="Bottom"){
			targetY = sourceY + sourceHeight;
		}
		
		if(keepInView)
		{
			var scrollX, scrollY;

			if(window.scrollX){
				/* IE */
				scrollX = window.scrollX;
				scrollY = window.scrollY;
			}else{
				/* Firefox */
				scrollX = document.documentElement.scrollLeft + document.body.scrollLeft;
				scrollY = document.documentElement.scrollTop + document.body.scrollTop;
			}
							
			/*
			 * Make sure to keep the target obj fully in view. To do this we will need to rotate
			 * around the source object
			 */
			targetWidth = targetObj.offsetWidth;
			targetHeight = targetObj.offsetHeight;

			var contentWidth = $(document).width();
			var contentHeight = $(document).height();

			/********************************************************************************
			 * Logic for making sure the target object stays visible in X plane, if possible
			 * 
			 * Scenarios:
			 * 
			 * drawDirectionX = RIGHT, doesn't fit RIGHT, fits LEFT -- match 2nd case 
			 * drawDirectionX = RIGHT, fits RIGHT doesn't fit LEFT  -- match 1st 
			 * 
			 * drawDirectionX = LEFT, doesn't fit RIGHT, fits LEFT -- match 2nd
			 * drawDirectionX = LEFT, fits RIGHT doesn't fit LEFT  -- match 1st
			 * 
			 *********************************************************************************/
			var rightEdgeWidth = sourceX + targetWidth + _offsetX;
			var leftEdgeWidth = sourceX - targetWidth - _offsetX;
			var fitsRightEdge = false;
			var fitsLeftEdge = false;

			if ( rightEdgeWidth <= (contentWidth+scrollX-sourceWidth) ) {
				/* Draw target to the right of source if screen realestate permits */
				fitsRightEdge = true;
			}
			if (leftEdgeWidth > scrollX) {
				/* Draw target to the left of source if screen realestate permits */
				fitsLeftEdge = true;
			}
			

			if((drawDirectionX=='Right' && fitsRightEdge) || (drawDirectionX=='Left' && !fitsLeftEdge && fitsRightEdge ))
			{
				targetX +=_offsetX;
			}else if(fitsLeftEdge){
				targetX = sourceX - targetWidth - _offsetX;
			}
			
			//log(fitsRightEdge + " " + fitsLeftEdge + " " +  sourceX  + " " + rightEdgeWidth + " " + contentWidth+ " " + scrollX  + " " + (contentWidth+scrollX))
			//log(fitsRightEdge + " " + fitsLeftEdge )
			
			/********************************************************************************
			 * Logic for making sure the target object stays visible in Y plane, if possible
			 * 
			 * Scenarios:
			 * 
			 * drawDirectionY = DOWN, doesn't fit BOTTOM, fits TOP -- match 2nd 
			 * drawDirectionY = DOWN, fits BOTTOM doesn't fit TOP  -- match 1st 
			 * 
			 * drawDirectionY = UP, doesn't fit BOTTOM, fits TOP -- match 2nd
			 * drawDirectionY = UP, fits BOTTOM doesn't fit TOP  -- match 1st
			 * 
			 *********************************************************************************/
			var bottomEdgeHeight = sourceY + targetHeight + _offsetY;
			var topEdgeHeight = sourceY - targetHeight - _offsetY;
			var fitsBottomEdge = false;
			var fitsTopEdge = false;


			if ( bottomEdgeHeight <= (contentHeight+scrollY-sourceHeight)) {
				/* Draw target below source if screen realestate permits */
				fitsBottomEdge = true;
			}
			if (topEdgeHeight > scrollY) {
				/* Draw target above source if screen realestate permits */
				fitsTopEdge = true;
			}
			

			if((drawDirectionY=='Down' && fitsBottomEdge) || (drawDirectionY=='Up' && !fitsTopEdge && fitsBottomEdge ))
			{
				targetY +=_offsetY;
			}else if(fitsTopEdge){
				targetY = sourceY - targetHeight - _offsetY;
			}
			
			
				
		}else{
			/*
			 * The target object may end up partially offscreen
			 */
			targetX += _offsetX;
			targetY += _offsetY;
		}

		targetObj.style.left = targetX +  'px';
		targetObj.style.top = targetY + 'px';

	};

	DR.Utils.Profiler = function(){
		this.startTime = new Date().getTime();
		this.benchmarks = [];
		this.log('Init Profiler');
	};
	
	DR.Utils.Profiler.prototype = {
		
		start: function(){
			this.startTime = new Date().getTime();
			this.benchmarks = [];
			this.log('Profiler: Start Timing');
		},
		
		log: function(_event){
			var obj = {};
				obj.time = new Date().getTime();
				obj._event = _event;
			this.benchmarks.push(obj);
		},
		
		view: function(){
			var benchmarks = this.benchmarks;
			var lastTime = this.startTime;
			if(window.console && !$.browser.safari){
				for(var i=0;i<benchmarks.length;i++){
					var time = benchmarks[i].time;
					var elapsedTime = time - this.startTime;
					var delta = time - lastTime;
					
					console.log("Elapsed time: " + elapsedTime + " - Delta: " + delta + " - " + benchmarks[i]._event);
					lastTime = time;
				}
			}else{
				
				var h = '<table cellpadding="4" cellspacing="1" border="1" >';
				h+='<tr><th nowrap="nowrap" style="width:75px;">Elapsed (ms)</th><th nowrap="nowrap" style="width:60px;">Delta (ms)</th><th>Event</th></tr>';
				for(var i=0;i<benchmarks.length;i++)
				{
					var time = benchmarks[i].time;
					var elapsedTime = time - this.startTime;
					var delta = time - lastTime;
					h+='<tr>';
						h+='<td>' + elapsedTime + '</td>';
						h+='<td>' + delta + '</td>';
						h+='<td nowrap="nowrap">' + benchmarks[i]._event + '</td>';
					h+='</tr>';
					lastTime = time;
				}
				h+='</table>';
				DR_Utils_Logger.log(h);
				DR_Utils_Logger.overlayContent.style.width = '400px';
				DR_Utils_Logger.overlay.setSize(450,350);
				DR_Utils_Logger.overlay.setTitle('Profiler');
				DR_Utils_Logger.overlay.refreshSize();
			}

		},
		
		clear: function(){
			this.benchmarks = [];
		}
	};
	
	var DR_Utils_Profiler  = new DR.Utils.Profiler();
		
	
	DR.Utils.Querystring = function(qs) { 
		this.params = {};
		
		if (qs === null) {
			//subtract off "?"
			qs=location.search.substring(1,location.search.length);
		} else {
			//remove question mark if present
			qs = (qs.indexOf("?") != -1) ? qs.substring(1,qs.length) : qs;
		}
	
		if (qs.length === 0) {
			 return;
		}
	
		qs = qs.replace(/\+/g, ' ');
		//split into name/value pairs
		var args = qs.split('&'); 
		var val;
		// split out each name=value pair
		for (var i=0;i<args.length;i++) {
			var value;
			alert(args[i]);
			var pair = args[i].split('=');
			var paramName = unescape(pair[0]);
	
			if (pair.length == 2) {
				val = unescape(pair[1]);
			} else {
				val = paramName;
			}
			
			this.params[paramName] = val;
		}
	};
	
	DR.Utils.Querystring.prototype.get = function(paramName) {
		var val=this.params[paramName];
		return val;
	};
	

;(function($){
    $.extend(DR.Utils.FormUtils, {
         setAction: function(formName, url) {
            if(formName) {
                var formObj = (typeof formName == "object") ? formName : document.forms[formName];
                    formObj.setAttribute('action',url);
            }
         }
    });
})(jQuery);
;(function($){
    $.extend(DR.Utils.FormUtils, {
		/******************************************************************************
		 * Example: DR.Utils.FormUtils.setOperationAndSubmit(triggerObj, event)
		 * @param {Object} triggerObj
		 * @param {Event} event
		 *****************************************************************************/
		setOperationAndSubmit: function (triggerObj, event) {
			var actionName = triggerObj.id || triggerObj.name;
			var actionObj = triggerObj.form.operation;
			if (typeof actionObj == 'object') {
				actionObj.value = actionName;
			}
			DR.Utils.FormUtils.submit(triggerObj.form);
			if (event) {
				event.returnValue = false;
				event.cancelBubble = true;
			}
			return false;
		}
	});
})(jQuery);
;(function($){
    $.extend(DR.Utils.FormUtils, {
        /******************************************************************************
         * Sets a select option to be selected if the value is matched<br />
         * Example: DR.Utils.FormUtils.setSelectOptionValue(o, val)
         * @param {Object} o
         * @param {String} val
         * @return VOID
         *****************************************************************************/
        setSelectOptionValue: function(o, val) {
            var match = (o.value == val || o.text == val);
            o.selected = match;
            return  match;
        }
    });
})(jQuery);
;(function($){
	/******************************************************************************
	 * Example: DR.Utils.FormUtils.setValue(fld, frm, value)
	 * @param {Object} fld
	 * @param {Object} frm
	 * @param {String} value
	 * @return VOID
	 *****************************************************************************/
    $.extend(DR.Utils.FormUtils, {
		setValue: function (fld, frm, value)
		{
			var formObj = (typeof frm == 'object') ?  frm : document.forms[frm];
			var fldObj = (typeof fld == 'object') ?  fld: formObj.elements[fld];
			var i=0;
			if(fldObj) {
				var type = (fldObj.type) ? fldObj.type: fldObj[0].type;
				switch (type) {
					case "text":
					case "textarea":
					case "password":
						fldObj.value = value;
						break;
					case "checkbox":
						fldObj.checked = (value) ? true : false;
						break;
					case "radio":
						for (i = 0; i < fldObj.length; i++) {
							if (fldObj[i].value == value) {
								fldObj[i].checked = true;
								break;
							}
						}
						break;
					case "select-one":
					case "select-multiple":
						if (typeof value == 'object') {
							for (var j = 0; j < value.length; j++) {
								for(i = 0; i < fldObj.options.length; i++) {
									if(fldObj.options[i].value == value[j]) {
										fldObj.options[i].selected = true;
									}
								}
							}
						} else {
							for(i = 0; i < fldObj.options.length; i++) {
								if(fldObj.options[i].value == value || fldObj.options[i].text == value) {
									fldObj.options[i].selected = true;
									break;
								}
							}
						}
						break;
					default:
						break;
				}
			}
		}
	});
})(jQuery);
;(function($){
    $.extend(DR.Utils.FormUtils, {
		submit: function (formName) {
			if(formName) {
				var formObj = (typeof formName == "object") ? formName : document.forms[formName];
				formObj.submit();
			}
		}
	});
})(jQuery);
;(function($){
    $.extend(DR.Utils.FormUtils, {
		submitActionForm: function (obj, evt) {
			var actionName = obj.id || obj.name;
			var actionObj = obj.form.action;
			if (typeof actionObj == 'object') {
				actionObj.value = actionName;
			}
			if(obj.className.indexOf('cancel') > -1){
				//Since the user is canceling, we turn off validation of the form
				if(typeof obj.form.enableValidation == 'function'){
					obj.form.enableValidation(false);
				}
			}
			obj.form.submit();
			if (evt) {
				evt.returnValue = false;
				evt.cancelBubble = true;
			}
			return false;
		}
	});
})(jQuery);
	/******************************************************************************
	* Generic toggle class for hiding and showing elements and setting the disable property<br />
	* Example: <code>DR.Utils.Toggle.visibilityFromCheckbox("enableCouponUsage", "couponUsageLimit");</code>
	* @constructor
	* @author bziegler
	*/
	
	DR.Utils.Toggle = function(){};
	
	/******************************************************************************
	 * Disable elements based on a single checkbox.<br />
	 * Example: <code>DR.Utils.Toggle.disabledFromCheckbox(trigger, toDisable);</code>
	 * @param {Object/String} trigger Object or id string of the checkbox that the click event occurred on.
	 * @param {String} toDisable The id string of the element that will have its disabled state set. Can be comma-delimited for multiple elements.
	 * @return VOID
	 */
	DR.Utils.Toggle.disabledFromCheckbox = function(trigger, toDisable) {
		var triggerObj = (typeof trigger == "object") ? trigger : document.getElementById(trigger);
		if (typeof toDisable == "string") {
			toDisable = toDisable.stripSpaces().split(',');
			for (var i = 0; i < toDisable.length; i++) {
				DR.Utils.Toggle.setDisabled(toDisable[i], !DR.Utils.Toggle.isChecked(trigger));
			}
		}
	};
	
	/******************************************************************************
	 * Disable elements based on a single radio button.
	 * Example: <code>DR.Utils.Toggle.disabledFromRadioButton(trigger, toDisable);</code>
	 * @param {Object/String} trigger Object or id string of the checkbox that the click event occurred on.
	 * @param {String} toDisable The id string of the element that will have its disabled state set. Can be comma-delimited for multiple elements.
	 * @return VOID
	 */
	DR.Utils.Toggle.disabledFromRadioButton = function(trigger, toDisable) {
		var triggerObj = (typeof trigger == "object") ? trigger : document.getElementById(trigger);
		//Invert since true means disabled. Assumption here is that most radio buttons will have the value of true when its counterparts should be enabled
		var doDisable = (triggerObj.value == "true" || triggerObj.value == true) ? false : true;
		if (typeof toDisable == "string") {
			toDisable = toDisable.stripSpaces().split(',');
			for (var i = 0; i < toDisable.length; i++) {
				DR.Utils.Toggle.setDisabled(toDisable[i], doDisable);
			}
		}
	};
	
	/******************************************************************************
	 * Returns true if the checked box is selected.<br />
	 * Example: <code>DR.Utils.Toggle.isChecked(trigger);</code>
	 * @param {Object/String} trigger Object or id string of the checkbox that the click event occurred on.
	 * @return Boolean true if the checkbox is checked, false if it is unchecked or null.
	 */
	DR.Utils.Toggle.isChecked = function (trigger) {
		var triggerObj = (typeof trigger == "object") ? trigger : document.getElementById(trigger);
		if (triggerObj) {
			return (triggerObj.checked) ? true : false;
		} else {
			return false;
		}
	};
	
	/******************************************************************************
	 * Set an element's disabled state to the boolean value passed in.<br /> 
	 * Example: <code>DR.Utils.Toggle.setDisabled(trigger, isDisabled);</code>
	 * @param {Object/String} trigger Object or id string of the element to have its disabled property set.
	 * @param {Boolean} isDisabled Boolean representing the disabled state.
	 * @return VOID
	 */
	DR.Utils.Toggle.setDisabled = function (trigger, isDisabled) {
		var triggerObj = (typeof trigger == "object") ? trigger : document.getElementById(trigger);
		if (triggerObj) {
			triggerObj.disabled = (isDisabled == "true" || isDisabled == true) ? true : false;
		}
	};
	
	/******************************************************************************
	 * Set an element's display state to the boolean value passed in.<br />
	 * Example: <code>DR.Utils.Toggle.setVisibility(trigger, isVisible)</code>
	 * @param trigger = Object or id string of the element to have its display property set.
	 * @param isVisible = Boolean representing the visibility.
	 * @return VOID
	 */
	DR.Utils.Toggle.setVisibility = function (trigger, isVisible) {
		var triggerObj = (typeof trigger == "object") ? trigger : document.getElementById(trigger);
		if (triggerObj) {
			if(isVisible){
				$(triggerObj).fadeIn("normal", function(){
					$(this).show();
				});
			}else{
				$(triggerObj).hide();
			}
		}
	};
	
	
	/******************************************************************************
	 * Enable a tab and disable the rest of the tabs in a group<br />
	 * Example: <code>DR.Utils.Toggle.enableTab(trigger)</code><br />
	 * Assumptions:<br />
	 * 1. Entire tab section is enclosed in a tabGroup div:
	 * <code>
	 *   <div class="tabGroup">
	 *      <!-- tabs and tab content -->
	 *   </div>
	 * </code>
	 * 1. Tabs are in a tabs div:<br />
	 * <code>
	 *    <div class="tabs">
	 *      <ul>
	 *        <li id="colorsFontsTab" class="selected"><span onclick="DR.Utils.Toggle.enableTab(this);"><fmt:message key="storeBuilder.contentManager.editStyleVersion.colorsAndFontsTab.text" /></span></li>
	 *        <li id="graphicsTab"><span onclick="DR.Utils.Toggle.enableTab(this);"><fmt:message key="storeBuilder.contentManager.editStyleVersion.buttonsTab.text" /></span></li>
	 *        <li id="htmlTab"><span onclick="DR.Utils.Toggle.enableTab(this);"><fmt:message key="storeBuilder.contentManager.editStyleVersion.htmlTab.text" /></span></li>
	 *        <li id="cssTab"><span onclick="DR.Utils.Toggle.enableTab(this);"><fmt:message key="storeBuilder.contentManager.editStyleVersion.advancedCssTab.text" /></span></li>
	 *     </ul>
	 *    </div>
	 * </code>
	 * 2. Tab content is in a tabContent div:
	 * <code>
	 *  <div id="tabContent_colorsFontsTab">
	 *    <!-- content -->
	 *  </div>
	 *  <div id="tabContent_graphicsTab">
	 *    <!-- content -->
	 *  </div>
	 *  <div id="tabContent_htmlTab">
	 *    <!-- content -->
	 *  </div>
	 *  <div id="tabContent_cssTab">
	 *    <!-- content -->
	 *  </div>
	 * </code>
	 * @param {Object|String} trigger Object or id string of the Span element which is a child of the <li> tab
	 * @return VOID
	 */
	DR.Utils.Toggle.enableTab = function(trigger) {
		var triggerObj = (typeof trigger == "object") ? trigger : document.getElementById(trigger);
		triggerObj = triggerObj.parentNode;
		// loop through all li's and turn them off
		var tabs = (triggerObj.parentNode.parentNode).getElementsByTagName("LI");
		for (var i=0; i < tabs.length; i++) {
			$(tabs[i]).removeClass("selected");
			DR.Utils.Toggle.setVisibility("tabContent_" + tabs[i].id, false);
		}
		$(triggerObj).addClass("selected");
		DR.Utils.Toggle.setVisibility("tabContent_" + triggerObj.id, true);
	};
	
	/******************************************************************************
	 * Show and hide elements based on a link.<br />
	 * Example: <code>DR.Utils.Toggle.visibilityFromLink(trigger, toShow, toHide)</code>
	 * @param trigger = Object or id string of the element that the click event occured on.
	 * @param toShow = The id string of the element that will be shown when link's click event occurs. Can be comma-delimited for multiple elements.
	 * @param toHide = The id string of the element that will be hidden when link's click event occurs. Can be comma-delimited for multiple elements.
	 * @return VOID
	 */
	// @TODO Add CSS classes to CSS file.  This function has NOT been used yet.
	DR.Utils.Toggle.visibilityFromLink = function(trigger, toShow, toHide) {
		var triggerObj = (typeof trigger == "object") ? trigger : document.getElementById(trigger);
		// if it's currently collapsed, it needs to be set to visible
		var isVisible = (triggerObj.className == "collapsedImage") ? true : false;
		// new class name is opposite of current one
		var newClassName = (triggerObj.className == "collapsedImage") ? "expandedImage" : "collapsedImage";
		if (typeof toShow == "string") {
			toShow = toShow.stripSpaces().split(',');
			for (var i = 0; i < toShow.length; i++) {
				DR.Utils.Toggle.setVisibility(toShow[i], isVisible);
			}
		}
		if (typeof toHide == "string") {
			toHide = toHide.stripSpaces().split(',');
			for (var j = 0; j < toHide.length; j++) {
				DR.Utils.Toggle.setVisibility(toHide[j], !isVisible);
			}
		}
		
		$(triggerObj).removeClass(triggerObj.className).addClass(newClassName);
	};
	
	/******************************************************************************
	 * Show and hide elements based on a single checkbox.<br />
	 * Example: <code>DR.Utils.Toggle.visibilityFromCheckbox(trigger, toShow, toHide)</code>
	 * @param trigger = Object or id string of the checkbox that the click event occurred on.
	 * @param toShow = The id string of the element that will be shown when checkbox's click event occurs. Can be comma-delimited for multiple elements.
	 * @param toHide = The id string of the element that will be hidden when checkbox's click event occurs. Can be comma-delimited for multiple elements. 
	 * @return VOID
	 */
	DR.Utils.Toggle.visibilityFromCheckbox = function(trigger, toShow, toHide) {
		var triggerObj = (typeof trigger == "object") ? trigger : document.getElementById(trigger);
		var isVisible = (triggerObj.checked) ? true : false;
		if (typeof toShow == "string") {
			toShow = toShow.stripSpaces().split(',');
			for (var i = 0; i < toShow.length; i++) {
				DR.Utils.Toggle.setVisibility(toShow[i], isVisible);
			}
		}
		if (typeof toHide == "string") {
			toHide = toHide.stripSpaces().split(',');
			for (var j = 0; j < toHide.length; j++) {
				DR.Utils.Toggle.setVisibility(toHide[j], !isVisible);
			}
		}
	};
	
	/******************************************************************************
	 * Show and hide elements based on a single radio button.<br />
	 * Example: <code>DR.Utils.Toggle.visibilityFromRadioButton(trigger, toShow, toHide)</code>
	 * @param trigger = Object or id string of the radio button that the click event occurred on.
	 * @param toShow = The id string of the element that will be shown when radio button's click event occurs. Can be comma-delimited for multiple elements.
	 * @param toHide = The id string of the element that will be hidden when radio button's click event occurs. Can be comma-delimited for multiple elements. 
	 * @return VOID
	 */
	DR.Utils.Toggle.visibilityFromRadioButton = function(trigger, toShow, toHide) {
		var triggerObj = (typeof trigger == "object") ? trigger : document.getElementById(trigger);
		if (typeof toShow == "string") {
			toShow = toShow.stripSpaces().split(',');
			for (var i = 0; i < toShow.length; i++) {
				DR.Utils.Toggle.setVisibility(toShow[i], true);
			}
		}
		if (typeof toHide == "string") {
			toHide = toHide.stripSpaces().split(',');
			for (var j = 0; j < toHide.length; j++) {
				DR.Utils.Toggle.setVisibility(toHide[j], false);
			}
		}
	};

	/******************************************************************************
	*  Hides and shows the faux tree object<br />
	*  Example: <code>childTable()</code>
	*  @param {CellObject} cellObj 
	*  @param {String} rowID 
	*  @return VOID
	*****************************************************************************/
	// @TO-DO refactor this into the DR.Widgets.ListControls/FauxTree  class
	DR.Utils.Toggle.childTable = function(cellObj, rowID)
	{
		var childRowObj = document.getElementById(rowID);
		var isExpanded = (childRowObj.style.display != "none");
		if(isExpanded) {
			childRowObj.style.display = "none";
			cellObj.className = "first collapsed";
		} else {
			childRowObj.style.display = "";
			cellObj.className = "first expanded";
		}
	};
	
	/******************************************************************************
	*  Function used on product list page for showing the faux tree table when
	*  clicking on the checkbox
	*  Example: <code>childTableFromCheckbox()</code>
	*  @param {CheckboxObject} check Checkbox object that the click event occurred on
	*  @param {CellObject} cellObj
	*  @param {String} rowID id of row you'd like to expand/collapse
	*  @return VOID
	*****************************************************************************/
	// @TO-DO refactor this into the ListControls/FauxTree class
	DR.Utils.Toggle.childTableFromCheckbox = function(check, cellObj, rowID)
	{    
	    var childRowObj = document.getElementById(rowID);
		var isExpanded = (childRowObj.style.display != "none");
			
		if(!check.checked) {
			childRowObj.style.display = "none";
			cellObj.className = "first collapsed";
		} else {
			childRowObj.style.display = "";
			cellObj.className = "first expanded";
		}
	};


	/*-----------------------------------------------------------------------------------------------
	 * The AjaxPanel is a region on the page used to display forms that are loaded
	 * and submitted using ajax.
	 * 
	 * Currently the AjaxPanel is only meant to have a single form in the ajax resonse.
	 * ---------------------------------------------------------------------------------------------*/		
	 	
	DR.Widgets.AjaxPanel = function(panelId,isModal){
		this.settingName = "";
		this.newSettingName = "";
		this.panelId = panelId;
		this.content = (typeof panelId === 'string') ? $('#'+panelId)[0] : panelId;
		this.currentForm = null;
		this.loaded=false;
		this.loading = false;
		this.saving = false;
		this.url = "";
		this.queryStringData = "";
		this.errors=[];
		this.showSuccessMessage=true;
		this.saveCallback=null;
		this.loadCallback=null;
		this.checkChangeCallback=null;
		this.isModal = (isModal) ? true : false;
	}
	
	DR.Widgets.AjaxPanel.prototype = {
		get: function(url,queryStringData){
			
			// TODO - check if save is occurring
			
			this.markLoading();
			this.url = url;
			if (queryStringData) {
				this.queryStringData = queryStringData;
				url = $.dr.utils.appendParam(url, queryStringData);
			}
			var oSelf = this;
			$.ajax({
					url: $.dr.utils.appendParam(url, 'ajaxTime='+(new Date()).getTime()),
					type: "GET",
					dataType: "html",
					success: function(response){
						if($.browser.msie){
							// IE has a bug where if the first element is a <script> tag, there must be a block element before
							// or that script will not be added to the DOM
							response = response.replace('<script','<br style="display:none"/> <script');
						}

						oSelf.content.innerHTML=response;
						oSelf.loaded = true;
						oSelf.loading = false;
						oSelf.prepare();
						oSelf.runScripts();
						
						if(typeof oSelf.loadCallback == 'function'){
							oSelf.loadCallback(response);
						}
					},
					error: function(xhr){

						if(xhr.status=='500'){
							// Internal server error
							$(oSelf.content).html(xhr.responseText);
							oSelf.loaded = true;
							oSelf.loading = false;
							oSelf.saving = false;
							oSelf.prepare();
							oSelf.runScripts();
						}else if(xhr.status=='403'){
							// Session timeout
							window.location=$.dr.LOGIN_URL;
						}

					}
			});
			if(typeof oSelf.beforeLoadCallback == 'function'){
				oSelf.beforeLoadCallback();
			}	
			this.loading = true;
			
		},
		
		refresh: function(){
			this.get(this.url,this.queryStringData);
		},
		
		prepare: function(){
			if(this.currentForm!==null){
				var _form = this.currentForm;
				$(_form).dr.form.destroy();
			}

			$.dr.triggerUnobtrusiveEvents(this.content);
			
			var forms = $("form",this.content);
			if(forms.length==0 && this.currentForm!==null){
				forms.dr.form.destroy();
				this.currentForm = null;
			}else{

				for (var i=0; i < forms.length; i++) {
					var _form = forms[i];
					this.currentForm = _form;
					this.addHijackForm();
				}
				
			}


		},

		addHijackForm: function(){

			var oSelf=this;

			var existingOnsubmit = this.currentForm.onsubmit;
			
			this.currentForm.onsubmit = function(allowHijack){
				var okToHijack = true;
				if ($.isFunction(existingOnsubmit)) {
					okToHijack = (existingOnsubmit.call(this) !== false);
				}
				if (okToHijack && (allowHijack !== false)) {
					oSelf.hijackForm();
					okToHijack = false;
				}
				return okToHijack;
			};
		},
		
		/*
		 * After the html has been injected via innerHTML, we eval any scripts present in the ajax response
		 */
		runScripts: function()
		{
			var div = this.content;
			var scripts = $('script',div);
			this.errors = [];
			var safariScripts=[];
			var isSafari = (navigator.userAgent.indexOf('Safari')>-1 && navigator.userAgent.indexOf('Chrome')==-1) ? true : false; 
			for (var i=0; i < scripts.length; i++) {
				var script = scripts[i];
				var h = script.innerHTML;
				if(h.indexOf('document.write')==-1){
					if (script.src){
						var head = document.getElementsByTagName("head")[0];
						var newScript = document.createElement("script");
							newScript.setAttribute("type", "text/javascript");
							newScript.setAttribute("src", script.src);  
							head.appendChild(newScript);
				    }
				    else if (h){
						if (isSafari) {
							// eval.call does not work in Safari, so we have to use window.setTimeout(h,0)
							safariScripts.push(h);
						}
						else {
							try {
								if (window.execScript) {
									//  Internet Explorer only function
									window.execScript(h);
								}
								else {
									eval.call(window, h);
								}
							}
							catch (e) {
								this.errors[this.errors.length] = e;
							}
							this.displayScriptErrors();
						}
				   	}
				}
			}
			if (isSafari) {
				var s = [];
				for (var i = 0; i < safariScripts.length; i++) {
					// put a try/catch around each script block
					s.push('try{'+safariScripts[i]+'}catch(e){'+this.panelId+'.errors.push(e)};')
				}
				var f = s.join('')+this.panelId + ".displayScriptErrors()";
				window.setTimeout(f, 0);
			}
		},
		
		displayScriptErrors: function(){
			if(this.errors.length>0 && $.dr.IS_INTERNAL_USER){
				DR.Utils.alert('There were javascript errors when loading '+this.settingName+':<br/><br/>'+this.errors.join("<br/><br/>"));
			}
		},
		
		hijackForm: function(callBack){
			
			var url = $.dr.utils.appendParam(this.url, this.queryStringData, 'ajaxTime='+(new Date()).getTime());
			var formData = $(this.currentForm).serialize();
		
			var oSelf = this;
			var hijackFailureCallback = function(o){oSelf.hijackFailureCallback(o);};
			var hijackCallback;
			
			this.loaded=false;
				
			// Standard forms are submitted via Ajax
			
			hijackCallback = function(data,o){
				oSelf.hijackSaveCallback(data,o);
				if(typeof callBack == 'function'){
					callBack();
				}
			};

			var _form = this.currentForm;
			// there seems to be a problem here, the reIndex function does not seem to run
			$(_form).dr.form.reIndex();
			
			$.ajax({
				type:"POST",
				url:url,
				success: hijackCallback,
				error: hijackFailureCallback,
				data:formData
			});
			
			this.saving=true;
			this.markSaving();

		},

		hijackSaveCallback: function(data,o){

				if(data !== undefined)
				{
					this.saving=false;
					this.loaded=true;
					if(typeof $.dr.processingDialog == 'object'){
						$.dr.processingDialog.hide();
					}
					if(this.showSuccessMessage){
						var msg = this.SAVE_SUCCESSFUL.replace('{0}',this.settingName);
						DR.Utils.success(msg);	
					}

					if(typeof this.checkChangeCallback == 'function'){
						this.checkChangeCallback();
					}else{
						var response = data;

						if($.browser.msie){
							// IE has a bug where if the first element is a <script> tag, there must be a block element before
							// or that script will not be added to the DOM
							response = response.replace('<script','<br style="display:none"/> <script');
						}
						this.content.innerHTML=response;
						this.prepare();
						this.runScripts();
						if(typeof this.saveCallback == 'function'){
							this.saveCallback();
						}
					}
				}
			
		},
		
		hijackFailureCallback: function(o){
			if (o.status=='403')
			{
				window.location=$.dr.LOGIN_URL;
			}else if (o.status=='500')
			{
				this.content.innerHTML = o.responseText;
			}
		},
		
		markLoading: function(){
			if(!this.saving){
				var timer = (!this.loaded) ? 0 : 250;
				this.loaded=false;
				var oSelf = this;
				var func = function(){oSelf.markLoadingST();};
				window.setTimeout(func,timer);
				
			}
		},
	
		markLoadingST: function(){
			if(!this.loaded){
				var msg = $.dr.strings.LOADING.replace('...', " " + this.settingName+"...");
				var h = '<div class="loadingTabContent" ><div><span>' +msg + '</span><div></div>';
				this.content.innerHTML = h;
			}
		},
		
		markSaving: function(){
			if(!this.loading){
				var timer = 150;
				this.saving=true;
				var oSelf = this;
				var func = function(){oSelf.markSavingST();};
				window.setTimeout(func,timer);
				
			}
		},
	
		markSavingST: function(){
			if(!this.loaded){
				if(this.isModal){
					var msg = this.SAVING_CHANGES.replace('{0}', " " + this.settingName+"...");
					var h = '<div class="loadingTabContent" ><div><span>' +msg + '</span><div></div>';
					this.content.innerHTML = h;
				}else{
					if(typeof $.dr.processingDialog == 'object'){
						$.dr.processingDialog.show();
					}
				}
			}
		},
		
		checkChanges: function(callback)
		{
			// Start out assuming no changes
			
			// Have we loaded anything yet?
			if(this.currentForm==null)
			{
				callback();
				return false;	
			}
			
			var formChanges = this.checkFormChanges();

			// If current tab or child tab has changes, prompt the user to save
			if(formChanges)
			{
				if(this.currentForm!==undefined)
				{
					var _onSubmit = this.currentForm.onsubmit;
					if(typeof _onSubmit == 'function'){
						var check = _onSubmit(false);
						if(check === false)
						{
							return false;
						}
					}
				}
				
				// Store off reference to callback, it will run after user is shown the warning
				this.checkChangeCallback = callback;
				
				var oSelf = this;
				var confirmCallback = function(saveChanges){
					oSelf.checkChangesConfirmCallback(saveChanges);
				};
				
				var q;
				if(this.settingName==this.newSettingName){
					q = this.UNSAVED_CHANGES_CONFIRM_QUESTION;
					q = q.replace('{0}',this.settingName);
				}else{
					q = this.UNSAVED_CHANGES_CONFIRM_QUESTION_LOAD;
					q = q.replace('{0}',this.settingName);
					q = q.replace('{1}',this.newSettingName);
				}

				DR.Utils.warning(q,confirmCallback,this.UNSAVED_CHANGES_CONFIRM_TITLE);
				return true;
			}else{
				
				// No changes, so run the callback
				callback();
				return false;
			}
			

		},	
				
		checkFormChanges: function()
		{
			var _form = this.currentForm;
		
			if(!_form)
			{
				return false;
			}

			if($(_form).dr.form.get().checkChanges)
			{
				if($(_form).dr.form.checkForChanges())
				{
					return true;
				}
			}
			return false;
		},
			  
		checkChangesConfirmCallback: function(saveChanges)
		{

			var validationError = false;

			if(saveChanges)
			{	
				var _form = this.currentForm;
				if($(_form).dr.form.validate()){
					this.hijackForm();
					return;
				}else{
					validationError=true;
				}	
			}
			
			if(!validationError){
				this.checkChangeCallback();
			}
		},
		
		getCurrentForm: function(){
			var _form = this.currentForm;
			return _form;
		}
	
	}

	DR.Widgets.AjaxPanel.prototype.SAVING_CHANGES = "\u66F4\u6539\u4FDD\u5B58\u5230{0}";
	DR.Widgets.AjaxPanel.prototype.SAVE_SUCCESSFUL = "{0}\u7684\u66F4\u6539\u5DF2\u6210\u529F\u4FDD\u5B58\u3002";
	DR.Widgets.AjaxPanel.prototype.UNSAVED_CHANGES_CONFIRM_TITLE = "\u66F4\u6539\u672A\u4FDD\u5B58";
	DR.Widgets.AjaxPanel.prototype.UNSAVED_CHANGES_CONFIRM_QUESTION = "\u6267\u884C\u8BF7\u6C42\u7684\u64CD\u4F5C\u524D\uFF0C\u662F\u5426\u5C06\u66F4\u6539\u4FDD\u5B58\u5230{0}\uFF1F";
	DR.Widgets.AjaxPanel.prototype.UNSAVED_CHANGES_CONFIRM_QUESTION_LOAD = "\u52A0\u8F7D{1}\u524D\u662F\u5426\u5C06\u66F4\u6539\u4FDD\u5B58\u5230{0}\uFF1F";
	
	
	



//Move into string utils
    String.THOUSANDS_SEPARATOR = ",";
    String.prototype.formatNumber = function() {
    	return this.replace(/\d{1,3}(?=(\d{3})+(?!\d))/g, "$&" + String.THOUSANDS_SEPARATOR); 
    }
    
    Date.prototype.dr_getDOY = function() {
		//console.log("this", this);
		var onejan = new Date(this.getFullYear(),0,1);
		return Math.ceil((this - onejan) / 86400000);
	} 

jQuery.dr = window.jQuery.dr || {};

	
	$.dr.baseChart = {
		//Wrapper to init different chart types since "amChartInited" is shared between chart types, I think
		/******************************************************************************
	 * initChart is a generic wrapper that uses the chart_id to find a DOM element
	 * with that id and look at the class on that element. Base on the class attribute
	 * a chart object will be constructed. This is used since amChartInited is used
	 * by different chart types. This is only called by the amChartInited method.
	 * 
	 * Example: <code>$.dr.baseChart.initChart(chart_id); </code>
	 * @param {String} chart_id is the id of the chart
	 * @return VOID
	 *****************************************************************************/
		initChart:function(chart_id) {
		var obj = $("#" + chart_id);
		
		if (obj.hasClass("stockChartContainer")) {
			if(!(window[chart_id] instanceof  $.dr.stockChart)){
            	try {
                  window[chart_id] = new $.dr.stockChart(chart_id);
                  window[chart_id].initChart(chart_id + "_flashObjectId");
                } catch (e) {
                 	//console.error(e);
                 }
            }
		} else {
			try {
				window[chart_id] = new Object();
			} catch(e) {
				
				
			}
			//Add other chart types in thier own if statement here
		}
	}
}

/******************************************************************************
 * amChartInited This function is called by the flash chart when the it is 
 * fully loaded and initialized. This function in turn then calls 
 * $.dr.baseChart.initChart(chart_id). The initChart function will bind the
 * flash chart to a javascript object and initialize the new object with data
 * from the chart if it is required. 
 * 
 * Example: <code>amChartInited(chart_id)</code>
 * @param {String} chart_id is the id of the chart
 * @return VOID
 *****************************************************************************/
amChartInited = function(chart_id){
	$.dr.baseChart.initChart(chart_id);          
};  

/******************************************************************************
 * amProcessCompleted This function is called by the flash chart when it has
 * finished completing running a javascript method that was exposed for this
 * flash chart. Examples are "setSettings", "setParam", "appendData", "setData"
 * etc. The passed in process name is the name of the JavaScript AMCharts 
 * method that was executed. This function invokes a corresponding callback 
 * method on the JavaScript chart object called window[chart_id].processCompleteCallback. 
 * 
 * Example: <code>amProcessCompleted(chart_id, process_name)</code>
 * @param {String} chart_id is the id of the chart
 * @param {String} Name of the function/process that just completed
 * @return VOID
 *****************************************************************************/
amProcessCompleted = function(chart_id, process_name) {
 	//console.log("processCompleted", process_name);
 	if (window[chart_id]) {
		window[chart_id].processCompletedCallback(process_name);  
	}
};  
 
/******************************************************************************
 * amReturnData This function is the callback method invoked by the flash chart 
 * by a getData() call into it. The last loaded data set will be returned. If a 
 * data set is being compared the data for the compared data set will be returned.
 * If multiple data sets are being compared the last data set to be loaded will be
 * returned. This is only called by the flash chart. This function invokes a 
 * corresponding callback method on the JavaScript chart object called 
 * window[chart_id].returnDataCallback. 
 * 
 * Example: <code>amReturnData(chart_id, data)</code>
 * @param {String} chart_id is the id of the chart
 * @param {String} CSV delimited string of data
 * @return VOID
 *****************************************************************************/
window.amReturnData = function(chart_id, data){
	if (window[chart_id]) {
		//@TODO figure out if escaping is needed
		window[chart_id].returnDataCallback(unescape(data));  
	}
};  

/******************************************************************************
 * amReturnSettings This function is the callback method invoked by the flash chart 
 * by a getSettings() call into it. The entire settings xml will be returned. This
 * function invokes a corresponding callback method on the JavaScript object called
 * window[chart_id].returnSettingsCallback. This is only called by the flash chart.
 *
 * Example: <code>amReturnSettings(chart_id, settings)</code>
 * @param {String} chart_id is the id of the chart
 * @param {String} CSV delimited string of data
 * @return VOID
 *****************************************************************************/ 
window.amReturnSettings = function(chart_id, settings) {	
	if (window[chart_id]) {
    	//console.log("amReturnSettings "+unescape(settings));
		window[chart_id].returnSettingsCallback(settings);
	}
};


/******************************************************************************
 * amReturnParam function is the callback method invoked by the flash chart 
 * by a getParam() call into it. The value for the requested parameter will be 
 * returned. This unction invokes a corresponding callback method on the JavaScript 
 * chart object called window[chart_id].returnParamCallback. This is only called
 * by the flash chart.
 * 
 * Example: <code>amReturnParam(chart_id, param)</code>
 * @param {String} chart_id is the id of the chart
 * @param {String} CSV delimited string of data
 * @return VOID
 *****************************************************************************/ 
window.amReturnParam = function(chart_id, param){
	if (window[chart_id]) {
		window[chart_id].returnParamCallback(param);
	}          
};	

/******************************************************************************
 * This is called when an errors occurs. Examples are no data or file not found.
 * This is only called by the flash chart. This function invokes a corresponding 
 * callback method on the JavaScript chart object called window[chart_id].errorCallback. 
 *
 * Example: <code>amRolledOver(chart_id, message)</code>
 * @param {String} message = Text of the error that occurred.
 * @return  VOID
 *****************************************************************************/
window.amError = function(chart_id, message){
	if (window[chart_id]) {
		window[chart_id].errorCallback(message);
	}
}; 

/******************************************************************************
 * This is called when a date marker on the graph is clicked on. This is only 
 * called by the flash chart. This function invokes a corresponding callback 
 * method on the JavaScript chart object called window[chart_id].rolledOverCallback. 
 *
 * Example: <code>amRolledOver(chart_id, date, period)</code>
 * @param {String} chart_id is the id of the chart
 * @param {Date String} date = date string formatted to date pattern the data uses
 * @param {String} period = DD, WW, MM are passed back as the period the the marker
 * 					is for. 
 * @return  VOID
 *****************************************************************************/
window.amRolledOver = function(chart_id, date, period){
	if (window[chart_id]) {
  	 	window[chart_id].rolledOverCallback(date, period);
  	 }
};

/******************************************************************************
 * This is called when a date marker on the graph is clicked on. The graph will 
 * zoom into the date period that was clicked on. This is only called by the
 * flash chart. This function invokes a corresponding callback method on the 
 * JavaScript chart object called window[chart_id].clickedOnCallback.
 *
 * Example: <code>amClickedOn(chart_id, date, period)</code>
 * @param {String} chart_id is the id of the chart
 * @param {Date String} date = date string formatted to date pattern the data uses
 * @param {String} period = DD, WW, MM are passed back as the period the the marker
 * 					is for. 
 * @return  VOID
 *****************************************************************************/
window.amClickedOn = function(chart_id, date, period){
	//console.log("clickedOn", date, period);
	if (window[chart_id]) {
  	 	window[chart_id].clickedOnCallback(date, period);
  	 }
	};
	
	/******************************************************************************
 * This is called when an event marker on the graph is rolled over. This is only 
 * called by the flash chart. This function invokes a corresponding callback 
 * method on the JavaScript chart object called window[chart_id].rolledOverEventCallback.
 *
 * Example: <code>amRolledOverEvent(chart_id, date, description, id, url)</code>
 * @param {String} chart_id is the id of the chart
 * @param {Date String} date = date string formatted to date pattern the data uses
 * @param {String} description = Value entered in the description node for the event
 * @param {String} id = The value of the eid attribute of the event
 * @param {String} url = The value of the URL node of the event
 * @return  VOID
 *****************************************************************************/          
window.amRolledOverEvent = function(chart_id, date, description, id, url){
  	if (window[chart_id]) {
  	 	window[chart_id].rolledOverEventCallback(date, description, id, url);
  	}
};
  
/******************************************************************************
 * This is called when an event marker on the graph is clicked on. This is only 
 * called by the flash chart. This function invokes a corresponding callback 
 * method on the JavaScript chart object called window[chart_id].clickedOnEventCallback.
 *
 * Example: <code>amClickedOnEvent(chart_id, date, description, id, url)</code>
 * @param {String} chart_id is the id of the chart
 * @param {Date String} date = date string formatted to date pattern the data uses
 * @param {String} description = Value entered in the description node for the event
 * @param {String} id = The value of the eid attribute of the event
 * @param {String} url = The value of the URL node of the event
 * @return  VOID
 *****************************************************************************/             
window.amClickedOnEvent = function(chart_id, date, description, id, url){
	if (window[chart_id]) {
  	 	window[chart_id].clickedOnEventCallback(date, description, id, url);
  	}
};
  
/******************************************************************************
 * amGetZoom is called by the flash chart any time a date is changed on the graph.
 * This can happen multiple ways, dragging the period selector, clicking on a 
 * predefined zoom setting, entering a custom date, or by JavaScript.
 * 
 * Example: <code>amGetZoom(chart_id, from, to)</code>
 * @param {String} chart_id is the id of the chart
 * @param {String} Date that the selected range is from
 * @param {String} Date that the selected range is to
 * @return VOID
 *****************************************************************************/
window.amGetZoom = function(chart_id, from, to){
  	 //console.info("amgetzoom", from, to);
  	 if (window[chart_id]) {
  	 	window[chart_id].getZoomCallback(from, to);
  	 }
};  

/******************************************************************************
 * amReturnImageData is called by the flash chart when the export to image 
 * process is finished and might be used as alternative way to get image data 
 * (instead of posting it to some file)> This is only called by the flash file.
 * 
 * Example: <code>amSliceClick(chart_id, index, title, value, percents, color, description)</code>
 * @param {String} chart_id is the id of the chart
 * @param {String} Date that the selected range is from
 * @param {String} Date that the selected range is to
 * @return VOID
 *****************************************************************************/
window.amReturnImageData = function(chart_id, data){
	   // Not Implemented yet//
};     
 

	/******************************************************************************
 * AMPie ONLY!
 * This function is called when the viewer clicks on the slice. It returns chart_id, 
 * the sequential number of the slice (index), the title, value, percent value, 
 * color and description. This is only called by the flash chart. This function 
 * invokes a corresponding callback method on the JavaScript chart object 
 * called window[chart_id].sliceClickCallback.
 *
 * Example: <code>amSliceClick(chart_id, index, title, value, percents, color, description)</code>
 * @param {String} chart_id is the id of the chart
 * @param {String} index = 
 * @param {String} title = 
 * @param {String} value = 
 * @param {String} percents = 
 * @param {String} color = 
 * @param {String} description =
 * @return  VOID
 *****************************************************************************/ 
window.amSliceClick = function(chart_id, index, title, value, percents, color, description){
	// Not Implemented yet//
}; 

/******************************************************************************
 * AMPie ONLY!
 * This function is called when the viewer hovers on the slice. It returns chart_id, 
 * the sequential number of the slice (index), the title, value, percent value, 
 * color and description. This is only called by the flash chart. This function 
 * invokes a corresponding callback method on the JavaScript chart object 
 * called window[chart_id].sliceOverCallback.
 *
 * Example: <code>amSliceOver(chart_id, index, title, value, percents, color, description)</code>
 * @param {String} chart_id is the id of the chart
 * @param {String} index = 
 * @param {String} title = 
 * @param {String} value = 
 * @param {String} percents = 
 * @param {String} color = 
 * @param {String} description =
 * @return  VOID
 *****************************************************************************/ 
window.amSliceOver = function(chart_id, index, title, value, percents, color, description){
	// Not Implemented yet//
};

/******************************************************************************
 * AMPie ONLY!
 * This function is called when the viewer moves off a slice. This is only called 
 * by the flash chart. This function invokes a corresponding callback method on 
 * the JavaScript chart object called window[chart_id].sliceOutCallback.
 *
 * Example: <code>amSliceOut(chart_id)</code>
 * @param {String} chart_id is the id of the chart
 * @return  VOID
 *****************************************************************************/ 
window.amSliceOut = function(chart_id){
	// Not Implemented yet//
}; 
(function($){   
	/******************************************************************************
	 * Build the xml needed to set the data set to be compared against in the
	 * settings xml file. This is usually called from apply settings if an apply
	 * compare to control was bound. The resulting xml can also be used in a 
	 * setSettings call.  
	 * Example: <code>this.buildCompareToSettingXML(elemObj)</code>
	 * @param {DOM Object} elemObj = DOM element that will be used determine the 
	 * 						values being passed in. 
	 * @return  {XML String}
	 *****************************************************************************/
	var buildCompareToSettingXML = function(elemObj) {
			//console.log("buildCompareToSetting ");
		var did = $(elemObj).val();
		var strBuff = [];
		strBuff.push("<data_sets>");
		strBuff.push("<data_set did='" + did + "'>");
		strBuff.push("<compare_list_box selected='true' /></data_set></data_sets>");
		//console.log(strBuff.toString());
		return strBuff.join("");
	}
		
	/******************************************************************************
	 * Builds the xml needed to set the column of data that a particular chart is 
	 * displaying. Charts are 0 based in the settings file. The first chart node is
	 * 0, the second is 1, etc. If more than one chart is displayed in the flash file
	 * a data-chart attribute must be present on the elemObj that is passed in. If 
	 * data-chart is not found or null "0" will be assumed. This is usually called from 
	 * apply settings if an apply graph source to control was bound. The resulting 
	 * xml can also be used in a setSettings call.  
	 * Example: <code>this.buildGraphSrcColSettingXML(elemObj)</code>
	 * @param {DOM Object} elemObj = DOM element that will be used determine the 
	 * 						values being passed in. 
	 * @return  {XML String}
	 *****************************************************************************/
	var buildGraphSrcColSettingXML =function(elemObj) {
		//@TODO Low Priority FUTURE ENHANCEMENT might need to allow setting the compare source with a differnt column, see amstock doc for more info
		var chartNum = $(elemObj).attr("data-chart");
		var selectId = $(elemObj).attr("id");
		var titleVal = $(":selected", elemObj).text();
		var colName = $(elemObj).val();
		var compareSrc = colName;
		var strBuff = [];
		
		strBuff.push("<charts>");
		strBuff.push("<chart cid='" + ((chartNum != null) ? chartNum : 0) + "'>");
			strBuff.push("<title>" + titleVal + "</title>");
			strBuff.push("<graphs>");
				strBuff.push("<graph gid='0'>");
					strBuff.push("<data_sources>");
						strBuff.push("<close>" + colName + "</close>");
				strBuff.push("</data_sources>");
				strBuff.push("<compare_source>" + compareSrc + "</compare_source>");
				strBuff.push("<legend><date key='false' title='false'><![CDATA[{close}]]></date><period key='false' title='false'> <![CDATA[<b>{close}</b>]]></period></legend>");
			strBuff.push("</graph></graphs></chart></charts>");
			if(chartNum == 0){
				//update scroller to reflect top  graph
				strBuff.push("<scroller><graph_data_source>"+colName+"</graph_data_source></scroller>")	
			}
			//console.log("selectId "+selectId+" colName "+colName);
			DR.USER_DATA.save('sitePulseHomeDetail'+GC.CURRENT_SITE_ID,selectId,colName,'String');
		return strBuff.join("");
	}
	
	/******************************************************************************
	 * Build the xml needed to set the from date range control. The date will 
	 * automatically be formatted into the date format that is needed for the flash
	 * object. Display date format can be different. This is usually called from 
	 * apply settings if an apply from date source to control was bound. The resulting 
	 * xml can also be used in a setSettings call.  
	 * Example: <code>this.buildFromDateSettingXML(elemObj)</code>
	 * @param {DOM Object} elemObj = DOM element that will be used determine the 
	 * 						values being passed in. 
	 * @return  {XML String}
	 *****************************************************************************/
	var buildFromDateSettingXML = function(elemObj, dataDateFmt) {
		var strBuff = [];
		strBuff.push("<period_selector><from>");
		strBuff.push(new $.dr.date($(elemObj).val(), $.dr.date.getDefaultFormat()).toFormattedString(dataDateFmt));
		strBuff.push("</from></period_selector>");
		return strBuff.join("");
	}
	
	/******************************************************************************
	 * Build the xml needed to set the to date range control. The date will 
	 * automatically be formatted into the date format that is needed for the flash
	 * object. Display date format can be different. This is usually called from 
	 * apply settings if an apply from date source to control was bound. The resulting 
	 * xml can also be used in a setSettings call.  
	 * Example: <code>this.buildToDateSettingXML(elemObj)</code>
	 * @param {DOM Object} elemObj = DOM element that will be used determine the 
	 * 						values being passed in. 
	 * @return  {XML String}
	 *****************************************************************************/
	var buildToDateSettingXML = function(elemObj, dataDateFmt) {
		var strBuff = [];
		var tempToDate = new $.dr.date($(elemObj).val(), $.dr.date.getDefaultFormat());
		//To Date is not inclusive. Resulting date displayed in the graph is
		// one less. We need to increment it by 1 to get the proper result. 
		tempToDate.setDate(tempToDate.getDate() + 1);
		strBuff.push("<period_selector><to>");
		strBuff.push(tempToDate.toFormattedString(dataDateFmt));
		strBuff.push("</to></period_selector>");
		return strBuff.join("");
	}
	
    /******************************************************************************
	 * Binds to elements with a class of "changeGraphSrcColumn" or "applyGraphSrcColumn". 
	 * The data in this control will be used to determine which 
	 * graph to change. Elements with the class of "changeGraphSrcColumn" will 
	 * change the graph source column when the onchange event is fired.
	 * Elements with the class of "applyGraphSrcColumn" will be used in conjunction 
	 * with an apply button to change the graph source. 
	 * Example: <code>bindGraphColumnControls(chartObj)</code>
	 * @param chartObj = reference to the calling chart object
	 * @return {Array} = List of DOM elements that were bound with the class of "applyGraphSrcColumn".
	 * @private for use in this file only
	 *****************************************************************************/
    var bindGraphColumnControls = function(chartObj) {
    	var boundControls = [];
    	$(".changeGraphColumn", chartObj.chartContainerObj).change(function(event) {
	    	chartObj.changeGraphSrcColumn(event.target);
	    });
	    
	    $(".applyGraphColumn", chartObj.chartContainerObj).each(function() {
	    	boundControls.push(this);
	    });
	    return boundControls;
    }
    
    /******************************************************************************
	 * Binds a click event to an element with a class of "applySettings" that 
	 * will call setSettings on the flash chart object for any bound setting.
	 * Example: <code>bindApplySettingsControls(chartObj)</code>
	 * @param chartObj = reference to the calling chart object
	 * @return {Array} = List of DOM elements that were bound
	 * @private for use in this file only
	 *****************************************************************************/
    var bindApplyControls = function(chartObj) {
	   //Multiple Applies are ok, could have a top and bottom one
	    var boundControls = [];
	    $(".applySettings", chartObj.chartContainerObj).each(function() {
	    	boundControls.push(this);
	    	$(this).click(function(event) {
		    	//console.log("in bind apply controls");
	    		chartObj.applySettings(event.target);
	    	});
	    });
	    return boundControls;
    }
    
     /******************************************************************************
	 * Binds to elements with a class of "changeCompareTo" or 
	 * "applyCompareTo". The data in this control will be used to determine which 
	 * dataset to compare to. Elements with the class of "changeCompareTo" will 
	 * change the compare src on the graph when the onchange event is fired on 
	 * the bound element. Elements with the class of "applyCompareTo" will be used 
	 * in conjunction with an apply button to change the graph source. 
	 * Example: <code>bindCompareToControls(chartObj)</code>
	 * @param chartObj = reference to the calling chart object
	 * @return {DOM Object} = DOM element that was bound with the class of "applyCompareTo".
	 * @private for use in this file only
	 *****************************************************************************/
    var bindCompareToControls = function(chartObj) {
    	var boundControl = null;
    	$(".changeCompareTo:first", chartObj.chartContainerObj).change(function(event) {
	    	chartObj.changeCompareTo(event.target);
	    });
	    
	    $(".applyCompareTo:first", chartObj.chartContainerObj).each(function() {
	    	boundControl = this;
	    });
	    return boundControl;
	}
    
    var bindSetDataControl = function(chartObj){
    	$("select.changeData")
    	.change(function() {
    		chartObj.changeSelectDataSet($(this).val());	
    	})
    	.keyup(function() {
    		chartObj.changeSelectDataSet($(this).val());	
    	});
    }
	
	/******************************************************************************
	 * Binds an input element external to the flash control that represents the 
	 * range start. If the control is not found null is returned. It is not required
	 * to have the date control external to the flash file. By having external date
	 * control the date can be formatted differently than the file file uses and
	 * could be bound to a datePicker control for more robust control functionality.
	 * Example: <code>bindRangeFromControls(context)</code>
	 * @param context = JQuery Object or DOM Object reference to scope binding to
	 * @return {DOM Object} Bound start date field
	 * @private for use in this file only
	 *****************************************************************************/
    var bindRangeFromControls = function(context) {
    	//@TODO low priority - look into hooking onchange event here as well, onchange call would need to know the to date somehow
    	var boundControl = null;
    	$(".applyRangeStart:first", context).each(function() {
	    	boundControl = this;
	    });
    	return boundControl;
    }
    
    /******************************************************************************
	 * Binds an input element external to the flash control that represents the 
	 * range end. If the control is not found null is returned. It is not required
	 * to have the date control external to the flash file. By having external date
	 * control the date can be formatted differently than the file file uses and
	 * could be bound to a datePicker control for more robust control functionality.
	 * Example: <code>bindRangeToControls(context)</code>
	 * @param context = JQuery Object or DOM Object reference to scope binding to
	 * @return {DOM Object} Bound end date field
	 * @private for use in this file only
	 *****************************************************************************/
    var bindRangeToControls = function(context) {
    	//@TODO low priority - look into hooking onchange event here as well, onchange call would need to know the from date somehow
    	var boundControl = null;
    	$(".applyRangeEnd:first", context).each(function() {
	    	boundControl = this;
	    });
    	return boundControl;
    }
    
	/******************************************************************************
	 * Binds elements with a class of "dynamicHighlight". The must be inside of the
	 * containing element referenced by the context argument. 
	 *
	 * Dynamic Highlights are used to calculate data as the selected date range 
	 * changes in the flash chart. Data is calculated to the required formula
	 * attribute. This method constructs a dynamicHighlight object that is contained 
	 * inside of the this.dynamicHighlights collection. The object is populated 
	 * from attributes on the element that has the class of "dynamicHighlight". Valid Attributes:
	 	<br />data-formula (Required) = Data columns can be referenced by name used in settings.xml
	 	 for the stockChart flash object or by column position. 
	 	 Example1:sum(1) Example2:avg('colName') Example3:sum(1)/avg('colName')
	 	<br />data-precision (Optional) = Number of decimal places to truncate data to. 2 is the default.
	 	<br />data-prefix (Optional) = String that is concatenated before the formula result. (prefix + formulaResult)
	 	<br />data-prefix (Optional) = String that is concatenated after the formula result. (formulaResult + suffix)
	 * This should only be called internally when the object is initializing. 
	 * Example: <code>bindDynamicHighlights(context)</code>
	 * @param context = JQuery Object or DOM Object reference to scope binding to
	 * @return dynamicHightlights[dynamicHighlight1, dynamicHighlight2, etc.]
	 * @private for use in this file only
	 *****************************************************************************/
	var bindDynamicHighlights = function(context) {
		//get all elements with class of dynamicHighlight
		var dynamicHighlights = [];
		$(".dynamicHighlight", context).each(function() {
			var precision = this.getAttribute("data-precision");
			var prefix = this.getAttribute("data-prefix");
			var suffix = this.getAttribute("data-suffix");
			
			dynamicHighlights.push({
				elemObj:this,
				precision:(precision != null && !isNaN(precision)) ? precision : 2,
				formula:this.getAttribute("data-formula"),
				prefix:(prefix) ? prefix : "",
				suffix:(suffix) ? suffix : ""
			});
		});
		
		return dynamicHighlights;
	}
    /******************************************************************************
	 * Binds an input element external to the flash control that represents the 

	 * Example: <code>bindStaticDataControls(chartObj)</code>
	 * @param chartObj = reference to the calling chart object
	 * @return JQuery Object or null if control is not found
	 * @private for use in this file only
	 *****************************************************************************/
    var bindStaticHighlightControls = function(chartObj) {
		$(".staticHighlightControl", chartObj.chartContainerObj).change(function(event) {
	    	chartObj.changeStaticHighlight(event.target);
	    });
	}
	
	/******************************************************************************
	 * Binds elements with a class of "staticHighlight". The must be inside of the
	 * containing element referenced by the context argument. 
	 * 
	 * Static highlight are used to calculate a specific range of date based on a required formula. 
	 * This method constructs a staticHighlight object that is contained inside of the 
	 * this.staticHighlights collection. The object is populated from attributes 
	 * on the element that has the class of "staticHighlight". Valid Attributes:
	 	<br />data-formula (Required) = Data columns can be referenced by name used in settings.xml
	 	 for the stockChart flash object or by column position. 
	 	 Example1:sum(1) Example2:avg('colName') Example3:sum(1)/avg('colName')
	 	<br />data-precision (Optional) = Number of decimal places to truncate data to. 2 is the default.
	 	<br />data-prefix (Optional) = String that is concatenated before the formula result. (prefix + formulaResult)
	 	<br />data-prefix (Optional) = String that is concatenated after the formula result. (formulaResult + suffix)
	 	<br />data-type (Optional if data-type-ref is set) = Type represents the number of days to calculate data for. 
	 	  Valid types are mtd,ytd,wtd,prev365,prev7,prev90,prev30,prev1,cur1,cur365,cur90,cur30,cur7.
	 	<br />data-type-ref (Optional if data-typeSet) = reference id to the element that will be used to dynamically
	 	  set the one of the valid types for the data-type attribute. 
	 *
	 * This should only be called internally when the object is initializing. 
	 * Example: <code>bindDynamicHighlights(context)</code>
	 * @param context = JQuery Object or DOM Object reference to scope binding to
	 * @return dynamicHightlights[dynamicHighlight1, dynamicHighlight2, etc.]
	 * @private for use in this file only
	 *****************************************************************************/
	var bindStaticHighlights = function(context) {
		var staticHighlights = [];
		$(".staticHighlight", context).each(function() {
			var precision = this.getAttribute("data-precision");
			var prefix = this.getAttribute("data-prefix");
			var suffix = this.getAttribute("data-suffix");
    		var typeRef = this.getAttribute("data-type-ref");
    		var type = this.getAttribute("data-type");
    		
			staticHighlights.push({
				//JQueryObject
				elemObj:this,
				precision:(precision != null && !isNaN(precision)) ? precision : 2,
				formula:this.getAttribute("data-formula"),
				prefix:(prefix) ? prefix : "",
				suffix:(suffix) ? suffix : "",
				type:type,
				typeRef:typeRef
			});
		});
		return staticHighlights;
	}
	
	
	
	/******************************************************************************
	 * Builds a collection of column names from the settings xml that is passed in.
	 * Example: <code>getColumns(settingsXML)</code>
	 * @return  array of column names
	 *****************************************************************************/
	var getColumns = function(settingsXML) {
		var parseFromIndex = settingsXML.indexOf("<columns>");
		var parseToIndex = settingsXML.indexOf("</columns>");
		var columns = [];
		if (parseFromIndex > -1 && parseToIndex > -1) {
			columns = settingsXML.substring(parseFromIndex+9, parseToIndex);
			columns = columns.split("<column>").join("").split("</column>");
			//check to make sure result is an array, if not, empty array should be returned.
			columns = (columns instanceof Array) ? columns : [];
		}
		return columns;
	}
    
	/******************************************************************************
	 * Returns the column position based on the column name passed in. If a number
	 * is passed in the number is returned. -1 is returned if a matching column 
	 * cannot be found.
	 * Example: <code>this.attachs()</code>
	 * @param {String} col = Column name as String or Integer <br />
	 * @param {String} columnNames = Array of column names used by the flash chart <br />
	 * @return {Integer} pos = column index number for that data
	 *****************************************************************************/
	var getColumnPos = function(col, columnNames) {
		var pos = -1;
		if (!isNaN(col)) {
			pos = col;
		} else {
			pos = $.inArray(col, columnNames);
		}
		return pos;
	}
    	
    /******************************************************************************
	 * AMStock API Call
	 * getSettings calls into the AMStock api to request the current settings. 
	 * Flash chart uses a callback method amReturnSettings(chart_id, settings)
	 * return the settings in xml.
	 * Example: <code>getSettings(flashChartObj)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @return VOID
	 * @private for use in this file only
	 *****************************************************************************/
	var getSettings = function(flashChartObj) {
			//console.log("in getSettings");
		flashChartObj.getSettings();
	}
	
	/******************************************************************************
	 * AMStock API Call
	 * getData calls into the AMStock api to request the current data. 
	 * Flash chart uses a callback method amReturnData(chart_id, param)
	 * return the cvs data as a string.
	 * Example: <code>getData(flashChartObj)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
	var getData = function(flashChartObj) {
		
		flashChartObj.getData(0);
	}
    
    /******************************************************************************
	 * AMStock API Call
	 * compareDataSet calls into the AMStock api to select a data set for comparing. 
	 * The dataSetID argument is the position of the data set in the settings xml. 
	 * Example: <code>compareDataSet(flashChartObj, dataSetID)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @param {Integer} dataSetID = data_set node position in the settings XML
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
	var compareDataSet = function(flashChartObj,dataSetID){
			//console.log("dataSetID "+dataSetID);
		flashChartObj.compareDataSet(dataSetID);
	}   
	
	/******************************************************************************
	 * AMStock API Call
	 * uncompareDataSet calls into the AMStock api to deselect a data set that 
	 * is being compared. The dataSetID argument is the position of the data set 
	 * in the settings xml. 
	 * Example: <code>uncompareDataSet(flashChartObj, dataSetID)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @param {Integer} dataSetID = data_set node position in the settings XML
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
	var uncompareDataSet = function(flashChartObj, dataSetID){
		flashChartObj.uncompareDataSet(dataSetID);
	} 
	
	/******************************************************************************
	 * AMStock API Call
	 * uncompareAll calls into the AMStock api to deselect all data sets that 
	 * are being compared. 
	 * Example: <code>uncompareAll(flashChartObj, dataSetID)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
	var uncompareAll = function(flashChartObj){     
		flashChartObj.uncompareAll();
	}
	
	/******************************************************************************
	 * AMStock API Call
	 * selectDataSet calls into the AMStock api to set the passed in dataSetID as
	 * primary data set for the graph. This is the data set that will be drawn by 
	 * default and used to compare against.  
	 * Example: <code>selectDataSet(flashChartObj, dataSetID)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @param {Integer} dataSetID = data_set node position in the settings XML
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
	var selectDataSet = function(flashChartObj, dataSetID) {
		flashChartObj.selectDataSet(dataSetID);
	}
    
    /******************************************************************************
	 * AMStock API Call
	 * hideEvents calls into the AMStock api to hide event popups. 
	 * Example: <code>hideEvents(flashChartObj)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var hideEvents = function(flashChartObj) {
    	flashChartObj.hideEvents();
    }
    
    /******************************************************************************
	 * AMStock API Call
	 * showEvents calls into the AMStock api to show event popups. 
	 * Example: <code>showEvents(flashChartObj)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var showEvents = function(flashChartObj) {
    	flashChartObj.showEvents();
    }
    
    /******************************************************************************
	 * AMStock API Call
	 * showAll calls into the AMStock api to show the full date range of data if
	 * a shorter period was selected.  
	 * Example: <code>showAll(flashChartObj)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var showAll = function(flashChartObj) {
    	flashChartObj.showAll();
    }
    
    /******************************************************************************
	 * AMStock API Call
	 * setData calls into the AMStock api is used for setting the chart's data on the fly. 
	 * Data must be in CSV form. Note, that this will work properly if you do not 
	 * compare data sets, as only currently selected data set will receive this data.   
	 * Example: <code>setData(flashChartObj)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var setData = function(flashChartObj, data) {
    	flashChartObj.setData(data);
    }
    
   /******************************************************************************
	 * AMStock API Call
	 * rebuild calls into the AMStock api will rebuild the chart. If you set some 
	 * settings using setSettings() function, with the "rebuild" set to "false", 
	 * then you can use this function to redraw the chart after several portions 
	 * of settings were set.    
	 * Example: <code>rebuild(flashChartObj)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var rebuild = function(flashChartObj) {
    	flashChartObj.rebuild();
    }
    
    /******************************************************************************
	 * AMStock API Call
	 * reloadData calls into the AMStock api to reload the data.    
	 * Example: <code>reloadData(flashChartObj)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var reloadData = function(flashChartObj) {
    	flashChartObj.reloadData();
    }
    
    /******************************************************************************
	 * AMStock API Call
	 * reloadSettings calls into the AMStock api to reload the current settings file.
	 * Optional filename argument can be used to load a different settings file.     
	 * Example: <code>reloadSettings(flashChartObj)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @param {String} filename = Optional filename/path to load a different file.
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var reloadSettings = function(flashChartObj, filename) {
    	flashChartObj.reloadSettings(filename);
    }
    
    /******************************************************************************
	 * AMStock API Call
	 * setSettings calls into the AMStock api used to set multiple (or a single) 
	 * setting at a runtime. The settings must be passed in XML form, using the same 
	 * names as in settings file. The settings string must not contain line breaks, 
	 * double quotes must be replaced with single quotes. Note, if you want to change 
	 * some existing settings of the settings items which can be multiple, such as 
	 * <data_set>, <chart>, <graph>, you must add an ID for these settings both in 
	 * your main setting and when passing them with this function. The id is formed 
	 * out of the first letter of a setting name and the "id", for example:
	 * <chart cid="0"> or <data_set did="1"> or <graph gid="2">.   
	 * Example: <code>setSettings(flashChartObj, "<background><color>
	 *               #CC0000</color><alpha>100</alpha></background>", 
	 * 					true, false)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @param {XML String} settings = XML structure to set. This is a path to 
	 *				the node to be set represented in XML. This should not include
	 * 				the settings start tag and closing tag.
	 * @param {Boolean} rebuild = Set to true if chart should rebuild after the new
	 *					value(s) are set. If set to false rebuild() must be called 
	 *					to get the chart to redraw.
	 * @param {Boolean} resetSelected = Boolean set to true if the value should be 
	 * 					reset to it original value in the in the settings xml file.
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var setSettings = function(flashChartObj, settings, rebuild, resetSelected) {
		    //console.log("set settings ");
		   // console.log("settings "+settings);
    	var strBuff = [];
    	strBuff.push("<settings>");
    	strBuff.push(settings);
    	strBuff.push("</settings>");
    	flashChartObj.setSettings(strBuff.join(""), rebuild, resetSelected);
    }
    
    /******************************************************************************
	 * AMStock API Call
	 * appendData calls into the AMStock api is be used to append new data to the 
	 * currently selected dataset. This is extremely useful when your dataset is 
	 * quite big and you add a few values every period but don't want to reload 
	 * the whole dataset. The data must be in CSV. The removeCount variable is 
	 * optional and sets the number of data points that should be removed from 
	 * the beginning of dataset.      
	 * Example: <code>appendData(flashChartObj, data, removeCount)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @param {String} data = CVS formatted data set string.
	 * @param {Integer} removeCount = Optional Number of data points to removing at the 
	 *			beginning of the dataset.
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var appendData = function(flashChartObj, data, removeCount) {
    	flashChartObj.appendData(data, removeCount);
    }
    
    /******************************************************************************
	 * AMStock API Call
	 * getParam calls into the AMStock api to ask the flash chart to return the value 
	 * of a setting. The parameter name is formed as "background.alpha " or 
	 * "data_sets.data_set[0].title". When you call this function to return the setting 
	 * value, Flash will call the amReturnParam(chart_id, param) function. 
	 *      
	 * Example: <code>getParam(flashChartObj, "background.color", "obj.foo")</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @param {String} param = String notation for the xml parameter to be fetched.
	 * @param {Function} callback = Function to be called when amReturnParam is called.
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var getParam = function(flashChartObj, param, callback) {
    	//@TODO finish hooking this up. Problem is that the returnParam function 
    	//Only returns the string. There is no context as to what param was requested.
    	//Either only allow one param to be requested at a time and use setTimeout to retry x times until the lock is released or
    	//create listener for getParam event to invoke callback
    	flashChartObj.getParam(param);
    }
    /******************************************************************************
	 * AMStock API Call
	 * setZoom calls into the AMStock api to set the desired date range selection
	 * to be viewed for the data set.     
	 * Example: <code>setZoom(flashChartObj, data, removeCount)</code>
	 * @param {DOM Object} flashChartObj = DOM object reference to flash chart
	 * @param {Date} from = The date to view data from.
	 * @param {Date} to = The date to view data through.
	 * @return  VOID
	 * @private for use in this file only
	 *****************************************************************************/
    var setZoom = function(flashChartObj, from, to, dataDateFmt) {
    	//console.log("setZoom");
    	var tempToDate = new $.dr.date(to, dataDateFmt);
		//To Date is not inclusive. Resulting date displayed in the graph is
		// one less. We need to increment it by 1 to get the proper result. 
		tempToDate.setDate(tempToDate.getDate() + 1);
    	flashChartObj.setZoom(from, tempToDate.toFormattedString());
    }
    
    /******************************************************************************
	 * Determines where to start calculating data from by getting an offset and days
	 * property from a $.dr.stockChart.STATIC_TYPES. If a typeRef attribute is set in
	 * the highlight it will get the highlight value from the bound form field. 
	 * The highlight object plus the offset, type, and days is used to calculate
	 * the requested value based on the supplied formula in the highlight. Resulting
	 * value is set as inner HTML on the html object that was used to build the static
	 * highlight.
	 * Example: <code>updateStaticHighlight(highlight, chartObj)</code>
	 * @param {highlight} highlight = Highlight object defining the attributes for 
	 			calculating the highlight data.
	 * @param {StockChart} chartObj = the chart object for which this static highlight is for.
	 * @return  VOID
	 *****************************************************************************/
	var updateStaticHighlight = function(highlight, chartObj) {
		var offset = 0;
		var days = 1;
		var staticTypes = $.dr.stockChart.STATIC_TYPES;
		if (highlight.typeRef) {
			highlight.type = $("#" + highlight.typeRef).val();
		}
		if (highlight.type) {
			for(var t in staticTypes) {
				if(t == highlight.type) {
					offset = staticTypes[t].offset;
					days = staticTypes[t].days;
					break;
				}
			}
		} 
		highlight.chartObj = chartObj;
		highlight.startOffset = offset;
		highlight.numDays = days;
		highlight.avg = function(colPos) {
			return chartObj.staticData.avg(this, colPos);
		};
		highlight.sum = function(colPos) {
			return chartObj.staticData.sum(this, colPos);
		};
		var dataVal = "0";
		with(highlight) {
			dataVal = eval(formula);
			if (!isNaN(dataVal)) {
				dataVal = prefix + dataVal.toFixed(precision).formatNumber() + suffix;
			} else {
				dataVal = $.dr.stockChart.DATA_NOT_AVAILABLE
			}
		}
		$(highlight.elemObj).html(dataVal);
		$(highlight.elemObj).trigger("staticChange");
		
	}
	/******************************************************************************
	 * StockChart constructor for creating stock chart objects
	 * 
	 * @param {String} chartNum a string that indicates the chart number on the page
	 * @param {String} dataDateFmt (Optional) a string for the required date format, 
	 * 					such as "mm/dd/yyyy". If it is not set "yyyy-mm-dd" will be used.
	 * @return VOID
	 *****************************************************************************/
    $.dr.stockChart = function(prefix, dataDateFmt) {
    	//wrong spot for this code
    	//DR.Widgets.ProcessingDialog.init();
    	//DR.Widgets.ProcessingDialog.show();
    		this.dataDateFmt = (dataDateFmt) ? dataDateFmt : "yyyy-mm-dd";
    		this.chartPrefix = prefix;
    		//document should be the default
    		var tempChartObj = $("#" + this.chartPrefix);
	    	this.chartContainerObj = (tempChartObj.length > 0) ? tempChartObj : document;
    }
    
      
    //DR.GlobalUpdater.addUpdater($.dr.stockChart);  
    $.dr.stockChart.prototype = {
    	/*Init the flash object
    	 * @ {String} id of flash Chart object
    	 * 
    	 */
    	initChart:function(id) {
    		//build reference to flash file to make future calls into flash object with
    		this.flashChartObj = document.getElementById(id); //$("#" + id);
	    	//Store Dynamic highlight objects
	    	this.dynamicHighlights = {};
	    	//Store References to Static Highlights
	    	this.staticHighlights = [];
	    	
	    	this.controls = {};
	    	this.controls.apply = [];
	    	this.controls.graphColumn = [];
	    	
	    	this.controls.fromDate = bindRangeFromControls(this.chartContainerObj); 
	    	this.controls.toDate = bindRangeToControls(this.chartContainerObj);
	    	this.controls.compareTo = bindCompareToControls(this);
	    	this.controls.changeDataSet = bindSetDataControl(this);
    		this.controls.apply = bindApplyControls(this);
    		this.controls.graphColumn = bindGraphColumnControls(this);
    		bindStaticHighlightControls(this);
    		this.staticHighlights = bindStaticHighlights(this.chartContainerObj);
    		this.dynamicHighlights = bindDynamicHighlights(this.chartContainerObj);
	    	
	    	this.rangeFromDate = null;
	    	this.rangeToDate = null;  	
	    	
	    	this.chartSettingsXML = null;
	    	
	    	this.columnNames = [];
	    	
	    	// set to true once data is loaded
	    	this.isDataLoaded = false; 
	    	//two dimensional array of rows and columns of data
	    	this.chartData = null; 
	    	//number of columns of data, used for looping over columns of data
	    	this.numDataColumns = 0;
	    	//number of rows of data, used in formula calcuations
	    	this.dataPoints = 0;
	    	// array with only the date str as data. Used to locate data by date in the array
	    	this.chartDataLoc = []; 
	    	
	    	//date formatted the same as the date format in the csv file.
	    	//This is the date that data goes back to. 
	    	this.dataStartDate = null;
	    	//date formatted the same as the date format in the csv file.
	    	//This is the date that data is through.
	    	this.dataEndDate = null;

	    	this.rangeTotals = [];
	    	this.rangeAverages = [];
	    	this.rangeDataPoints = 0;	    	
    		
    		
    		//set rangeStart from external range control if date is null
			if (!this.rangeFromDate && this.controls.fromDate) {
    			this.rangeFromDate = new $.dr.date($(this.controls.fromDate).val(), $.dr.date.getDefaultFormat()).toFormattedString(this.dataDateFmt);
    		} 
    		//set rangeEnd from external range control if date is null
    		if (!this.rangeToDate && this.controls.toDate) {
    			this.rangeToDate = new $.dr.date($(this.controls.toDate).val(), $.dr.date.getDefaultFormat()).toFormattedString(this.dataDateFmt);
    		}
    		
    		//Request Settings from XML, returnSettingsCallback(settings) will store
    		//the resulting settings in this.chartSettingsXML property.
    		getSettings(this.flashChartObj);
    		
    		//I am a little worried about getting into a race condition here.
    		//this.chartSettingsXML might not returned from the callback method.
    		//This should be refactored into a method call that can recall itself if
    		//the data is not present.
			this.columnNames = getColumns(this.chartSettingsXML);
			
			//Request the data from flash file. returnDataCallback(dataString) will be
			//called by the amReturnData method to load and initialize the data in chartObject.
			getData(this.flashChartObj);
			
			//Set date that the data begins at
			this.dataStartDate = this.chartData[0][0];
			//Set the date that the data ends at
    		this.dataEndDate = this.chartData[this.chartData.length-1][0];
			
			this.updateStaticHighlights();
			this.getZoomCallback(this.rangeFromDate, this.rangeToDate);
			this.syncBoundControls();
    	},
		
		syncBoundControls:function() {
		//@TODO finsih this metod
			for(var controlType in this.controls) {
				switch(controlType) {
					case "compareTo":
						//getParam(this.flashChartObj, "data_sets.data_set[1].compare_list_box");
						break;
					case "graphColumn":
						for (var c = 0; c < this.controls[controlType].length; c++) {
						}
						break;
					case "fromDate":
						
						break;
					case "toDate":
						
						break;	
					default:
					break;
				
				}
			}
		},
		
    	/******************************************************************************
		 * Sets value the external date controls. This always gets called after a date
		 * change event happens in the chart. Uses properties this.rangeToDate and 
		 * this.rangeFromDate to set the values for the date control.
		 *
		 * Example: <code>this.setCustomDateControls()</code>
		 * @return VOID
		 *****************************************************************************/
    	setCustomDateControls:function(start, end) {
    		if (this.controls.toDate) {
	    		$(this.controls.toDate).val(new $.dr.date(this.rangeToDate, this.dataDateFmt).toFormattedString($.dr.date.getDefaultFormat()));
	    	}
	    	if (this.controls.fromDate) {
	    		$(this.controls.fromDate).val(new $.dr.date(this.rangeFromDate, this.dataDateFmt).toFormattedString($.dr.date.getDefaultFormat()));
	    	}
    	},
    	
    	
    	
		/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * Sets variables that represent the date range selected in the flash chart object.
		 * Once the variables are set update is called to updated dynamic highlights and 
		 * other required data. Main use is when a date change occurs in the flash file, the
		 * flash chart calls he amGetZoom(chart_id, from, to) which in turn calls this 
		 * method to sync the flash and js object.
		 *
		 * Example: <code>this.getZoomCallback(start, end) or for 
		 * external calls chartObj.getZoomCallback(start, end)</code>
		 * @param start = Range Start date formatted to date format used in the CSV data file
		 * @param end = Range end date formatted to date format used in the CSV data file
		 *****************************************************************************/
		getZoomCallback:function(from, to) {
			this.rangeFromDate = from;
    		this.rangeToDate = to;	
    		this.setCustomDateControls();
    		this.update();
    	},
    	
    	/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * This is called only by the amRolledOver(chart_id, date, period) callback method that
		 * gets invoked when a date marker on the graph is rolled over. 
		 *
		 * Example: <code>window[chart_id].clickedOnCallback(date, period)</code>
		 * @param {Date String} date = date string formatted to date pattern the data uses
		 * @param {String} period = DD, WW, MM are passed back as the period the the marker
		 * 					is for. 
		 * @return  VOID
		 *****************************************************************************/
    	rolledOverCallback:function(date, period) {
    		//console.log("rolledOverCallback", date, period);
    		//--- Not Currently Implemented - DO Nothing ----//
    	},
    	
    	/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * This is called only by the amProcessComplete(process_name) callback method that
		 * gets invoked when a process has finished. Process names that get handed back
		 * are usually the JavaScript function names that were called to do something with
		 * the flash chart. Examples are "setSettings", "setParam", "appendData", "setData"
		 * etc. The passed in process name is the name of the JavaScript AMCharts 
	 	 * method that was executed.   
	 	 *
		 * Example: <code>window[chart_id].errorCallback(message)</code>
		 * @param {String} process_name = Name of the function/process that just completed
		 * @return  VOID
		 *****************************************************************************/
    	processCompletedCallback:function(process_name) {
    		//console.log("processCompletedCallback");
    		//--- Not Currently Implemented - DO Nothing ----//
    		getSettings(this.flashChartObj)
    	},
    	
    	/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * This is called only by the amError(message) callback method that
		 * gets invoked when an error has occurred. 
		 *
		 * Example: <code>window[chart_id].errorCallback(message)</code>
		 * @param {String} message = Text of the error that occurred.
		 * @return  VOID
		 *****************************************************************************/
    	errorCallback:function(message) {
    		//console.log("errorCallback");
    		//--- Not Currently Implemented - DO Nothing ----//
    	},
    	
    	/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * This is called only by the amClickedOn(chart_id, date, period) callback method that
		 * gets invoked when a date marker on the graph is clicked on. The graph will 
		 * zoom into the date period that was clicked on.
		 * 
		 * Example: <code>window[chart_id].clickedOnCallback(date, period)</code>
		 * @param {Date String} date = date string formatted to date pattern the data uses
		 * @param {String} period = DD, WW, MM are passed back as the period the the marker
		 * 					is for. 
		 * @return  VOID
		 *****************************************************************************/
    	clickedOnCallback:function(date, period) {
    		if(period == "DD") {
    			setZoom(this.flashChartObj, date, date, this.dataDateFmt);
    		} else if (period == "WW") {
    			var tempDate = new $.dr.date(date, this.dataDateFmt);
    			tempDate.setDate(tempDate.getDate() + 6);
    			setZoom(this.flashChartObj, date, tempDate.toFormattedString(), this.dataDateFmt);
    		} else if (period == "MM") {
    			var tempDate = new $.dr.date(date, this.dataDateFmt);
    			tempDate.setMonth(tempDate.getMonth() + 1);
    			tempDate.setDate(tempDate.getDate()-1);
    			setZoom(this.flashChartObj, date, tempDate.toFormattedString(), this.dataDateFmt);
    		}
    	},
    	
    	/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * This is called only by the amRolledOverEvent(chart_id, date, description, id, url) 
		 * callback method that gets invoked when an event marker on the graph is 
		 * rolled over. 
		 * 
		 * Example: <code>window[chart_id].rolledOverEventCallback(date, description, id, url)</code>
		 * @param {Date String} date = date string formatted to date pattern the data uses
		 * @param {String} description = Value entered in the description node for the event
		 * @param {String} id = The value of the eid attribute of the event
		 * @param {String} url = The value of the URL node of the event
		 * @return  VOID
		 *****************************************************************************/ 
    	rolledOverEventCallback:function(date, description, id, url) {
    		//console.log("rolledOverEventCallback");
    		//--- Not Currently Implemented - DO Nothing ----//
    	},
    	
    	/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * This is called only by the amRolledOverEvent(chart_id, date, description, id, url) 
		 * callback method that gets invoked when an event marker on the graph is 
		 * clicked on. 
		 * 
		 * Example: <code>window[chart_id].clickedOnEventCallback(date, description, id, url)</code>
		 * @param {Date String} date = date string formatted to date pattern the data uses
		 * @param {String} description = Value entered in the description node for the event
		 * @param {String} id = The value of the eid attribute of the event
		 * @param {String} url = The value of the URL node of the event
		 * @return  VOID
		 *****************************************************************************/  
    	clickedOnEventCallback:function(date, description, id, url) {
    		//console.log("clickedOnEventCallback");
    		//--- Not Currently Implemented - DO Nothing ----//
    	},
    
    	/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * This is called only by the amReturnSettings(settings) callback method that
		 * gets invoked when a getSettings() call is made into the flash chart.
		 * Settings are unescaped before storing in the object.
		 *
		 * Example: <code>window[chart_id].returnSettingsCallback(settings)</code>
		 * @param String settings = all the settings returned as an xml string.
		 * @return  VOID
		 *****************************************************************************/
    	returnSettingsCallback:function(settings) {
		    	//console.log("returned settings "+unescape(settings));
    		this.chartSettingsXML = unescape(settings);
    	},
    	
    	/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * This is called only by the amReturnSettings(settings) callback method that
		 * gets invoked when a getSettings() call is made into the flash chart.
		 *
		 * Example: <code>window[chart_id].returnDataCallback(data)</code>
		 * @param (String)data = cvs data as a string
		 * @return  VOID
		 *****************************************************************************/
    	returnDataCallback:function(tempChartData) {
	    	//@TODO CHECK LINE ENDINGS IN ALL BROWSERS!!!!!!!!
    		var startTime = new Date().getTime();
    		this.chartData = tempChartData.split("\n");
    		this.chartData.reverse();
    		for(var i = 0; i < this.chartData.length; i++) {
    			//assign data to temporary object to test for data integrety.
    			var temp = this.chartData[i].split(',');
    			//test data to make sure data will be in columns. Consider having a property on the object that list 
    			//number of expected data columns and test against that. 
    			if (temp.length > 1) {	
    				this.chartData[i] = temp;
    				//store date in separate array to speed up locating data
    				this.chartDataLoc[i] = this.chartData[i][0];
    				temp = null; //release memory
    			} else {
    				//remove invalid data
    				var removed = this.chartData.splice(i, 1);
    				//decrement i to account for removed row
    				i--;
    			}		
    		}
    		var endTime = new Date().getTime();
    		this.dataPoints = this.chartData.length;
    		this.numDataColumns = this.chartData[0].length;
    		this.isDataLoaded = true;
    		//null to release memory, not sure if this helps, but it doesn't hurt
    		tempChartData = null;
    	},
    	
    	/******************************************************************************
		 * AMStock Required Callback Method
		 *
		 * This is called only by the amReturnParam(chart_id, param) callback method that
		 * gets invoked when a getParam() call is made into the flash chart.
		 *
		 * Example: <code>window[chart_id].returnParamCallback(param)</code>
		 * @param (String) param = value of the requested parameter
		 * @return  VOID
		 *****************************************************************************/
		returnParamCallback:function(param) {
			//console.log("returnParamCallback");
			/*Not sure how to used this since we don't know what param was requested. We
			will probably need to only allow one param to be requested at time. A listener
			would be created when a getParam method was called. This would broadcast an
			param returned event with the value. The callback method that was attached to the
			listner would execute and pick up hte param value */
			//--- Not Currently Implemented - DO Nothing ----//
		},
		
    	/******************************************************************************
		 * This method will recalculate any static highlight object that is stored in
		 * this.staticHighlights[] array with a typeRef property that matches the id
		 * of the object passed into this method. This method automatically gets 
		 * bound to an html element by the bindStaticHighlightControls method.
		 * Example: <code>chartObj.changeStaticHighlight(event.target)</code>
		 * @param {HTML Element Object} obj = Usually the object that calls this method<br />
		 * @return  VOID
		 *****************************************************************************/
    	changeStaticHighlight:function(obj) {
    		var refId = obj.id;
    		for (var i=0; i < this.staticHighlights.length; i++) { 
    			var highlight = this.staticHighlights[i];
    			for(var r in highlight) {
    				if (r == "typeRef" && highlight[r] == refId) {
    					updateStaticHighlight(this.staticHighlights[i], this);
    				}
    			}
    		}
    	},   	
    	
    	/******************************************************************************
		 * Calls updateStaticHighlight for each highlight object. This is 
		 * generally only called during initialization
		 * Example: <code>this.updateStaticHighlights()</code>
		 * @return  VOID
		 *****************************************************************************/
    	updateStaticHighlights:function() {
    		for(var i=0; i < this.staticHighlights.length; i++) {
    			updateStaticHighlight(this.staticHighlights[i], this);
    		}
    	},
    	    	
    	/******************************************************************************
		 * Object is used to contain functions that are used to specify formulas for
		 * static highlights. These methods need to be unique from the similar 
		 * counterparts for dynamicHighlights.
		 * Example: <code>this.staticData.avg(highlightObj, col) or 
		 *             this.staticData.sum(highlightObj, col)</code>
		 * @return  VOID
		 *****************************************************************************/
    	staticData:{
    	//@TODO seems like there should be a better/cleaner way to package up all static highlight code with closures, etc.
    		avg:function(highlightObj, col) {
    			var dataVal = this.sum(highlightObj, col)/highlightObj.numDays;
    			return Number(dataVal);
    		},
    		sum:function(highlightObj, col) {
    			var colNum = getColumnPos(col, highlightObj.chartObj.columnNames);
	    		var dataVal = Number.NaN;
    			var startPos = (highlightObj.chartObj.chartData.length - 1) - highlightObj.startOffset;// - ((highlightObj.numDays-1)+ highlightObj.startOffset);
    			var endPos = startPos - (highlightObj.numDays);
    			
    			if (colNum > -1) {
    				dataVal = 0;
	    			for(var i = startPos; i > endPos; i--) {
	    			//seems like there should be a way to get to the chartdata without going through highlightObj
	    				var val = Number(highlightObj.chartObj.chartData[i][colNum]);
	    				dataVal += ((val == NaN)? 0 : val);
	    			}
	    		}

	    		return Number(dataVal);
    		}
    	},
    	
    	/******************************************************************************
		 * This method is called by an onchange event that is bound to an select form 
		 * control with the class of "changeCompareTo". This will uncompare a compare
		 * source if there is one and use the selected value in the select as the new 
		 * compare soure. The value used in the "value" attribute will be used if both
		 * a text value and value are set. 
		 * Example: <code>this.changeCompareTo(elemObj)</code>
		 * @param {DOM Object} elemObj = DOM element that will be used determine the 
		 * 						values being passed in. 
		 * @return  VOID
		 *****************************************************************************/
		changeCompareTo:function(elemObj) { 
				//console.log("changeCompareTo "+elemObj);
			var dataSetId = $(elemObj).val();
			//console.log("dataSetId "+dataSetId);
			uncompareAll(this.flashChartObj);
			if (dataSetId != ""){
				compareDataSet(this.flashChartObj, dataSetId);
			}
		},   
		
		changeSelectDataSet:function(data) {
			
			selectDataSet(this.flashChartObj,data);
		},
		
		/******************************************************************************
		 * This method is called by an onchange event that is bound to an select form 
		 * control with the class of "changeGraphColumn". This calls buildGraphSrcColSettingXML
		 * and calls setSettings with the value that is returned. The resulting setSettings
		 * call will cause the flash chart to be rebuilt. 
		 * Example: <code>this.changeGraphSrcColumn(elemObj)</code>
		 * @param {DOM Object} elemObj = DOM element that will be used determine the 
		 * 						values being passed in. 
		 * @return  VOID
		 *****************************************************************************/
		changeGraphSrcColumn:function(elemObj) {
			var settings = buildGraphSrcColSettingXML(elemObj);
			setSettings(this.flashChartObj, settings, true);
		},
		
		/******************************************************************************
		 * Loop through all the controls array that contains all the controls that have
		 * been bound by an "applyX" class. Settings XML is built by calling the 
		 * corresponding buildXSettingXML method. All of the settings are passed in as
		 * one string to the setSettings method. The resulting setSettings call will as
		 * request that the flash chart be rebuilt. This is usually call from a bound
		 * button with the class of "applySettings".
		 * Example: <code>this.applySettings()</code>
		 * @return  VOID
		 *****************************************************************************/
		applySettings:function() {
				//console.log("apply settings ");
			var strBuff = [];
			
			for(var controlType in this.controls) {
				switch(controlType) {
					case "compareTo":
						//console.log("control type "+controlType);
						//hasCompareControl = true;
						//strBuff.push(buildCompareToSettingXML(this.controls.compareTo));
						//commented above because we can get the setSettings to apply the compare node correctly to the graph
						break;
					case "graphColumn":
						for (var c = 0; c < this.controls[controlType].length; c++) {
							strBuff.push(buildGraphSrcColSettingXML(this.controls[controlType][c]));
						}
						break;
					case "fromDate":
						strBuff.push(buildFromDateSettingXML(this.controls.fromDate, this.dataDateFmt));
						break;
					case "toDate":
						strBuff.push(buildToDateSettingXML(this.controls.toDate, this.dataDateFmt));
						break;	
					default:
					break;
				
				}
				
			}
			setSettings(this.flashChartObj, strBuff.join(""), true);

		},	
		
    	/******************************************************************************
		 * update calculates the bound dynamic highlight values based on the selected
		 * date range. This gets invoked anytime the date range is changed. If the 
		 * data is not loaded it will continue to retry. 
		 * Example: <code>this.update()</code>
		 * @return  VOID
		 *****************************************************************************/
    	update:function () {
    		if (!this.isDataLoaded) {
    			var oSelf = this;
    			window.setTimeout(function(){oSelf.update()}, 1000);
    		} else {
    			var endPos = parseInt(jQuery.inArray(this.rangeToDate, this.chartDataLoc));
    			var startPos = parseInt(jQuery.inArray(this.rangeFromDate, this.chartDataLoc));
    			this.rangeDataPoints = (endPos - startPos) +1;
    			//console.error("this.rangeDataPoints", this.rangeDataPoints);
    			//zero arrays before recalcuating new values for selected range.
    			for (var col = 1; col < this.numDataColumns; col++) {
	    			this.rangeTotals[col] = 0;
	    			this.rangeAverages[col] = 0;
	    		}
    		
    			for (var row = startPos; row <= endPos; row++) {
    			
    				for (var col = 1; col < this.numDataColumns; col++) {
    					var val = Number(this.chartData[row][col]);
    					
    					//console.log("numDataColumns "+this.numDataColumns+" val "+val+" row "+row);
    					
    					this.rangeTotals[col] = this.rangeTotals[col] + ((val == NaN)? 0 : val);
    				} 
    			}
    			for (var colNum = 1; colNum < this.rangeTotals.length; colNum++) {
    				
    				//console.log("rangeTotals.length "+this.rangeTotals.length+" rangeDataPoints "+this.rangeDataPoints+" colNum "+colNum);
    				
    				this.rangeAverages[colNum] = this.rangeTotals[colNum]/this.rangeDataPoints;
    			}
    			
    			this.updateDynamicHighlights();
    		}
    	},
    	
    	/******************************************************************************
		 * sum looks up the column name if passed in or uses the position to get a total
		 * from the this.rangeTotals array that was calculated by the update method. 
		 * Number.NaN will be return if an invalid column is passed in.
		 * 
		 * Example: <code>this.sum(colName/Pos)</code>
		 * @param {String/Integer} col = The column name used in the settings.xml file 
		 			can be passed in of the colum position in the csv data.
		 * @return  (Number) The sum for the requested column will be returned.
		 *****************************************************************************/
    	sum:function (col) {
    		var colNum = getColumnPos(col, this.columnNames);
    		return (colNum > -1) ? this.rangeTotals[colNum] : Number.NaN;
    	},
    	/******************************************************************************
		 * avg looks up the column name if passed in or uses the position to get an average
		 * from the this.rangeAverages array that was calculated by the update method. 
		 * Number.NaN will be return if an invalid column is passed in. 
		 *
		 * Example: <code>this.avg(colName/Pos)</code>
		 * @param {String/Integer} col = The column name used in the settings.xml file 
		 			can be passed in of the colum position in the csv data.
		 * @return  {Number} the average for the requested column will be returned.
		 *****************************************************************************/
    	avg:function (col) {
    		var colNum = getColumnPos(col, this.columnNames);
    		return (colNum > -1) ? this.rangeAverages[colNum] : Number.NaN;
    	},
    	/******************************************************************************
		 * dataPoints returns the number of data points in the selected range
		 *
		 * Example: <code>this.dataPoints()</code>
		 * @return  {Number} of data points for the selected range
		 *****************************************************************************/
    	dataPoints:function () {
    		return this.rangeDataPoints;
    	},
    	
    	/******************************************************************************
		 * updateDynamicHighlights loops over the bound highlights and calculates
		 * a value based on the formula for the highlight and the selected range of data.
		 * The resulting value is inserted into the DOM element for this highlight.
		 * This is only called by this.update();
		 *
		 * Example: <code>this.updateDynamicHighlights()</code>
		 * @return  VOID
		 *****************************************************************************/ 
    	updateDynamicHighlights:function() {
    		//@TODO verify data calcuations, seems like dynamic might not be including end, or static includes an extra day.
    		for ( var highlight in this.dynamicHighlights) {
    			var highlightObj = this.dynamicHighlights[highlight];
    			var dataVal = 0;
    			with(this) {
    				dataVal = eval(highlightObj.formula);
    				
    				if (!isNaN(dataVal)) {
						dataVal = highlightObj.prefix + dataVal.toFixed(highlightObj.precision).formatNumber() + highlightObj.suffix;
					} else {
						dataVal = $.dr.stockChart.DATA_NOT_AVAILABLE
					}
				} 
				$(highlightObj.elemObj).html(dataVal);
    		}
    	} 
    }
    
	//some of these could get cleaned up
	$.dr.stockChart.DATA_NOT_AVAILABLE = "n/a"
    $.dr.stockChart.SUM = "sum";
    $.dr.stockChart.AVG = "avg";
    $.dr.stockChart.TEXT = "text";
    $.dr.stockChart.VALUE = "value";
    //these should be objects
    //$.extend(object, conent)
    $.dr.stockChart.DOY = new Date().dr_getDOY();
    
    /******************************************************************************
	 * dr.stockChart.STATIC_TYPES are types of calculations that are available for
	 * use with staticHighlights. Each type declares where in the data set should 
	 * the calculation begin from (offset) and how many days should be included (days).
	 *****************************************************************************/ 
    $.dr.stockChart.STATIC_TYPES = {
    
    	mtd: {
    		offset:0,
	    	//get date based on last date passed into data collection
	    	days:new Date().getDate()
    	},
    	
	    ytd:{
	    	offset:0,
	    	//get date based on last date passed into data collection
	    	days:$.dr.stockChart.DOY
	    },
	    
   		wtd:{
	    	offset:0,
	    	//get date based on last date passed into data collection
	    	days:new Date().getDay()+1
	    },
    	prev365:{
	    	offset:364,
	    	days:365
	    },
    	prev7:{
	    	offset:6,
	    	days:7
	    },
    	prev90:{
	    	offset:89,
	    	days:90
	    },
    	prev30:{
	    	offset:29,
	    	days:30
	    },
    	prev1:{
	    	offset:1,
	    	days:1
	    },
    	cur1:{
	    	offset:0,
	    	days:1
	    },
    	cur365:{
	    	offset:0,
	    	days:365
	    },
    	cur90:{
	    	offset:0,
	    	days:90
	    },
    
    	cur30:{
	    	offset:0,
	    	days:30
	    },
    
    	cur7:{
	    	offset:0,
	    	days:7
	    },
	    cur60: {
    		offset:0,
    		days:60
    	},
    	prev60: {
    		offset:59,
    		days:60
    	}
	}
    
   })(jQuery);
	/*
	 * These global variables are here for legacy support
	 * @TODO - Find all instances of these variables in use in both the jsp codebase
	 * and in the DR and GC javascript framework.
	 */
	


	//DR.Global.init
	//DR.Global.modalInit
	

	//DR.VERSION
	//DR.BUILD_ID
	//DR.FRAMEWORK_PATH
	//DR.IMAGE_PATH
	//DR.BLANK_PAGE_URL
	//DR.LOGIN_URL
	//DR.userdata
	//DR.USER_LOCALE
	//DR.IS_INTERNAL_USER

	
	/*
	 * Shortcuts to Utils
	 */
	var Utils = DR.Utils;
	Utils.Prompt = DR.Utils.prompt;
	Utils.confirm = DR.Utils.confirm;
	
	var submitActionForm = DR.Utils.FormUtils.submitActionForm;
	var BrowserDetect = DR.Utils.BrowserDetect;
	var FormUtils = DR.Utils.FormUtils;
	var Cookie = DR.Utils.Cookie;
	var PanelSet = DR.Widgets.PanelSet;
	var Toggle = DR.Utils.Toggle;
	var getElem = DR.Utils.getElem;
	
	/*
	 * Shortcuts to Widgets
	 */

	var ModalOverlay = DR.Widgets.ModalOverlay;
	var InlineModalOverlay = DR.Widgets.InlineModalOverlay;
	var iframeCallback = DR.Widgets.ModalOverlay.iframeCallback;

	
	/******************************************************************************
	 * DR.Widgets.FauxTree(objRef, "foo.bar.foobar", true)
	 *
	 * This constructs a new DR.Widgets.FauxTree object. DR.Widgets.FauxTree is an object that has childNodes
	 * collection of other DR.Widgets.FauxTrees. This simulates a tree in memory with javascript. This
	 * tree object then operates on a normal table, hence the DR.Widgets.FauxTree name. This object
	 * can toggle the visibility of any table row.
	 *
	 * Indentation and icons for the tree are controlled via css. To change the css
	 * behavior modify the appropriate css class defined in the DR.Widgets.FauxTree Constants.
	 *
	 * Steps to create a Faux Tree:
	 * 1) Create a root node for the tree - EXAMPLE: var root = new DR.Widgets.FauxTree(null, "", true, false);
	 *		- parent is null because it is the root.
	 *		- guid can be an empty string or null if one is not needed
	 *		- isDirectory must be true, since it will altimately have children
	 *		- hasCheckbox is true or false depending on whether there is a column of checkboxes before the tree
	 *
	 * 2) Add DR.Widgets.FauxTree.initConstants() to the onload of the page or any method that is
	 *                                 called from onload.
	 * 		- This is only needed if you want firefox compatibility
	 *
	 * 3) Add children either in the javascript on the page, like
	 * 		root.addItem("all.en_US", true);
	 *
	 *    OR INLINE as the table is being built
	 *
	 *		<tr id="all.en_US" class="collapsed" style="display:none;">
	 *			<td>
	 *				<a href="javascript:applyStylesTreeRoot.toggleDirectory('all.en_US');">EN_US</a>
	 *				<script type="text/javascript">
	 *					applyStylesTreeRoot.addItem("all.en_US", true);
	 *				</script>
	 *			</td>
	 *		... rest of table implementation ...
	 *		</tr>
	 *
	 *
	 * @param parentNode = DR.Widgets.FauxTree object reference to this nodes parent.
	 * @param guid = String Identifier used to toggle the visibility of the row.
	 *               This is also the path to the item in the tree.
	 * @param isDirectory = Boolean true if this object represents a directory
	 *                      in the tree.
	 *
	 * Internal Properties:
	 * childNodes = Asscociative Array (Hash Map) Indexed by the string of the path
	 * section that represents this level
	 * isExpanded = Boolean used to store if this object is expanded or not if an
	 * ancestor is collapsed.
	 * level = Integer - number of levels down this object is in the tree
	 *
	 *****************************************************************************/
	DR.Widgets.FauxTree = function(parentNode, guid, isDirectory, hasCheckbox, saveState, cookieName) {
	
		this.childNodes = [];
		this.parentNode = parentNode;
		/* used to track if the child was expanded when the parent was collapsed. Used to resume state */
		this.isExpanded = false;
		if (saveState!==undefined)
		{
			this.saveState = saveState;
			this.cookieName = cookieName;
		}else{
			this.saveState = false;
			this.cookieName = null;
		}
		this.isDirectory = isDirectory;
		this.hasCheckbox = (hasCheckbox === true) ? true : false;
		/* this should match the id of the table row for this item */
		this.guid = guid;
		//Store off reference to row. Make sure this does not cause a problem.
		this.obj = document.getElementById(this.guid);
		var guidArray = guid.split(DR.Widgets.FauxTree.PATH_SEPARATOR);
		this.level = guidArray.length;
		this.shortId = guidArray[guidArray.length-1];
	};
	
	/*****************************************************	*************************
	 * Separator between path levels
	 *****************************************************************************/
	DR.Widgets.FauxTree.PATH_SEPARATOR = ".";
	
	/******************************************************************************
	 * Column that is to be indented. 0 is the first column in the list. This
	 * usually the one to be indented.
	 * NOTE: All Faux Tree objects will use this column for indenting on a
	 * given page.
	 *****************************************************************************/
	DR.Widgets.FauxTree.INDENTED_COLUMN_POSITION = 0;
	
	/******************************************************************************
	 * CSS display property to be used when the row is visible. IE 6 uses block,
	 * Firefox uses table-row. If block is used in Firefox, table rows are treated
	 * as individual tables, columns do not line up and flow together.
	 *****************************************************************************/
	DR.Widgets.FauxTree.EXPANDED_CHILDREN_DISPLAY_VALUE = "";
	
	/******************************************************************************
	 * CSS display property to be used when the row is hidden. None works in all
	 * browsers.
	 *****************************************************************************/
	DR.Widgets.FauxTree.COLLAPSED_CHILDREN_DISPLAY_VALUE = "none";
	
	/******************************************************************************
	 * CSS class to be applied to the row (TR) when it is an empty directory.
	 *****************************************************************************/
	DR.Widgets.FauxTree.EMPTY_DIRECTORY_STYLE = "empty";
	
	/******************************************************************************
	 * CSS class to be applied to the row (TR) when its contents are expanded. This
	 * class sets a flag to draw the collapse icon and the open folder.
	 *****************************************************************************/
	DR.Widgets.FauxTree.EXPANDED_DIRECTORY_STYLE = "expanded";
	
	/******************************************************************************
	 * CSS class to be applied to the row (TR) when it is collapsed. This
	 * class sets a flag to draw the expand icon and the closed folder.
	 *****************************************************************************/
	DR.Widgets.FauxTree.COLLAPSED_DIRECTORY_STYLE = "collapsed";
	
	/******************************************************************************
	 * CSS class to be applied to the row (TR) when it is an item (not a directory). This
	 * class sets a flag to draw the item icon.
	 *****************************************************************************/
	DR.Widgets.FauxTree.ITEM_STYLE = "item";
	
	/******************************************************************************
	 * Constant used as ID of root node
	 *****************************************************************************/
	DR.Widgets.FauxTree.FAUX_TREE_ROOT = "FauxTreeRoot";
	
	/******************************************************************************
	 * "hash map" for faster lookup. This is shared acrossed all trees on a given page.
	 * Prefix your root node to avoid object collision.
	 *****************************************************************************/
	DR.Widgets.FauxTree.NODE_LOOKUP_TABLE = [];
	
	/******************************************************************************
	 * Count the nodes in the lookup table. Just used for debugging purposes.
	 *****************************************************************************/
	DR.Widgets.FauxTree.countNodes = function() {
		var num = 0;
	
		for (var i in DR.Widgets.FauxTree.NODE_LOOKUP_TABLE) {
			num++;
		}
	
		alert(num);
	};
	
	/******************************************************************************
	 * The child nodes collections might have other properties that are not
	 * DR.Widgets.FauxTrees, so use this function to test.
	 *****************************************************************************/
	   DR.Widgets.FauxTree.isNode = function(node) {
	    return node.guid;
	};
	
	
	/******************************************************************************
	 * DR.Widgets.FauxTree.initConstants(1)
	 *
	 * Call this on page load to initialize constants to support firefox and other
	 * standards based browsers. If this is not called only IE will work properly.
	 * This only needs to be called once per page load, even if there are multiple
	 * DR.Widgets.FauxTree instances on a given page.
	 *
	 * @param nestingLevel = (Optional) Integer represention which column to indent
	 *                       0 is the first position.
	 * @return VOID.
	 *****************************************************************************/
	DR.Widgets.FauxTree.initConstants = function(nestingLevel) {
		DR.Widgets.FauxTree.INDENTED_COLUMN_POSITION = (nestingLevel) ? nestingLevel : 0;
	};
	
	
	DR.Widgets.FauxTree.prototype = {
	
		/******************************************************************************
		 * obj.refreshTreeState()
		 *
		 * This function checks to see if the state is preserved in a cookie
		 * if so it calls the revertState() function which recurses starting at 
		 * the root node
		 *
		 * @return VOID
		 *****************************************************************************/
		refreshTreeState: function() {
			if (this.saveState)
			{
				DR.Widgets.FauxTree.NODE_LOOKUP_TABLE[DR.Widgets.FauxTree.FAUX_TREE_ROOT] = this;
				this.stateCookie = new DR.Utils.Cookie(this.cookieName);
				this.stateCookie.type="Array";
				this.stateCookie.load();
				this.findChild().revertState();
			}
		},
		
		/******************************************************************************
		 * obj.addItem("foo.bar.foobar", true)
		 *
		 * Call this on any Faux Tree object to add a new node. Path position is assumed
		 * to be from the location of this node down. It is not inclusive of this node.
		 * Generally, it is easiest to always call this from the root node object.
		 *
		 * @param path = String relative from the node object that it is called from.
		 * @param isDirectory = Boolean stating whether the item that is being added or
		 *                      not is a directory.
		 * @return VOID
		 *****************************************************************************/
		addItem: function(path, isDirectory) {
			
			var pathLevels = path.split(DR.Widgets.FauxTree.PATH_SEPARATOR);
			var lIsDirectory = true;
			
			//@TODO should enable childnodes if something was not a directory but now is
			if (pathLevels.length > 1) {
				//if not end of path automatically a directory
				lIsDirectory = true;
			} else {
				//normalize to booleen, just in case it wasn't passed in.
				lIsDirectory = (isDirectory) ? true : false;
			}
	
			//NOTE shift will remove the first element from the array equiv = pathLevels = pathLevels.slice(1, pathLevels.length);
			var currentPathSection = pathLevels.shift();
			var guid = null;
	
			if (this.guid === "") {
				guid = currentPathSection;
			} else {
				guid = this.guid + DR.Widgets.FauxTree.PATH_SEPARATOR + currentPathSection;
			}
	
	
			if (!this.childNodes[currentPathSection]) {
				//Create new level
				this.childNodes[currentPathSection] = new DR.Widgets.FauxTree(this, guid, lIsDirectory, this.hasCheckbox, this.saveState);
	
				//Add to look up table
				DR.Widgets.FauxTree.NODE_LOOKUP_TABLE[guid] = this.childNodes[currentPathSection];
			}
			
			//Recurse if not at the end of the path;
			if(pathLevels.length > 0) {
				this.childNodes[currentPathSection].addItem(pathLevels.join(DR.Widgets.FauxTree.PATH_SEPARATOR), isDirectory);
			}
		},
	
		/******************************************************************************
		 * obj.findItem("foo.bar.foobar")
		 *
		 * Call this to find an item in the tree. The path that is passed in is assumed
		 * to be relative from the calling node object. This will recursively call itself
		 * until it reaches the end of the supplied path.
		 *
		 * @param path = String relative from the node object that it is called from.
		 * @return fauxTree Object or null if none is found.
		 *****************************************************************************/
		findItem: function(path) {
			return DR.Widgets.FauxTree.NODE_LOOKUP_TABLE[path];
			/*
			var pathLevels = path.split(DR.Widgets.FauxTree.PATH_SEPARATOR);
			//NOTE shift will remove the first element from the array equiv = pathLevels = pathLevels.slice(1, pathLevels.legth);
			var currentPathSection = pathLevels.shift();
			var currentLevelObj = this.childNodes[currentPathSection];
	
			if (pathLevels.length > 0) {
				if (currentLevelObj != null) {
					currentLevelObj = currentLevelObj.findItem(pathLevels.join(DR.Widgets.FauxTree.PATH_SEPARATOR));
				}
			}
	
			return currentLevelObj;
			*/
		},
	
		/******************************************************************************
		 * obj.toggleDirectory("foo.bar.foobar")
		 *
		 * NOTE: THIS IS ASSUMED THAT THIS IS ONLY CALLED FROM THE ROOT NODE!!!!
		 * Call this to toggle the state of item in the tree. The rowID that is passed is
		 assumed to be the full path from the root node and also the id of the row that
		 state is going to be toggled.
		 *
		 * @param rowID = row id for the row that is to be toggled and the full path to
		 * 					the object in the tree from the root node
		 * @return VOID
		 *****************************************************************************/
		toggleDirectory: function(rowId) {
			/* @TODO Make this traverse up the tree to the parent and build a full path
				so it does not have to be called from the root node
				or pass in an obj to the row */
	
			var rowObj = document.getElementById(rowId);
			var isExpanded = (rowObj.className.indexOf(DR.Widgets.FauxTree.EXPANDED_DIRECTORY_STYLE) != -1) ? true : false;
			var theDirectory = this.findItem(rowId);
	
			if (theDirectory.isDirectory) {
				if (isExpanded) {
					theDirectory.collapse();
					if (this.saveState)
					{
						this.stateCookie.removeArrayValue(theDirectory.shortId);
					}
				} else {
					theDirectory.expand();
					if (this.saveState)
					{
						this.stateCookie.addArrayValue(theDirectory.shortId);
					}
				}
			}
		},
	
		/******************************************************************************
		 * obj.findChild()
		 *
		 * Call this to find the child of the root.
		 *
		 * Can be used with expandAll() like so:
		 * obj.findChild().expandAll()
		 *
		 * @return child
		 *****************************************************************************/
		findChild: function() {
			var child;
	    	for(var i in this.childNodes){
	    		child = this.childNodes[i];
	    		break;
	    	}
	    	return child;
	
		},
	
		/******************************************************************************
		 * obj.expandAll()
		 *
		 * Call this to expand all items in the tree.
		 *
		 * @return VOID
		 *****************************************************************************/
		expandAll: function() {
	
		    this.obj.style.display = DR.Widgets.FauxTree.EXPANDED_CHILDREN_DISPLAY_VALUE;
	
		    if (this.isDirectory) {
					if (this.hasChildren() === 0) {
						this.obj.className = DR.Widgets.FauxTree.EMPTY_DIRECTORY_STYLE;
					} else {
						this.obj.className = (this.isExpanded) ? DR.Widgets.FauxTree.EXPANDED_DIRECTORY_STYLE : DR.Widgets.FauxTree.COLLAPSED_DIRECTORY_STYLE;
					}
				} else {
					this.obj.className = DR.Widgets.FauxTree.ITEM_STYLE;
				}
			//Adding the css class could be slow. Could move to an init function instead.
			$('>td:not(.actionCol)', this.obj).eq(0).addClass('first level' + this.level);

			// if this is a directory, expand it and show the children
	        if (this.isDirectory) {
	        	this.expand();
	    		for (var i in this.childNodes) {
	              if (DR.Widgets.FauxTree.isNode(this.childNodes[i])) {
		    	    var childNode = this.childNodes[i];
			    	childNode.expandAll();
	              }
	    		}
	        }
		},
	
		/******************************************************************************
		 * obj.revertState()
		 *
		 * Call this to expand all items in the tree.
		 *
		 * @return VOID
		 *****************************************************************************/
		revertState: function() {
			
			if (this.saveState)
			{
				var cookieArray = this.getCookieArray();
		
				if (this.isDirectory)
				{
					var found = false;
					if (cookieArray.length>0)
					{
						var i =0;
						while (!found && i<cookieArray.length) 
						{
							if (cookieArray[i]==this.shortId)
							{
								found=true;
								this.expand();
							}
							i++;
						}
					}
					if (found)
					{
						for (var j in this.childNodes) {
						  if (DR.Widgets.FauxTree.isNode(this.childNodes[j])) {
							var childNode = this.childNodes[j];
							childNode.revertState();
						  }
						}
					}
				}
			}
		},
	
		/******************************************************************************
		 * PRIVATE INSTANCE METHODS
		 *****************************************************************************/
	
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.expandNRestoreChildrenState()
		 *
		 * Recursive companion for obj.expand(). This will recursive scan through
		 * the calling objects children and restore the expand/collapse state for every
		 * descendent. Expand/Collapse state is determnined from obj.isExpanded value.
		 *
		 * @return VOID
		 *****************************************************************************/
		expandNRestoreChildrenState: function() {
		    this.obj.style.display = DR.Widgets.FauxTree.EXPANDED_CHILDREN_DISPLAY_VALUE;
	
		    if (this.isDirectory) {
					if (this.hasChildren() === 0) {
						this.obj.className = DR.Widgets.FauxTree.EMPTY_DIRECTORY_STYLE;
					} else {
						this.obj.className = (this.isExpanded) ? DR.Widgets.FauxTree.EXPANDED_DIRECTORY_STYLE : DR.Widgets.FauxTree.COLLAPSED_DIRECTORY_STYLE;
					}
				} else {
					this.obj.className = DR.Widgets.FauxTree.ITEM_STYLE;
				}
			//Adding the css class could be slow. Could move to an init function instead.
			$('>td:not(.actionCol)', this.obj).eq(0).addClass('first level' + this.level);
	
			if (this.saveState)
			{
	
				var cookieArray = this.getCookieArray();
				var found = false;
				if (cookieArray.length>0)
				{
					var i =0;
					while (!found && i<cookieArray.length) 
					{
						if (cookieArray[i]==this.shortId)
						{
							this.isExpanded = true;
						}
						i++;
					}
				}
			}
	
			if (this.isExpanded) {
	    		for (var j in this.childNodes) {
	              if (DR.Widgets.FauxTree.isNode(this.childNodes[j])) {
		    	    var childNode = this.childNodes[j];
			    	childNode.expandNRestoreChildrenState();
	              }
	    		}
	        }
		},
	
		hasChildren: function() {
			for (var i in this.childNodes) {
	          if (DR.Widgets.FauxTree.isNode(this.childNodes[i])) {
				return true;
	          }
			}
			return false;
		},
	
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.collapseNStoreChildrenState()
		 *
		 * Recursive companion for obj.collapse(). This will recursive scan through
		 * the calling objects descendents and set the display to
		 * DR.Widgets.FauxTree.COLLAPSED_CHILDREN_DISPLAY_VALUE
		 *
		 * @return VOID
		 *****************************************************************************/
		collapseNStoreChildrenState: function() {
			for (var i in this.childNodes) {
	          if (DR.Widgets.FauxTree.isNode(this.childNodes[i])) {
				this.childNodes[i].obj.style.display = DR.Widgets.FauxTree.COLLAPSED_CHILDREN_DISPLAY_VALUE;
				this.childNodes[i].collapseNStoreChildrenState();
	          }
			}
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.expand()
		 *
		 * Set object style to DR.Widgets.FauxTree.EXPANDED_DIRECTORY_STYLE, and call
		 * this.expandNRestoreChildrenState() to restore expand/collapse state for all
		 * descendents.
		 *
		 * @return VOID
		 *****************************************************************************/
		expand: function() {
			this.isExpanded = true;
			this.expandNRestoreChildrenState();
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.getCookieArray()
		 *
		 * retrieves the cookie values from the cookie attached to the root tree
		 *
		 * @return ARRAY
		 *****************************************************************************/
		getCookieArray: function() {
			return DR.Widgets.FauxTree.NODE_LOOKUP_TABLE[DR.Widgets.FauxTree.FAUX_TREE_ROOT].stateCookie.arrayValues;
		},
	
		/******************************************************************************
		 * PRIVATE - this should only be called internally
		 *
		 * obj.collapse()
		 *
		 * Set object style to DR.Widgets.FauxTree.COLLAPSED_DIRECTORY_STYLE, and call
		 * this.collapseNStoreChildrenState() to hide all descendents.
		 *
		 * @return VOID
		 *****************************************************************************/
		collapse: function() {
			this.isExpanded = false;
			this.obj.className = DR.Widgets.FauxTree.COLLAPSED_DIRECTORY_STYLE;
			this.collapseNStoreChildrenState();
		}
	};

	
	 /******************************************************************************
	 * @constructor
	 *
	 * DR.Widgets.PanelSet()
	 * 
	 * The PanelSet is a UI utility oject that allows the creation of a resizeable
	 * "split" panel set.
	 *
	 * @TO-DO - Make a vertical split "type", some code has been stubbed out but
	 * not tested on an actual page
	 *
	 * Example code to create a  PanelSet:
	 *
	 * var catalogSplitPanel = new DR.Widgets.PanelSet('TwoColumn','catalogTreeContainer');
	 * 		catalogSplitPanel.setColumns('catalogTreeLeftPanel','catalogTreeRightPanel');
	 * 		catalogSplitPanel.setDefaultPanelSize(720, 430);
	 * 		catalogSplitPanel.setColumn1DefaultWidth(250);
	 * 		catalogSplitPanel.setColumn1MinWidth(100);
	 * 		catalogSplitPanel.setColumn2MinWidth(150);
	 * 		catalogSplitPanel.setStateCookieID('catalogTree');
	 * 		catalogSplitPanel.setResizeCallback(adjustListScroller);
	 * 		catalogSplitPanel.init();
	 * 
	 * Arguments:
	 * 
	 * @param {String} layout 	==> Defines the rows, columns
	 * @param {String} id 		==> String ID of the panelset
	 *
	 * Internal Properties:
	 * 
	 * id 						==> ID of the panelset, used for cookie
	 * type			 			==> Defines the rows, columns
	 * container 				==> HTML DIV object that is the outer box
	 * column1 					==> ID of column 2
	 * column1Width 			==> Current width of column 1 in pixels
	 * column2Width 			==> Current width of column 2 in pixels
	 * panelWidth 				==> Width of panel object in pixels
	 * panelHeight 				==> Height of panel object in pixels
	 * handleWidth 				==> Width of the draggable handle
	 * column1MinWidth 			==> Minimum width of column 1
	 * column2MinWidth 			==> Minimum width of column 2
	 * dragObject 				==> Reference to a DR.Utils.DragObject class
	 * resizeCallback 			==> Optional function that fires when dragging
	 *								operation has ended
	 *
	 * @return PanelSet
	 *
	 *****************************************************************************/
	DR.Widgets.PanelSet = function(obj)
	{
		this.layout = 'TwoColumn';
		this.sidebarOpenCSSClass = 'sidebarOpen';
		this.sidebarClosedCSSClass = 'sidebarClosed';
		this.buttonSelectedCSSClass = 'selected';
		this.column1Open=true;
		this.container = (typeof obj=="string") ? document.getElementById(obj) :  obj;
		this.defaultSearchField = null;
		this.column1Button = null;
		this.column1 = null;
		this.column2 = null;
		this.column1Width = 200;
		this.column2Width = null;
		this.panelWidth = 720;
		this.panelHeight = 430;
		this.autoHeightSizing=true;
		this.handleWidth = 10;
		this.leftPadding = 0;
		this.column1MinWidth = 170;
		this.column2MinWidth = 170;
		this.dragObject = null;
		this.resizeCallback = null;
		this.saveCookieState=false;
		this.saveUserDataState=true;
		this.stateCookie = null;
		this.stateCookieID = null;
		this.dataTableContainer = null;
	};
	
	DR.Widgets.PanelSet.prototype = {
		
		/******************************************************************************
		 * @public
		 *
		 * obj.init()
		 *
		 * Load in the cookie state, and then refresh and display the interface
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		init : function()
		{
			this.loadState();
			
			var self = this;
			var fnOnresize = window.onresize;
			var winOnresize = function(){self.refreshPanelSize();self.refresh();};
			window.onresize  = function(){winOnresize(); if(typeof(fnOnresize)=='function'){fnOnresize();}};
			
			var fnOnload,winOnload;
				
			function cleanupEvents()
			{
				// The following lines prevent a memory leak in Internet Explorer from the closure type of leak
				// We need to detach all the functions that were dynamically assigned to any DOM elements		
				window.detachEvent("onresize",winOnload);
				window.detachEvent("onresize",winOnresize);
				window.detachEvent("onunload",cleanupEvents);
			}
				
			if($.browser.msie)
			{
				if(parseInt($.browser.version,10) < 7)
				{
					if(this.column2){
						var d = this.column2.getElementsByTagName('div');
						for(var i=0; i<d.length; i++)
						{
							var c = d[i].className;
							if(c)
							{
								if(c.indexOf('dataTableContainer')>-1)
								{
									this.dataTableContainer = d[i];
									break;
								}
							}
						}
					}
				}
				fnOnload = window.onload;
				winOnload = function(){self.drawInterface();};
				window.onload  = function(){winOnload(); if(typeof(fnOnload)=='function'){fnOnload();}};
	
				if (window.attachEvent){
					window.attachEvent("onunload",cleanupEvents);
				}
			}
			else
			{
				this.drawInterface();
			}
		},
	
	
		/******************************************************************************
		 * @public
		 *
		 * obj.drawInterface()
		 *
		 * Position the drag handles and refresh the interface.
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		drawInterface : function()
		{	
			this.refreshPanelSize();
			this.attachHandles();
			this.refresh();
			this.show();
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.setColumn1Id()
		 *
		 * Sets the the reference up to the left column (column1) in the panel set.
		 * 
		 * @param {String} id 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setColumn1Id: function(id)
		{
			this.column1 = document.getElementById(id);
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.setColumn2Id()
		 *
		 * Sets the the reference up to the right column (column2) in the panel set.
		 *
		 * @param {String} id 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setColumn2Id: function(id)
		{
			this.column2 = document.getElementById(id);
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.setColumn1Width()
		 *
		 * Sets the width of column1
		 * 
		 * @param {String} id 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setColumn1Width: function(w)
		{
			this.column1Width  = parseInt(w,10);
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.show()
		 *
		 * Sets the visibility of the panel to visible, if it is currently hidden
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		show: function()
		{
			this.container.style.visibility='visible';
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.setPanelSize()
		 *
		 * Sets the panelWidth and panelHeight as integers
		 * 
		 * @param {Integer} w Width of the panel
		 * @param {Integer} h Height of the panel
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setPanelSize: function(w,h)
		{
			if(w!==undefined && h!==undefined)
			{
				this.panelWidth = parseInt(w,10);
				this.panelHeight = parseInt(h,10);
			}
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.setPanelHeight()
		 *
		 * Sets the panelHeight as integers
		 * 
		 * @param {Integer} h Height of the panel
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setPanelHeight: function(h)
		{
			if(h!==undefined)
			{
				this.autoHeightSizing=false;
				this.panelHeight = parseInt(h,10);
			}
		},
		
		/******************************************************************************
		 * @private
		 *
		 * obj.refreshPanelSize()
		 *
		 * Sets the panelWidth and panelHeight as integers
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		refreshPanelSize: function(w,h)
		{
			if($.browser.msie)
			{	
				this.panelWidth = this.container.offsetWidth;
				if(this.autoHeightSizing && parseInt($.browser.version,10) > 6)
				{
					this.panelHeight = jQuery("TABLE.panelTable",this.container)[0].offsetHeight;
				}
			}
			else
			{
				this.panelWidth = this.container.offsetWidth;
			}
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.setColumn1DefaultWidth()
		 *
		 * Sets the width of the column 1 in case saveState is not enabled
		 * 
		 * @param {Integer} w Width of column 1
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setColumn1DefaultWidth: function(w)
		{
			if (w!==undefined)
			{
				this.column1Width = parseInt(w,10);
			}
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.setColumn2DefaultWidth()
		 *
		 * Sets the width of the column 2 in case saveState is not enabled
		 * 
		 * @param {Integer} w Width of column 2
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setColumn2DefaultWidth: function(w)
		{
			if (w!==undefined)
			{
				this.column2Width = parseInt(w,10);
			}
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.setColumn1MinWidth()
		 *
		 * Sets the minium width of column 1
		 * 
		 * @param {Integer} w 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setColumn1MinWidth: function(w)
		{
			if (w!==undefined)
			{
				this.column1MinWidth = parseInt(w,10);
			}
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.setColumn1ButtonId()
		 *
		 * Sets the button for column 1, this is used when toggling the visiblity
		 * of the column
		 * 
		 * @param {String} id 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setColumn1ButtonId: function(id)
		{
			if (id!==undefined)
			{
				this.column1Button = document.getElementById(id);
			}
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.setDefaultSearchFocusFieldId()
		 *
		 * Sets the button for column 1, this is used when toggling the visiblity
		 * of the column
		 * 
		 * @param {String} id 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setDefaultSearchFocusFieldId: function(id)
		{
			if (id!==undefined)
			{
				this.defaultSearchField = document.getElementById(id);
			}
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.setUserDataStorageIds()
		 *
		 * Sets the user data storage names
		 * 
		 * @param {String} pageName 
		 * @param {String} setting 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setUserDataStorageIds: function(pageName, setting)
		{
			if (pageName!==undefined && setting!==undefined)
			{
				this.userDataPageName = pageName;
				this.userDataSetting = setting;
			}
		},
	
		/*****************************************************************************
		 * @public
		 *
		 * obj.setColumn2MinWidth()
		 *
		 * Sets the minium width of column 2
		 * 
		 * @param {Integer} w 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setColumn2MinWidth: function(w)
		{
			if (w!==undefined)
			{
				this.column2MinWidth = parseInt(w,10);
			}
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.getColumn1Width()
		 *
		 * Gets the width of the column 1 
		 * 
		 * @return Integer
		 * 
		 *****************************************************************************/
		getColumn1Width: function()
		{
			return this.column1Width;
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.getColumn2Width()
		 *
		 * Gets the width of the column 2 
		 * 
		 * @return Integer
		 * 
		 *****************************************************************************/
		getColumn2Width: function()
		{
			return this.column2Width;
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.setResizeCallback()
		 *
		 * @param {Function} func Function that is called when resize operation ends
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setResizeCallback: function(func)
		{
			if (typeof func == 'function')
			{
				this.resizeCallback = func;
			}
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.setStateCookieID()
		 *
		 * Enables saving state of the panel set
		 *
		 * @param {String} cookieId 
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		setStateCookieID: function(cookieId)
		{
			this.saveCookieState=true;
			this.stateCookieID = cookieId +'_LeftWidth';
		},
	
	
		/******************************************************************************
		 * @private
		 *
		 * obj.loadState()
		 *
		 * Loads a cookie if the saveState flag is set. If the cookie contains a value
		 * it sets the appropiate dimensions
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		loadState: function()
		{
			if(this.saveCookieState && this.stateCookie===null)
			{
				this.stateCookie = new DR.Utils.Cookie(this.stateCookieID);
				this.stateCookie.load();
				var v = this.stateCookie.value;
				if (v!==null)
				{
					this.column1Width = parseInt(v,10);
				}
			}
		},
		
		/******************************************************************************
		 * @private
		 *
		 * obj.saveState()
		 *
		 * Saves state of panel using either cookies or user data storage
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		saveState: function(stateType)
		{
			if(this.saveUserDataState && $.dr.userdata !== null)
			{
				if(stateType=='width')
				{
					$.dr.userdata.save(this.userDataPageName,this.userDataSetting+"Width",this.column1Width,'String');		
				}else{
					var state = '';
					if(!this.column1Open)
					{
						state = 'collapsed';
					}
					$.dr.userdata.save(this.userDataPageName,this.userDataSetting+"Collapsed",state,'String');
				}
	
			}
			else if(this.saveCookieState && this.stateCookie===null)
			{
				this.stateCookie.setValue(''+this.column1Width+'');
			}
		},
		
	
		/******************************************************************************
		 * @private
		 *
		 * obj.attachHandles()
		 *
		 * Creates the handles which are absolute positioned and float above the
		 * panels.
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		attachHandles: function()
		{
			var classType;
			if (this.layout=='TwoColumn')
			{
				classType = 'H';
			}
			else if (this.layout=='TwoRow')
			{
				classType = 'V';
			}
			var self = this;
			this.hiddenHandle = document.createElement('div');
			this.hiddenHandle.style.position = 'absolute';
			this.hiddenHandle.style.top = '0px';
			this.hiddenHandle.style.display = 'none';
			this.staticHandle = document.createElement('div');
			this.staticHandle.style.position = 'absolute';
			this.staticHandle.style.top = '0px';
			this.staticHandle.style.display = 'block';
			function handleOnMousedown(event){self.initDrag(event);}
			this.staticHandle.onmousedown=handleOnMousedown;
			this.hiddenHandle.className = 'splitContainerHiddenHandle'+classType;
			this.staticHandle.className = 'splitContainerHandle'+classType;
			this.container.appendChild(this.staticHandle);
			this.container.appendChild(this.hiddenHandle);
			
			function cleanupEvents()
			{
				// The following lines prevent a memory leak in Internet Explorer from the closure type of leak
				// We need to detach all the functions that were dynamically assigned to any DOM elements		
				self.staticHandle.detachEvent("onmousedown",handleOnMousedown);
				window.detachEvent("onunload",cleanupEvents);
			}
			
			if (window.attachEvent){
				window.attachEvent("onunload",cleanupEvents);
			}
			
		},
		
		/******************************************************************************
		 * @private
		 *
		 * obj.refresh()
		 *
		 * Sets the position of the panels and handles based on the widths set 
		 * on the PanelSet object. When done it calls the resizeCallback function
		 * if it has been set.
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		refresh: function()
		{
	
			var h = this.panelHeight-2;
			
			if(this.hiddenHandle){
				if($.browser.msie) {
					// IE6 and IE7 would pass this test
					if(this.autoHeightSizing)
					{
						
						//DR_Utils_Logger.log('refresh: ' + h );
						//this.container.style.height = (h+2)+'px';
					}
					this.hiddenHandle.style.height = (h+2)+'px';
					this.staticHandle.style.height = (h+2)+'px';
				}
				else{
					this.hiddenHandle.style.height = '100%';
					this.staticHandle.style.height = '100%';
				}
			}
			
			this.refreshColumn1Width();
			
			if(!($.browser.msie && parseInt($.browser.version, 10) < 7))
			{
				this.fixColumn1Width();
			}else{
				
				this.column2Width = this.container.offsetWidth - this.column1Width;
				if(this.dataTableContainer){
					this.dataTableContainer.style.width = (this.column2Width-20) + "px";
				}
			}
			
			if(this.hiddenHandle){
				this.hiddenHandle.style.left = (this.column1Width)+'px';
				this.staticHandle.style.left = (this.column1Width)+'px';
			}
			
			if (typeof this.resizeCallback == 'function')
			{
				this.resizeCallback();
			}
		},
		
		/******************************************************************************
		 * @private
		 *
		 * obj.fixColumn1Width()
		 *
		 * Gets the actual column1 width
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		fixColumn1Width: function(event)
		{ 
			if(this.container.className.indexOf(this.sidebarClosedCSSClass) == -1)
			{
				var a = this.column1.childNodes;
				for( var i = 0; i < a.length; i++ )
				{
					if(a[i].tagName)
					{
						
						var newW = (a[i].offsetWidth);
						if(jQuery.browser.safari){
							newW = newW + 2;
						}
						this.column1.style.width = newW+"px";
						this.column1Width = newW+this.leftPadding;
					}
				}
			}
		},
		
		/******************************************************************************
		 * @private
		 *
		 * obj.refreshColumn1Width()
		 *
		 * Sets the width of the left panel
		 * 
		 * @return VOID
		 * 
		 *****************************************************************************/
		refreshColumn1Width: function(event)
		{
			this.column1.style.width = (this.column1Width - this.leftPadding)+ 'px';
		},
		
		/******************************************************************************
		 * @private
		 * 
		 * obj.initDrag()
		 *
		 * Initilizes mouse and element properties
		 * 
		 * Load up the dragObject and assign the call back functions to it
		 * 
		 * @return VOID
		 *****************************************************************************/
		initDrag: function(event)
		{
			if (this.dragObject===null)
			{
				this.dragObject = new DR.Utils.DragObject(this.hiddenHandle);
				this.dragObject.setType('PanelSet',this);
				this.dragObject.setMoveDragCallback(true);
				this.dragObject.setStopDragCallback(true);
			}
			this.dragObject.initDrag(event);
		},
		
		/******************************************************************************
		 * @private
		 *
		 * obj.moveDrag()
		 *
		 * This function fires when the user has clicked down on a draggable area
		 * and has started to move the mouse, so we show the hidden handle
		 * 
		 * @return VOID
		 *****************************************************************************/
		moveDrag: function(x,y)
		{
			this.hiddenHandle.style.display = 'block';
		},
		
		/******************************************************************************
		 * @private
		 *
		 * obj.stopDrag()
		 *
		 * When the user lets up on the mouse, the drag operation ends which triggers
		 * this function. We set the new dimensions of the panel, and then refresh 
		 * the user interface
		 * 
		 * @return VOID
		 *****************************************************************************/
		stopDrag: function(x,y)
		{
			if (this.layout=='TwoColumn'){
				this.column1Width =  parseInt(this.hiddenHandle.style.left,10);
				this.saveState('width');
			}
			this.dragObject.isDragging=false;
			this.dragObject.isInitialized=false;
			this.hiddenHandle.style.display = 'none';
			this.refresh();
			if(typeof this.resizeCallback == 'function'){
				this.resizeCallback(this.column1Width);
			}
		},
		
		/******************************************************************************
		 * @public
		 *
		 * obj.hideColumn1()
		 *
		 * Makes column1 hidden
		 * 
		 * @return VOID
		 *****************************************************************************/
		hideColumn1: function()
		{
			if($.browser.msie)
			{	
				this.column1.style.display = 'none';
			}
			$(this.container).removeClass(this.sidebarOpenCSSClass).addClass(this.sidebarClosedCSSClass);
			$(this.column1Button).removeCSS('selected');
			this.column1Open=false;
			this.saveState('column1Visible');
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.showColumn1()
		 *
		 * Makes column1 visible
		 * 
		 * @return VOID
		 *****************************************************************************/
		showColumn1: function()
		{
			if($.browser.msie)
			{	
				this.column1.style.display = 'block';
			}
			$(this.container).removeClass(this.sidebarClosedCSSClass).addClass(this.sidebarOpenCSSClass);
			$(this.column1Button).addClass(this.buttonSelectedCSSClass);
			if(this.defaultSearchField)
			{
				this.defaultSearchField.focus();
				this.defaultSearchField.select();
			}
			this.column1Open=true;
			this.saveState('column1Visible');
		},
	
		/******************************************************************************
		 * @public
		 *
		 * obj.toggleColumn1()
		 *
		 * Toggles visiblity of column1
		 * 
		 * @return VOID
		 *****************************************************************************/
		toggleColumn1: function()
		{
			if(this.container.className.indexOf(this.sidebarClosedCSSClass) > -1)
			{
		 		this.showColumn1();
			}else{
				this.hideColumn1();
			}
		}
	};
	/******************************************************************************
	 * @constructor
	 *
	 * TreeMenu()
	 *
	 * The TreeMenu class handles the behavior for a UL/LI based tree menu.<br />
	 * Each menu can have an unlimited depth, because of the css rules<br />
	 *<br />
	 * Steps to create an Inline Modal Overlay:<br />
	 * 1) Write out menu to the page, using a standard unordered list<br />
	 * 2) Set the label onclick function<br />
	 *<br />
	 * Example of unordered list HTML for a tree menu.<br />
	 *<br />
	 *<code>
	 *	<ul>
	 *		<li class="treeNodeOpen" id="treeRootNode_801700"><div><span onclick="catalogTree.toggleNode(this);" >&nbsp;</span><a href="#" onclick="catalogTree.selectNode(this);return false;" >Motorola Corp. (801700)</a></div>
	 *		<ul id="treeRootNode_801700_child" >
	 *			<li class="treeNodeClosed" id="treeNode_716900"><div><span onclick="catalogTree.toggleNode(this);" >&nbsp;</span><a href="#" onclick="catalogTree.selectNode(this);return false;" >Mobile Devices (716900)</a></div>
	 *			<ul id="treeNode_716900_child" >
	 *				<li class="treeNodeEmpty" id="treeNode_722200"><div><span onclick="catalogTree.toggleNode(this);" >&nbsp;</span><a href="#" onclick="catalogTree.selectNode(this);return false;" >Alltel (722200)</a></div></li>
	 *				<li class="treeNodeEmpty" id="treeNode_717300"><div><span onclick="catalogTree.toggleNode(this);" >&nbsp;</span><a href="#" onclick="catalogTree.selectNode(this);return false;" >Cingular Wireless (717300)</a></div></li>
	 *				<li class="treeNodeEmpty" id="treeNode_727000"><div><span onclick="catalogTree.toggleNode(this);" >&nbsp;</span><a href="#" onclick="catalogTree.selectNode(this);return false;" >Cricket Communications (727000)</a></div></li>
	 *			</ul>
	 *		</ul>
	 *	</ul>
	 *</code><br />
	 * Example javascript code to add a tree menu to the page.<br />
	 *<br />
	 *<code> 
	 *		function myLabelFunction(nodeId){
	 *			alert(nodeId)
	 *		}
	 *
	 *		var catalogTree = new TreeMenu();
	 *			catalogTree.setLabelOnlick(myLabelFunction);
	 *</code><br />
	 * Internal Properties:<br />
	 *<br />
	 * currentTreeNodeId 			==> ID of currently selected tree node<br />
	 * currentTreeNodeHasChildren	==> Does selelcted node have children<br />
	 * defaultNodeId 				==> Node to select if saveState not enabled<br />
	 * saveState 					==> Should the cookie state be saved in cookie<br />
	 * stateCookie 					==> Array of open tree nodes<br />
	 * cookieName 					==> Name of cookie to save state to<br />
	 * stateCookieSelected 			==> ID of last selected node ID<br />
	 * cookieSelectedName 			==> Name of last selected cookie<br />
	 * rootNodeCookie 				==> Stores the node ID of the root node<br />
	 * ready 						==> Is the tree built and ready to be used<br />
	 *****************************************************************************/
	DR.Widgets.TreeMenu = function(containerId)
	{
		this.container = $('#'+containerId)[0];
		this.currentTreeNodeId=null;
		this.currentTreeNodeHasChildren=false;
		this.labelOnclick=null;
		this.defaultNodeId = "";
		this.saveState=false;
		this.saveSelectedItem = "";
		this.stateCookie=null;
		this.cookieName = "";
		this.stateCookieSelected=null;
		this.cookieSelectedName = "";
		this.rootNodeCookie=null;
		this.rootNodeCookieID="";
		this.ready=true;
		this.checkBrowser();
	};
	
	
	DR.Widgets.TreeMenu.prototype = {
		
		/******************************************************************************
		 * Example: <code>obj.selectNode (obj)</code>
		 * @param {Object} obj Variable of type HTML Element Object
		 * @return VOID
		 *****************************************************************************/
		selectNode: function(obj)
		{
			var node = null;
			var autoSroll=false;
	
			if (typeof obj == 'object')
			{
				node = obj.parentNode.parentNode;
			}
			else if (typeof obj == 'string')
			{
				node = document.getElementById(obj);
				autoSroll=true;
			}
			else{
				return null;
			}
	
			var id = node.id;
				id = id.replace('treeNode_','');
			var nodeId = id;
				id = id.replace('treeRoot_Node_','');
	
			var child = document.getElementById(node.id+'_child');
	
			if (node.className=='treeNodeClosed' || node.className=='treeNodeClosedSelected' )
			{
				if (child)
				{
					node.className='treeNodeOpenSelected';
					child.style.display = 'block';
				}else{
					node.className='treeNodeEmptySelected';
				}
				this.saveNodeState(id,"selected");
			}
			else if (node.className=='treeNodeOpen')
			{
				if (child)
				{
					child.style.display = 'block';
					node.className='treeNodeOpenSelected';
				}
				this.saveNodeState(id,"selected");
			}
			else if (node.className=='treeNodeEmptyOpen' || node.className=='treeNodeEmpty' || node.className=='treeNodeEmptySelected')
			{
				node.className='treeNodeEmptySelected';
				this.saveNodeState(id,"selected");
			}else if (node.className=='doc'){
				node.className='docSelected';
				this.saveNodeState(id,"selected");
			}
	
			if (!this.ready)
			{
				// make sure that if we are selecting a node that it is visible to the user
				// only need to do this while running through revertState function
				this.makeVisible(node);
				if (this.browserType == 'IE'){
					// IE has bug where it needs to sleep for a while before scrolling into view
					var oSelf = this;
					var func = function(){oSelf.scrollToNode(node);};
					window.setTimeout(func,100);
				}else{
					this.scrollToNode(node);
				}
	
			}
	
			if (autoSroll)
			{
				this.scrollToNode(node);
			}
	
			this.setCurrentNodeOff(node.id);
	
			if (!child){
				this.currentTreeNodeHasChildren = false;
			}else{
				if (child.childNodes.length>0)
				{
					this.currentTreeNodeHasChildren = true;
				}
			}
	
			this.currentTreeNodeId = node.id;
	
			if (typeof this.labelOnclick == 'function')
			{
				this.labelOnclick(id,node.id);
			}
	
		},
		
		scrollToNode: function(node){
			var xpos = node.offsetLeft;
			var ypos = node.offsetTop;
			this.container.scrollTop = Math.max(ypos-28,0);
			this.container.scrollLeft = xpos;
		},
	
		/******************************************************************************
		 * Example: <code>obj.toggleNode (obj)</code>
		 * @param {Object} obj Variable of type HTML Element Object
		 * @return VOID
		 *****************************************************************************/
		toggleNode: function(obj)
		{
			var node = null;
	
			if (typeof obj == 'object')
			{
				node = obj.parentNode.parentNode;
			}
			else if (typeof obj == 'string')
			{
				if(obj.length==0){
					log('hi')
				}
				node = document.getElementById(obj);
			}
			else{
				return null;
			}
	
			var id = node.id;
			id = id.replace('treeNode_','');
	
			var child = document.getElementById(node.id+'_child');
	
			if (node.className=='treeNodeClosed' )
			{
				if (child)
				{
					node.className='treeNodeOpen';
					child.style.display = 'block';
					this.saveNodeState(id,"open");
				}else{
					node.className='treeNodeEmpty';
				}
			}
			else if ( node.className=='treeNodeClosedSelected' )
			{
				node.className='treeNodeOpenSelected';
				child.style.display = 'block';
				this.saveNodeState(id,"open");
			}
			else if (node.className=='treeNodeOpen')
			{
				if (child)
				{
					child.style.display = 'none';
					node.className='treeNodeClosed';
					this.saveNodeState(id,"closed");
				}
			}
			else if (node.className=='treeNodeOpenSelected')
			{
				if (child)
				{
					child.style.display = 'none';
					node.className='treeNodeClosedSelected';
					this.saveNodeState(id,"closed");
				}
			}
		},
	
		/******************************************************************************
		 * If saveState is enabled for the tree, we save the state of the node<br />
		 * Example: <code>obj.saveNodeState (id,state)</code>
		 * @param {String} id The node id
		 * @param {String} state The state to save, open or closed or selected
		 *
		 * @return VOID
		 *
		 *****************************************************************************/
		saveNodeState: function(id,state)
		{
			if (typeof id == 'string' && this.ready)
			{
				if (this.saveState)
				{
					if (state=="open")
					{
						this.stateCookie.addArrayValue(id);
					}
					else if (state=="closed")
					{
						this.stateCookie.removeArrayValue(id);
					}
					else if (state=="selected"){
						this.stateCookie.addArrayValue(id);
					}
				}
				if(this.saveSelectedItem  && state=="selected"){
					this.stateCookieSelected.setValue(id);
				}
			}
		},
	
	
		/******************************************************************************
		 * @private
		 * Example: <code>obj.setCurrentNodeOff (id)</code>
		 * @param {String} id Variable of type string
		 * @return VOID
		 *****************************************************************************/
		setCurrentNodeOff: function(id)
		{
			if (this.currentTreeNodeId!==null && this.currentTreeNodeId!=id)
			{
				var node = document.getElementById(this.currentTreeNodeId);
				if (node){
					if (node.className=='docSelected'){
						node.className='doc';
					}else if (this.currentTreeNodeHasChildren){
						node.className='treeNodeOpen';
					}else{
						node.className='treeNodeEmpty';
					}
				}
			}
		},
	
		/******************************************************************************
		 * When the labelonlick function is run, the ID for the node will be sent
		 * to the labelOnclick function<br />
		 * Example: <code>obj.setLabelOnlick (func)</code>
		 * @param {Function} func Variable of type FUNCTION
		 * @return VOID
		 *****************************************************************************/
		setLabelOnlick: function(func)
		{
			if (typeof func == 'function')
			{
				this.labelOnclick = func;
			}
		},
	
		/******************************************************************************
		 * If set, this node will be opened during the revertState function, if
		 * no cookie has been set, or the root node id has changed<br />
		 * Example: <code>obj.setDefaultNodeId()</code>
		 * @param {String} id String ID of a node
		 * @return VOID
		 *****************************************************************************/
		setDefaultNodeId: function(id)
		{
			if (typeof id == 'string')
			{
				this.defaultNodeId = id;
			}
		},
	
		/******************************************************************************
		 * If the root node id changes, we clear all the cookies for the tree, because
		 * we are assuming that there has been a change of catalog.<br />
		 * Example: <code>obj.setRootNodeId()</code>
		 * @param {String} id String ID of the root node
		 * @return VOID
		 *****************************************************************************/
		setRootNodeId: function(id)
		{
			if (typeof id == 'string')
			{
				this.rootNodeCookie = new DR.Utils.Cookie(this.cookieName+"_rootID");
				this.rootNodeCookie.type="Single";
				this.rootNodeCookie.load();
				var v = this.rootNodeCookie.value;
				if (v!=id && v!=="" && v!==null){
					if(this.saveState){this.stateCookie.clear();}
					if(this.saveSelectedItem){this.stateCookieSelected.clear();}
					this.initCookies();
				}
				this.rootNodeCookie.setValue(id);
			}
		},
	
		/******************************************************************************
		 * Navigates up the tree a level<br />
		 * Example: <code>obj.goUp()</code>
		 * @return VOID
		 *****************************************************************************/
		goUp: function()
		{
			var node = document.getElementById(this.currentTreeNodeId);
			if (node)
			{
				var parentNode = node.parentNode.parentNode;
				this.selectNode(parentNode.id);
			}
		},
	
		/******************************************************************************
		 * Remember the entire state of the tree with a cookie
		 * Example: <code>obj.enableSaveState(cookieName)</code>
		 * @param {String} cookieName Name of the cookie that the state of the tree will be saved into
		 * @return VOID
		 *****************************************************************************/
		enableSaveState: function(cookieName)
		{
			if (typeof cookieName == 'string')
			{
				this.cookieName=cookieName;
				this.saveState = true;
				this.saveSelectedItem=true;
				this.initCookies();
			}
		},
		
		/******************************************************************************
		 * Remember the last selected item with a cookie
		 * Example: <code>obj.enableLastSelected(cookieName)</code>
		 * @param {String} cookieName Name of the cookie that the state of the tree will be saved into
		 * @return VOID
		 *****************************************************************************/
		enableLastSelected: function(cookieName)
		{
			if (typeof cookieName == 'string')
			{
				this.cookieName=cookieName;
				this.saveSelectedItem=true;
				this.initCookies();
			}
		},
		/******************************************************************************
		 * @private
		 * Initializes the cookies
		 * Example: <code>obj.initCookies()</code>
		 * @return VOID
		 *****************************************************************************/
		initCookies: function()
		{
			if (this.cookieName!=="")
			{
				
				if(this.saveState){
					this.stateCookie = new DR.Utils.Cookie(this.cookieName);
					this.stateCookie.type="Array";
					this.stateCookie.load();
				}
				if(this.saveSelectedItem){
					this.cookieSelectedName = this.cookieName+"_on";
					this.stateCookieSelected = new DR.Utils.Cookie(this.cookieSelectedName);
					this.stateCookieSelected.type="Single";
					this.stateCookieSelected.load();
				}
			}
		},
	
		/******************************************************************************
		 * Example: <code>obj.refreshState()</code>
		 * @param {String} id Variable of type string
		 * @return VOID
		 *****************************************************************************/
		refreshState: function() {
			if (this.cookieName!==""){
				this.ready=false;
				
				if(this.saveState){
					var a = this.stateCookie.arrayValues;
					for(var i=0;i<a.length;i++)
					{
						if (a[i]!=v){
							if(document.getElementById('treeNode_'+a[i]))
							{
								this.toggleNode('treeNode_'+a[i]);
							}else{
								// A category stored in the cookie has been deleted, so remove
								// from the cookie array
								this.stateCookie.removeArrayValue(a[i]);
							}
						}
					}
				}
				
				if(this.saveSelectedItem){
					var v =  this.stateCookieSelected.value;
					if (v!=="" && v!==null && document.getElementById('treeNode_'+v))
					{
						this.selectNode('treeNode_'+v);
					}else{
						if (this.defaultNodeId!==""){
							this.selectNode(this.defaultNodeId);
						}
					}					
				}

				this.ready=true;
			}
		},
	
		/******************************************************************************
		 * @private
		 * Initializes the cookies<br />
		 * Example: <code>obj.makeVisible(obj)</code>
		 * @param {Object} obj
		 * @return VOID
		 *****************************************************************************/
	
		makeVisible: function(obj)
		{
			// get parent node of element
			var p = obj.parentNode;
			// while parent node exists and isn't body or html tag
			while (p)
			{
				if ((p.tagName == "BODY") || (p.tagName == "HTML"))
				{
					break;
				}
				if (p.className == "treeNodeClosed")
				{
					this.toggleNode(p.id);
				}
	
				// climb up DOM tree
				p = p.parentNode;
			}
			// passed both valid input field and parent nodes aren't hidden, set focus.
		},
	
		/******************************************************************************
		 * @private
		 * This function checks the browser type<br />
		 * Example: <code>obj.checkBrowser()</code>
		 * @return VOID
		 *****************************************************************************/
		checkBrowser: function ()
		{
			if(document.all)
			{
				this.browserType = 'IE';
			}
			else
			{
				this.broswerType = 'Standard';
			}
		}
	};
